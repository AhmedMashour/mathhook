# MathHook 0.1 AI Agent Action Guide
**Structured Task List for AI Agent Consumption**

**Purpose**: This document provides actionable, structured information for AI agents to understand and fix MathHook issues.
**Context**: See `0.1_RELEASE_READINESS_HUMAN.md` for detailed analysis.
**Priority Order**: P0 (Critical Blocker) → P1 (High) → P2 (Medium) → P3 (Low)

---

## AGENT EXECUTION PROTOCOL

When working on MathHook tasks:

1. **Always read CLAUDE.md first** - It is the single source of truth
2. **Check this file for task priority** - Work top-down (P0 → P1 → P2 → P3)
3. **Run tests after every change** - `cargo test -p mathhook-core`
4. **Verify doctests** - `cargo test --doc -p mathhook-core`
5. **Check no regressions** - Test count should never decrease
6. **Validate against SymPy** - When in doubt, check SymPy behavior

---

## P0: CRITICAL BLOCKERS (MUST FIX BEFORE 0.1)

### TASK P0-1: Implement Pattern Matching & Substitution System

**Status**: NOT STARTED
**Priority**: CRITICAL (BLOCKING)
**Estimated Effort**: 2-3 weeks
**Blocking**: Equation solving, integration by substitution, transformation rules

**Context**:
- SymPy has `expr.subs(x, value)` and `expr.match(pattern)`
- Symbolica has `expr.replace(&pattern, &replacement)`
- MathHook has NONE of this - completely missing

**Files to Create**:
```
crates/mathhook-core/src/pattern/mod.rs
crates/mathhook-core/src/pattern/substitution.rs
crates/mathhook-core/src/pattern/matching.rs
crates/mathhook-core/tests/pattern_tests.rs
```

**Required API**:
```rust
// In crates/mathhook-core/src/core/expression.rs or pattern/substitution.rs
impl Expression {
    /// Substitute a variable with a value
    /// Example: (x^2 + 2*x).subs(x, 3) → 15
    pub fn subs(&self, old: &Expression, new: &Expression) -> Expression {
        // TODO: Implement recursive substitution
        // Walk the expression tree
        // Replace all occurrences of `old` with `new`
        // Return new expression
    }

    /// Multiple simultaneous substitutions
    /// Example: (x + y).subs_multiple(&[(x, 1), (y, 2)]) → 3
    pub fn subs_multiple(&self, substitutions: &[(Expression, Expression)]) -> Expression {
        // TODO: Apply multiple substitutions in one pass
        // Avoid intermediate allocations
    }

    /// Pattern matching - returns bindings if match succeeds
    pub fn matches(&self, pattern: &Pattern) -> Option<HashMap<Symbol, Expression>> {
        // TODO: Implement pattern matching
        // Pattern: a*x^2 + b*x + c
        // Expression: 2*x^2 + 3*x + 1
        // Returns: {a: 2, b: 3, c: 1}
    }

    /// Replace pattern with replacement expression
    pub fn replace(&self, pattern: &Pattern, replacement: &Expression) -> Expression {
        // TODO: Find pattern matches and replace
        // Used for transformation rules
    }
}

/// Pattern representation
pub struct Pattern {
    // TODO: Define pattern structure
    // Support wildcards, constraints, recursive patterns
}
```

**Implementation Steps**:
1. Create `pattern/` module
2. Implement `Expression::subs()` for basic substitution
3. Add recursive tree walking
4. Handle edge cases (substituting x in sin(x), nested substitutions)
5. Implement `subs_multiple()` for efficiency
6. Add pattern matching infrastructure (Pattern struct)
7. Implement `matches()` for structural pattern matching
8. Implement `replace()` for transformation rules
9. Add comprehensive tests (50+ test cases)

**Tests Required**:
```rust
#[test]
fn test_basic_substitution() {
    let x = symbol!(x);
    let expr = expr!(x + 1);
    let result = expr.subs(&expr!(x), &Expression::integer(5));
    assert_eq!(result, Expression::integer(6));
}

#[test]
fn test_nested_substitution() {
    let x = symbol!(x);
    let expr = expr!(sin(x) + cos(x));
    let result = expr.subs(&expr!(x), &Expression::integer(0));
    // sin(0) + cos(0) should simplify to 1
    assert_eq!(result.simplify(), Expression::integer(1));
}

#[test]
fn test_multiple_substitution() {
    let x = symbol!(x);
    let y = symbol!(y);
    let expr = expr!(x + y);
    let result = expr.subs_multiple(&[
        (expr!(x), Expression::integer(1)),
        (expr!(y), Expression::integer(2)),
    ]);
    assert_eq!(result, Expression::integer(3));
}

#[test]
fn test_pattern_matching_quadratic() {
    // Pattern: a*x^2 + b*x + c
    // Should match: 2*x^2 + 3*x + 1
    // And extract: {a: 2, b: 3, c: 1}
}
```

**Verification**:
- [ ] All substitution tests pass
- [ ] Can verify equation solutions: `eq.subs(x, solution).simplify() == 0`
- [ ] Pattern matching extracts correct bindings
- [ ] No performance regressions (benchmark if needed)

**CLAUDE.md References**:
- Line 89-137: Mathematical Correctness Architecture
- Line 388-392: Substitution mechanism (currently missing)

---

### TASK P0-2: Fix Polynomial Solver Fake Roots

**Status**: BROKEN
**Priority**: CRITICAL (MATHEMATICAL CORRECTNESS)
**Estimated Effort**: 1 day (Option B) or 2-3 weeks (Option A)
**Blocking**: Polynomial equation solving

**Context**:
The polynomial solver adds FAKE placeholder roots when it can't find all roots. This is mathematically incorrect and violates CLAUDE.md's "Mathematical Correctness First" principle.

**Files to Fix**:
```
crates/mathhook-core/src/algebra/solvers/polynomial.rs
```

**Problematic Code Locations**:

**Lines 155-162 (Cubic solver)**:
```rust
// CURRENT (BROKEN):
while found_roots.len() < 3 {
    found_roots.push(Expression::function(
        "complex",
        vec![Expression::integer(0), Expression::integer(1)],
    ));
}

// FIX OPTION A (Implement proper cubic formula):
// Use Cardano's formula for cubic equations
// Handle all cases: three real roots, one real + two complex conjugates
// Estimated effort: 2-3 weeks

// FIX OPTION B (Return partial solutions - RECOMMENDED for 0.1):
// Just return found_roots as-is, don't pad with fakes
return SolverResult::Partial(found_roots);

// Add to SolverResult enum:
pub enum SolverResult {
    // ... existing variants
    Partial(Vec<Expression>),  // Some but not all roots found
}
```

**Lines 241-248 (Quartic solver)**:
```rust
// CURRENT (BROKEN):
while found_roots.len() < 4 {
    found_roots.push(Expression::function(
        "complex",
        vec![Expression::integer(0), Expression::integer(1)],
    ));
}

// FIX: Same as cubic - return Partial(found_roots)
```

**Lines 309-311 (Helper function)**:
```rust
// CURRENT (BROKEN):
fn find_remaining_cubic_roots(...) -> Vec<Expression> {
    // Simplified for TDD - return placeholder roots
    vec![Expression::integer(-1), Expression::integer(1)]  // FAKE!
}

// FIX: Either implement properly or remove this function
```

**Implementation Steps (Option B - RECOMMENDED)**:
1. Add `Partial(Vec<Expression>)` variant to `SolverResult` enum
2. Remove all `while found_roots.len() < N` loops
3. Return `SolverResult::Partial(found_roots)` instead
4. Update tests to expect `Partial` results
5. Document limitations in API docs
6. Remove or fix `find_remaining_cubic_roots()` function

**Tests to Update**:
```rust
#[test]
fn test_cubic_partial_solutions() {
    // x^3 - 1 = 0 has roots: 1, (-1 ± i√3)/2
    // If we only find x=1, return Partial([1])
    let result = solve_cubic(...);
    match result {
        SolverResult::Partial(roots) => {
            assert!(roots.len() >= 1);
            assert!(roots.len() <= 3);
            // Verify roots are correct (not fake)
        }
        _ => panic!("Expected partial solution"),
    }
}
```

**Verification**:
- [ ] No fake roots returned
- [ ] Partial solutions are mathematically correct
- [ ] All returned roots actually solve the equation
- [ ] Tests validate correctness of found roots
- [ ] Documentation explains `Partial` variant

**CLAUDE.md Violation**:
> "Mathematical Correctness First: Every mathematical operation must be correct in ALL cases. No exceptions."

---

### TASK P0-3: Fix All 103 Failing Doctests

**Status**: FAILING
**Priority**: CRITICAL (USER TRUST)
**Estimated Effort**: 1 week
**Blocking**: Documentation reliability

**Context**:
39% of documentation examples don't work. Users cannot trust the documentation.

**Affected Files** (46 failures across):
```
crates/mathhook-core/src/algebra/complex.rs
crates/mathhook-core/src/calculus/derivatives/basic.rs
crates/mathhook-core/src/calculus/derivatives/chain_rule.rs
crates/mathhook-core/src/calculus/derivatives/checker.rs
crates/mathhook-core/src/calculus/derivatives/higher_order.rs
crates/mathhook-core/src/calculus/derivatives/partial/*.rs (multiple files)
crates/mathhook-core/src/calculus/derivatives/power_rule.rs
crates/mathhook-core/src/calculus/integrals/*.rs
crates/mathhook-core/src/calculus/limits.rs
crates/mathhook-core/src/calculus/residues.rs
```

**Common Failure Patterns**:

**Pattern 1: Missing imports**
```rust
// BROKEN:
/// ```
/// let x = symbol!(x);
/// let derivative = expr.derivative(x);
/// ```

// FIX:
/// ```
/// use mathhook_core::prelude::*;
/// use mathhook_core::Derivative;  // Import trait
///
/// let x = symbol!(x);
/// let derivative = expr.derivative(x);
/// ```
```

**Pattern 2: Wrong method signatures**
```rust
// BROKEN (old API):
/// ```
/// let derivative = expr.derivative(&x, 1);  // Wrong signature
/// ```

// FIX (current API):
/// ```
/// use mathhook_core::Derivative;
/// let derivative = expr.derivative(x);  // No order parameter
/// // For higher order:
/// let second = expr.nth_derivative(x, 2);
/// ```
```

**Pattern 3: Methods that don't exist**
```rust
// BROKEN:
/// ```
/// let latex = expr.to_latex();  // Method doesn't exist this way
/// ```

// FIX:
/// ```
/// use mathhook_core::formatter::LaTeXFormatter;
/// let latex = expr.to_latex(&Default::default())?;  // Returns Result
/// ```
```

**Implementation Steps**:
1. Run `cargo test --doc -p mathhook-core` to see all failures
2. For each failure:
   - Identify the root cause (missing import, wrong API, non-existent method)
   - Fix the doctest example
   - Verify it compiles and runs
3. Group fixes by failure type for efficiency
4. Re-run after each batch of fixes
5. Verify final count: 0 failures

**Systematic Fix Process**:
```bash
# Step 1: Get list of all failures
cargo test --doc -p mathhook-core 2>&1 | grep "FAILED" > doctest_failures.txt

# Step 2: Fix each file systematically
# For each file in doctest_failures.txt:
#   - Read the file
#   - Find all /// ``` blocks
#   - Add missing imports
#   - Fix method signatures
#   - Mark as `no_run` if method truly doesn't exist yet

# Step 3: Verify
cargo test --doc -p mathhook-core

# Step 4: Ensure count is ZERO failures
```

**For Non-Existent Methods**:
If a method doesn't exist yet but is documented:
```rust
/// ```no_run
/// // This feature is planned for v0.2
/// let result = expr.fancy_method();
/// ```
```

**Verification**:
- [ ] `cargo test --doc -p mathhook-core` shows 0 failures
- [ ] All code examples compile
- [ ] All code examples run successfully
- [ ] Examples demonstrate actual working API

**CLAUDE.md Reference**:
- Documentation Standards section (lines 577-671)

---

### TASK P0-4: Add Number Type Arithmetic with Overflow Handling

**Status**: MISSING
**Priority**: CRITICAL (CORRECTNESS)
**Estimated Effort**: 1 week
**Blocking**: Safe arithmetic operations

**Context**:
The `Number` type has NO arithmetic trait implementations and ZERO checked arithmetic. Can silently overflow on integer operations.

**Files to Modify**:
```
crates/mathhook-core/src/core/number.rs
crates/mathhook-core/tests/number_arithmetic_tests.rs (create)
```

**Current State**:
- No `impl Add for Number`
- No `impl Sub for Number`
- No `impl Mul for Number`
- No `impl Div for Number`
- Zero uses of `checked_add`, `checked_mul`, etc.

**Required Implementation**:
```rust
// In crates/mathhook-core/src/core/number.rs

impl Add for Number {
    type Output = Result<Number, MathError>;

    fn add(self, other: Number) -> Result<Number, MathError> {
        match (self, other) {
            // Integer + Integer with overflow checking
            (Number::Integer(a), Number::Integer(b)) => {
                match a.checked_add(b) {
                    Some(result) => Ok(Number::Integer(result)),
                    None => {
                        // Promote to BigInt on overflow
                        Ok(Number::BigInteger(Box::new(
                            BigInt::from(a) + BigInt::from(b)
                        )))
                    }
                }
            }

            // Rational + Rational
            (Number::Rational(a), Number::Rational(b)) => {
                // Use BigRational arithmetic (already handles overflow)
                Ok(Number::Rational(Box::new(*a + *b)))
            }

            // Float + Float
            (Number::Float(a), Number::Float(b)) => {
                Ok(Number::Float(a + b))
            }

            // Mixed cases: promote to common type
            (Number::Integer(a), Number::Float(b)) => {
                Ok(Number::Float(a as f64 + b))
            }

            // ... handle all mixed cases
        }
    }
}

impl Mul for Number {
    type Output = Result<Number, MathError>;

    fn mul(self, other: Number) -> Result<Number, MathError> {
        match (self, other) {
            (Number::Integer(a), Number::Integer(b)) => {
                match a.checked_mul(b) {
                    Some(result) => Ok(Number::Integer(result)),
                    None => {
                        // Promote to BigInt on overflow
                        Ok(Number::BigInteger(Box::new(
                            BigInt::from(a) * BigInt::from(b)
                        )))
                    }
                }
            }

            // ... similar for other cases
        }
    }
}

impl Div for Number {
    type Output = Result<Number, MathError>;

    fn div(self, other: Number) -> Result<Number, MathError> {
        // Check for division by zero
        if other.is_zero() {
            return Err(MathError::DivisionByZero);
        }

        match (self, other) {
            (Number::Integer(a), Number::Integer(b)) => {
                if a % b == 0 {
                    Ok(Number::Integer(a / b))
                } else {
                    // Return rational for non-exact division
                    Ok(Number::Rational(Box::new(
                        BigRational::new(BigInt::from(a), BigInt::from(b))
                    )))
                }
            }

            // ... other cases
        }
    }
}

// Helper method
impl Number {
    pub fn is_zero(&self) -> bool {
        match self {
            Number::Integer(0) => true,
            Number::Float(f) if *f == 0.0 => true,
            Number::BigInteger(b) if b.is_zero() => true,
            Number::Rational(r) if r.is_zero() => true,
            _ => false,
        }
    }
}
```

**Tests Required**:
```rust
// In crates/mathhook-core/tests/number_arithmetic_tests.rs

#[test]
fn test_integer_overflow_promotes_to_bigint() {
    let a = Number::Integer(i64::MAX);
    let b = Number::Integer(1);
    let result = (a + b).unwrap();

    match result {
        Number::BigInteger(n) => {
            assert_eq!(*n, BigInt::from(i64::MAX) + BigInt::from(1));
        }
        _ => panic!("Expected BigInteger promotion on overflow"),
    }
}

#[test]
fn test_multiplication_overflow_promotes_to_bigint() {
    let a = Number::Integer(i64::MAX / 2);
    let b = Number::Integer(3);
    let result = (a * b).unwrap();

    match result {
        Number::BigInteger(_) => { /* OK */ }
        _ => panic!("Expected BigInteger promotion"),
    }
}

#[test]
fn test_division_by_zero_returns_error() {
    let a = Number::Integer(5);
    let b = Number::Integer(0);
    let result = a / b;

    assert!(result.is_err());
    match result {
        Err(MathError::DivisionByZero) => { /* OK */ }
        _ => panic!("Expected DivisionByZero error"),
    }
}

#[test]
fn test_rational_reduction() {
    let a = Number::Integer(6);
    let b = Number::Integer(4);
    let result = (a / b).unwrap();

    // Should reduce to 3/2
    match result {
        Number::Rational(r) => {
            assert_eq!(r.numer(), &BigInt::from(3));
            assert_eq!(r.denom(), &BigInt::from(2));
        }
        _ => panic!("Expected rational 3/2"),
    }
}

#[test]
fn test_precision_loss_warning_rational_to_float() {
    // When converting 1/3 to float, precision is lost
    // Document this clearly
}
```

**Implementation Steps**:
1. Define `MathError` enum if not exists (see P0-5)
2. Implement `Add` trait with checked arithmetic
3. Implement `Mul` trait with checked arithmetic
4. Implement `Sub` trait with checked arithmetic
5. Implement `Div` trait with division by zero check
6. Add `is_zero()` helper
7. Add comprehensive tests (20+ test cases)
8. Document overflow behavior in type documentation

**Verification**:
- [ ] All arithmetic operations use checked arithmetic
- [ ] Overflow promotes to BigInt
- [ ] Division by zero returns error
- [ ] Rational arithmetic reduces to lowest terms
- [ ] All tests pass

**CLAUDE.md Violation**:
> "Rational arithmetic overflow: Integer operations in Number type can overflow. Use checked arithmetic operations (checked_add, checked_mul, etc.). On overflow, promote to arbitrary precision BigInt or return an error. NEVER silently wrap."

---

### TASK P0-5: Implement Domain Error System

**Status**: MISSING
**Priority**: CRITICAL (CORRECTNESS)
**Estimated Effort**: 3-4 days
**Blocking**: Proper mathematical error handling

**Context**:
No error types exist for domain violations. Operations return symbolic "undefined" instead of proper errors.

**Files to Create/Modify**:
```
crates/mathhook-core/src/error.rs (create)
crates/mathhook-core/src/lib.rs (add pub use error::*)
crates/mathhook-core/src/simplify/arithmetic.rs (fix line 599-602)
crates/mathhook-core/tests/domain_error_tests.rs (create)
```

**Required Error Type**:
```rust
// In crates/mathhook-core/src/error.rs

use crate::core::expression::Expression;

#[derive(Debug, Clone, PartialEq)]
pub enum MathError {
    /// Domain error - operation not valid for given input
    DomainError {
        operation: String,
        value: Expression,
        reason: String,
    },

    /// Division by zero
    DivisionByZero,

    /// Undefined expression (e.g., 0^0)
    Undefined {
        expression: Expression,
        reason: String,
    },

    /// Numeric overflow
    NumericOverflow {
        operation: String,
    },

    /// Feature not yet implemented
    NotImplemented {
        feature: String,
    },

    /// Pole singularity (e.g., tan(π/2))
    Pole {
        function: String,
        at: Expression,
    },

    /// Branch cut issue for multi-valued function
    BranchCut {
        function: String,
        value: Expression,
    },
}

impl std::fmt::Display for MathError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            MathError::DomainError { operation, value, reason } => {
                write!(f, "Domain error in {}: {} ({})", operation, value, reason)
            }
            MathError::DivisionByZero => {
                write!(f, "Division by zero")
            }
            MathError::Undefined { expression, reason } => {
                write!(f, "Undefined: {} ({})", expression, reason)
            }
            MathError::NumericOverflow { operation } => {
                write!(f, "Numeric overflow in {}", operation)
            }
            MathError::NotImplemented { feature } => {
                write!(f, "Not yet implemented: {}", feature)
            }
            MathError::Pole { function, at } => {
                write!(f, "Pole singularity: {}({}) is undefined", function, at)
            }
            MathError::BranchCut { function, value } => {
                write!(f, "Branch cut: {}({}) requires domain specification", function, value)
            }
        }
    }
}

impl std::error::Error for MathError {}
```

**Update Existing Code**:
```rust
// In crates/mathhook-core/src/simplify/arithmetic.rs
// Lines 599-602 (CURRENT - BROKEN):
(Expression::Number(Number::Integer(0)), Expression::Number(Number::Integer(-1))) => {
    Expression::function("undefined".to_string(), vec![])  // BAD
}

// FIX:
// Change function signature to return Result:
pub fn simplify_power(base: &Expression, exp: &Expression) -> Result<Expression, MathError> {
    match (base, exp) {
        (Expression::Number(Number::Integer(0)), Expression::Number(Number::Integer(-1))) => {
            Err(MathError::DivisionByZero)
        }

        (Expression::Number(Number::Integer(0)), Expression::Number(Number::Integer(0))) => {
            Err(MathError::Undefined {
                expression: Expression::pow(
                    Expression::integer(0),
                    Expression::integer(0)
                ),
                reason: "0^0 is indeterminate".to_string(),
            })
        }

        // ... other cases that return Ok(Expression)
    }
}
```

**Domain Restriction Tests Required**:
```rust
// In crates/mathhook-core/tests/domain_error_tests.rs

#[test]
fn test_sqrt_negative_real_domain() {
    // In real domain, sqrt(-1) should error
    let expr = Expression::function("sqrt", vec![Expression::integer(-1)]);
    let result = expr.evaluate_real();  // Real domain evaluation

    match result {
        Err(MathError::DomainError { operation, .. }) => {
            assert_eq!(operation, "sqrt");
        }
        _ => panic!("Expected domain error for sqrt(-1) in real domain"),
    }
}

#[test]
fn test_log_zero() {
    let expr = Expression::function("log", vec![Expression::integer(0)]);
    let result = expr.evaluate();

    match result {
        Err(MathError::Pole { function, .. }) => {
            assert_eq!(function, "log");
        }
        _ => panic!("Expected pole error for log(0)"),
    }
}

#[test]
fn test_log_negative_real_domain() {
    let expr = Expression::function("log", vec![Expression::integer(-1)]);
    let result = expr.evaluate_real();

    match result {
        Err(MathError::BranchCut { function, .. }) => {
            assert_eq!(function, "log");
        }
        _ => panic!("Expected branch cut error"),
    }
}

#[test]
fn test_division_by_zero() {
    let expr = Expression::div(
        Expression::integer(1),
        Expression::integer(0)
    );
    let result = expr.evaluate();

    assert!(matches!(result, Err(MathError::DivisionByZero)));
}

#[test]
fn test_tan_pole() {
    use std::f64::consts::PI;
    let expr = Expression::function("tan", vec![
        Expression::float(PI / 2.0)
    ]);
    let result = expr.evaluate();

    match result {
        Err(MathError::Pole { function, .. }) => {
            assert_eq!(function, "tan");
        }
        _ => panic!("Expected pole error for tan(π/2)"),
    }
}

#[test]
fn test_zero_to_zero() {
    let expr = Expression::pow(
        Expression::integer(0),
        Expression::integer(0)
    );
    let result = expr.evaluate();

    match result {
        Err(MathError::Undefined { reason, .. }) => {
            assert!(reason.contains("indeterminate"));
        }
        _ => panic!("Expected undefined error for 0^0"),
    }
}
```

**Implementation Steps**:
1. Create `error.rs` with `MathError` enum
2. Add to lib.rs exports
3. Update function signatures to return `Result<Expression, MathError>`
4. Replace all symbolic "undefined" with proper errors
5. Add domain checks in function evaluation
6. Update simplification to propagate errors
7. Add comprehensive domain error tests (20+ cases)
8. Update documentation to show error handling

**Functions Needing Domain Checks**:
- `sqrt(x)` - real domain requires x ≥ 0
- `log(x)` - requires x > 0 (pole at 0, branch cut for x < 0)
- `tan(x)` - poles at x = π/2 + nπ
- `sec(x)`, `csc(x)` - similar poles
- `arcsin(x)`, `arccos(x)` - domain [-1, 1] in real numbers
- Division - denominator ≠ 0
- Power - 0^0, 0^(-n)

**Verification**:
- [ ] `MathError` enum defined with all variants
- [ ] All domain violations return proper errors
- [ ] No symbolic "undefined" returns
- [ ] All domain tests pass
- [ ] Error messages are helpful and clear

**CLAUDE.md Violation**:
> "Use `Result<Expression, DomainError>` for operations that can fail. Domain restrictions: Always check for division by zero, sqrt of negatives, log of non-positives"

---

## P1: HIGH PRIORITY (SHOULD HAVE FOR 0.1)

### TASK P1-1: Refactor Hardcoded Function Matching to Use Registry

**Status**: ARCHITECTURAL VIOLATION
**Priority**: HIGH
**Estimated Effort**: 1-2 weeks
**Impact**: Extensibility, maintainability

**Context**:
Functions are hardcoded in match statements instead of using the UniversalFunctionRegistry. This violates CLAUDE.md architectural guidelines.

**Files to Refactor**:
```
crates/mathhook-core/src/simplify/functions.rs
crates/mathhook-core/src/calculus/derivatives/chain_rule.rs (330 lines of hardcoded derivatives!)
crates/mathhook-core/src/functions/intelligence.rs (enhance registry)
```

**Current Violation** (`simplify/functions.rs`):
```rust
// CURRENT (WRONG):
pub fn simplify_function(name: &str, args: &[Expression]) -> Expression {
    let simplified_args: Vec<Expression> = args.iter().map(|arg| arg.simplify()).collect();

    match name {
        "sin" => match simplified_args.get(0) { ... },
        "cos" => match simplified_args.get(0) { ... },
        "tan" => ...,
        "exp" => ...,
        "ln" | "log" => ...,
        "sqrt" => ...,
        "abs" => ...,
        "factorial" => ...,
        _ => Expression::function(name, simplified_args),
    }
}
```

**Correct Architecture**:
```rust
// FIX:
pub fn simplify_function(name: &str, args: &[Expression]) -> Expression {
    let simplified_args: Vec<Expression> = args.iter().map(|arg| arg.simplify()).collect();

    // Use registry for O(1) lookup
    if let Some(intelligence) = UNIVERSAL_REGISTRY.get_function(name) {
        intelligence.simplify(&simplified_args)
    } else {
        Expression::function(name, simplified_args)
    }
}
```

**Current Violation** (`calculus/derivatives/chain_rule.rs`):
```rust
// CURRENT (WRONG) - 330 line match statement!:
pub fn get(name: &str, arg: &Expression, variable: Symbol) -> Expression {
    match name {
        "sin" => Expression::function("cos", vec![arg.clone()]),
        "cos" => Expression::mul(vec![Expression::integer(-1), Expression::function("sin", vec![arg.clone()])]),
        "tan" => ...,
        // ... 50+ more cases
        _ => Expression::derivative(...)
    }
}
```

**Correct Architecture**:
```rust
// FIX:
pub fn get(name: &str, arg: &Expression, variable: Symbol) -> Expression {
    if let Some(intelligence) = UNIVERSAL_REGISTRY.get_function(name) {
        intelligence.derivative(arg, variable)
    } else {
        // Generic derivative for unknown functions
        Expression::derivative(
            Expression::function(name, vec![arg.clone()]),
            variable
        )
    }
}
```

**Enhance UniversalFunctionRegistry**:
```rust
// In crates/mathhook-core/src/functions/intelligence.rs

pub struct FunctionIntelligence {
    pub name: String,
    pub properties: FunctionProperties,
    pub simplify: fn(&[Expression]) -> Expression,
    pub derivative: fn(&Expression, Symbol) -> Expression,  // ADD THIS
    pub evaluate: fn(&[Expression]) -> Result<Expression, MathError>,
    // ... other methods
}

impl UniversalFunctionRegistry {
    pub fn get_function(&self, name: &str) -> Option<&FunctionIntelligence> {
        self.functions.get(name)
    }

    // Initialize all elementary functions with their derivatives
    fn initialize_elementary(&mut self) {
        // Sin
        self.register(FunctionIntelligence {
            name: "sin".to_string(),
            simplify: |args| {
                // Special values: sin(0) = 0, sin(π/2) = 1, etc.
                // ... implementation
            },
            derivative: |arg, var| {
                // d/dx[sin(arg)] = cos(arg) * d/dx[arg]
                Expression::mul(vec![
                    Expression::function("cos", vec![arg.clone()]),
                    arg.derivative(var)
                ])
            },
            // ... other properties
        });

        // Cos
        self.register(FunctionIntelligence {
            name: "cos".to_string(),
            derivative: |arg, var| {
                // d/dx[cos(arg)] = -sin(arg) * d/dx[arg]
                Expression::mul(vec![
                    Expression::integer(-1),
                    Expression::function("sin", vec![arg.clone()]),
                    arg.derivative(var)
                ])
            },
            // ... other properties
        });

        // ... register all other functions
    }
}
```

**Implementation Steps**:
1. Enhance `FunctionIntelligence` struct with `simplify` and `derivative` function pointers
2. Update registry initialization to include these for all functions
3. Refactor `simplify/functions.rs` to use registry
4. Refactor `calculus/derivatives/chain_rule.rs` to use registry
5. Remove all hardcoded match statements
6. Add tests to ensure no regressions
7. Verify all existing tests still pass

**Migration Checklist**:
- [ ] Add `simplify` field to `FunctionIntelligence`
- [ ] Add `derivative` field to `FunctionIntelligence`
- [ ] Register all elementary functions with their simplification rules
- [ ] Register all elementary functions with their derivatives
- [ ] Refactor `simplify_function()` to use registry
- [ ] Refactor `chain_rule::get()` to use registry
- [ ] Remove hardcoded match statements
- [ ] Verify all tests pass (no regressions)

**Verification**:
- [ ] No more hardcoded function name matching in simplify/
- [ ] No more hardcoded function name matching in calculus/derivatives/
- [ ] All functions use registry
- [ ] Adding new function only requires registry registration
- [ ] Performance: O(1) lookup maintained

**CLAUDE.md Violation**:
> "NEVER hardcode function names in implementation logic. Use the UniversalFunctionRegistry for function-specific behavior."

---

### TASK P1-2: Complete Complex Number Arithmetic

**Status**: PARTIAL
**Priority**: HIGH
**Estimated Effort**: 3-5 days
**Impact**: Complex number support

**Context**:
Complex number structure exists but arithmetic operations are incomplete.

**Files to Modify**:
```
crates/mathhook-core/src/algebra/complex.rs
crates/mathhook-core/tests/complex_tests.rs
```

**Required Operations**:
```rust
// In crates/mathhook-core/src/algebra/complex.rs

impl Expression {
    /// Get real part of complex expression
    pub fn real(&self) -> Expression {
        match self {
            Expression::Complex(data) => data.real.clone(),
            Expression::Number(_) => self.clone(), // Real number
            Expression::Add(terms) => {
                Expression::add(terms.iter().map(|t| t.real()).collect())
            }
            // ... handle all expression types
            _ => Expression::function("Re", vec![self.clone()])
        }
    }

    /// Get imaginary part of complex expression
    pub fn imag(&self) -> Expression {
        match self {
            Expression::Complex(data) => data.imag.clone(),
            Expression::Number(_) => Expression::integer(0), // Real number has 0 imag
            Expression::Add(terms) => {
                Expression::add(terms.iter().map(|t| t.imag()).collect())
            }
            // ... handle all expression types
            _ => Expression::function("Im", vec![self.clone()])
        }
    }

    /// Complex conjugate
    pub fn conjugate(&self) -> Expression {
        match self {
            Expression::Complex(data) => {
                Expression::complex(
                    data.real.clone(),
                    Expression::mul(vec![Expression::integer(-1), data.imag.clone()])
                )
            }
            Expression::Number(_) => self.clone(),
            Expression::Add(terms) => {
                Expression::add(terms.iter().map(|t| t.conjugate()).collect())
            }
            Expression::Mul(factors) => {
                Expression::mul(factors.iter().map(|f| f.conjugate()).collect())
            }
            // ... handle all types
            _ => Expression::function("conjugate", vec![self.clone()])
        }
    }

    /// Absolute value (modulus) of complex number
    pub fn abs(&self) -> Expression {
        match self {
            Expression::Complex(data) => {
                // |a + bi| = sqrt(a^2 + b^2)
                Expression::function("sqrt", vec![
                    Expression::add(vec![
                        Expression::pow(data.real.clone(), Expression::integer(2)),
                        Expression::pow(data.imag.clone(), Expression::integer(2))
                    ])
                ])
            }
            Expression::Number(n) => {
                // Real number absolute value
                // ... implementation
            }
            _ => Expression::function("abs", vec![self.clone()])
        }
    }

    /// Argument (phase angle) of complex number
    pub fn arg(&self) -> Expression {
        match self {
            Expression::Complex(data) => {
                // arg(a + bi) = atan2(b, a)
                Expression::function("atan2", vec![
                    data.imag.clone(),
                    data.real.clone()
                ])
            }
            _ => Expression::function("arg", vec![self.clone()])
        }
    }

    /// Convert to polar form: r * exp(i*theta)
    pub fn to_polar(&self) -> Expression {
        let r = self.abs();
        let theta = self.arg();

        Expression::mul(vec![
            r,
            Expression::function("exp", vec![
                Expression::mul(vec![
                    Expression::symbol(Symbol::new("i")),
                    theta
                ])
            ])
        ])
    }

    /// Convert from polar form: r * exp(i*theta) -> a + bi
    pub fn from_polar(r: Expression, theta: Expression) -> Expression {
        // a = r * cos(theta)
        // b = r * sin(theta)
        Expression::complex(
            Expression::mul(vec![r.clone(), Expression::function("cos", vec![theta.clone()])]),
            Expression::mul(vec![r, Expression::function("sin", vec![theta])])
        )
    }
}

// Arithmetic operations
impl Expression {
    /// Add two complex expressions
    fn add_complex(&self, other: &Expression) -> Expression {
        // (a + bi) + (c + di) = (a+c) + (b+d)i
        let real = Expression::add(vec![self.real(), other.real()]);
        let imag = Expression::add(vec![self.imag(), other.imag()]);
        Expression::complex(real, imag)
    }

    /// Multiply two complex expressions
    fn mul_complex(&self, other: &Expression) -> Expression {
        // (a + bi)(c + di) = (ac - bd) + (ad + bc)i
        let a = self.real();
        let b = self.imag();
        let c = other.real();
        let d = other.imag();

        let real = Expression::add(vec![
            Expression::mul(vec![a.clone(), c.clone()]),
            Expression::mul(vec![Expression::integer(-1), b.clone(), d.clone()])
        ]);

        let imag = Expression::add(vec![
            Expression::mul(vec![a, d]),
            Expression::mul(vec![b, c])
        ]);

        Expression::complex(real, imag)
    }

    /// Divide complex expressions
    fn div_complex(&self, other: &Expression) -> Result<Expression, MathError> {
        // (a + bi) / (c + di) = [(a + bi)(c - di)] / (c^2 + d^2)
        let numerator = self.mul_complex(&other.conjugate());
        let denominator = Expression::add(vec![
            Expression::pow(other.real(), Expression::integer(2)),
            Expression::pow(other.imag(), Expression::integer(2))
        ]);

        // Check for division by zero
        if denominator.is_zero() {
            return Err(MathError::DivisionByZero);
        }

        Ok(Expression::div(numerator, denominator))
    }
}
```

**Tests Required**:
```rust
#[test]
fn test_complex_addition() {
    // (2 + 3i) + (4 + 5i) = 6 + 8i
    let a = Expression::complex(Expression::integer(2), Expression::integer(3));
    let b = Expression::complex(Expression::integer(4), Expression::integer(5));
    let result = a.add_complex(&b);

    assert_eq!(result.real(), Expression::integer(6));
    assert_eq!(result.imag(), Expression::integer(8));
}

#[test]
fn test_complex_multiplication() {
    // (2 + 3i)(4 + 5i) = 8 + 10i + 12i + 15i^2 = -7 + 22i
    let a = Expression::complex(Expression::integer(2), Expression::integer(3));
    let b = Expression::complex(Expression::integer(4), Expression::integer(5));
    let result = a.mul_complex(&b);

    assert_eq!(result.real(), Expression::integer(-7));
    assert_eq!(result.imag(), Expression::integer(22));
}

#[test]
fn test_complex_conjugate() {
    let z = Expression::complex(Expression::integer(3), Expression::integer(4));
    let conj = z.conjugate();

    assert_eq!(conj.real(), Expression::integer(3));
    assert_eq!(conj.imag(), Expression::integer(-4));
}

#[test]
fn test_complex_abs() {
    // |3 + 4i| = 5
    let z = Expression::complex(Expression::integer(3), Expression::integer(4));
    let abs = z.abs();

    assert_eq!(abs.simplify(), Expression::integer(5));
}

#[test]
fn test_polar_conversion() {
    let z = Expression::complex(Expression::integer(1), Expression::integer(1));
    let polar = z.to_polar();

    // Should be sqrt(2) * exp(i*pi/4)
    // Verify by converting back
    // ... implementation
}

#[test]
fn test_branch_cuts() {
    // sqrt(-1) should give i
    // log(-1) should give i*pi (principal branch)
    // ... implementation
}
```

**Implementation Steps**:
1. Implement `real()`, `imag()`, `conjugate()` methods
2. Implement `abs()` and `arg()` methods
3. Implement `to_polar()` and `from_polar()` conversions
4. Implement complex arithmetic: `add_complex()`, `mul_complex()`, `div_complex()`
5. Handle branch cuts for multi-valued functions
6. Add comprehensive tests (20+ cases)
7. Fix failing doctest in `algebra/complex.rs`

**Verification**:
- [ ] All complex arithmetic operations work
- [ ] Conjugate, abs, arg methods work
- [ ] Polar conversion works both ways
- [ ] Branch cuts handled correctly
- [ ] Doctest in `algebra/complex.rs` passes

---

### TASK P1-3: Complete Integration Table

**Status**: PARTIAL
**Priority**: HIGH
**Estimated Effort**: 1 week
**Impact**: Calculus completeness

**Context**:
Integration has basic power rule but many elementary integrals are missing or stubbed out.

**Files to Modify**:
```
crates/mathhook-core/src/calculus/integrals/basic.rs
crates/mathhook-core/src/calculus/integrals/by_parts.rs (implement)
crates/mathhook-core/src/calculus/integrals.rs (enable modules)
crates/mathhook-core/tests/integration_tests.rs
```

**Required Integrals for 0.1**:

**Elementary Functions**:
```rust
// Power rule (already implemented - verify correctness)
// ∫ x^n dx = x^(n+1)/(n+1) + C  (n ≠ -1)
// ∫ x^(-1) dx = ln|x| + C

// Exponential
// ∫ e^x dx = e^x + C
// ∫ a^x dx = a^x / ln(a) + C

// Trigonometric
// ∫ sin(x) dx = -cos(x) + C
// ∫ cos(x) dx = sin(x) + C
// ∫ tan(x) dx = -ln|cos(x)| + C = ln|sec(x)| + C
// ∫ sec^2(x) dx = tan(x) + C
// ∫ csc^2(x) dx = -cot(x) + C
// ∫ sec(x)tan(x) dx = sec(x) + C

// Inverse trig (if functions exist)
// ∫ 1/sqrt(1-x^2) dx = arcsin(x) + C
// ∫ 1/(1+x^2) dx = arctan(x) + C

// Hyperbolic
// ∫ sinh(x) dx = cosh(x) + C
// ∫ cosh(x) dx = sinh(x) + C
```

**Implementation**:
```rust
// In crates/mathhook-core/src/calculus/integrals/basic.rs

pub fn integrate_elementary(expr: &Expression, var: Symbol) -> Option<Expression> {
    match expr {
        // Power rule
        Expression::Pow(base, exp) if base == &Expression::symbol(var) => {
            // ∫ x^n dx = x^(n+1)/(n+1) + C
            let new_exp = Expression::add(vec![exp.clone(), Expression::integer(1)]);
            Some(Expression::div(
                Expression::pow(base.clone(), new_exp.clone()),
                new_exp
            ))
        }

        // Exponential: e^x
        Expression::Function(name, args) if name == "exp" && args.len() == 1 => {
            if args[0] == Expression::symbol(var) {
                Some(Expression::function("exp", vec![Expression::symbol(var)]))
            } else {
                None // Need substitution
            }
        }

        // Sine
        Expression::Function(name, args) if name == "sin" && args.len() == 1 => {
            if args[0] == Expression::symbol(var) {
                Some(Expression::mul(vec![
                    Expression::integer(-1),
                    Expression::function("cos", vec![Expression::symbol(var)])
                ]))
            } else {
                None
            }
        }

        // Cosine
        Expression::Function(name, args) if name == "cos" && args.len() == 1 => {
            if args[0] == Expression::symbol(var) {
                Some(Expression::function("sin", vec![Expression::symbol(var)]))
            } else {
                None
            }
        }

        // Logarithm: 1/x
        Expression::Pow(base, exp)
            if base == &Expression::symbol(var)
            && exp == &Expression::integer(-1) => {
            Some(Expression::function("ln", vec![
                Expression::function("abs", vec![Expression::symbol(var)])
            ]))
        }

        // ... add all other elementary integrals

        _ => None
    }
}
```

**Integration by Parts (Simple Cases)**:
```rust
// In crates/mathhook-core/src/calculus/integrals/by_parts.rs

/// Integration by parts: ∫ u dv = uv - ∫ v du
pub fn by_parts(expr: &Expression, var: Symbol) -> Option<Expression> {
    // Pattern matching for common cases:
    // ∫ x * sin(x) dx
    // ∫ x * exp(x) dx
    // ∫ ln(x) dx (treat as ln(x) * 1)

    // For 0.1, implement simple cases only
    // Full general implementation can wait for 0.2

    match expr {
        Expression::Mul(factors) if factors.len() == 2 => {
            // Try different u/dv assignments
            for i in 0..2 {
                let u = &factors[i];
                let dv = &factors[1-i];

                if let Some(result) = try_by_parts(u, dv, var) {
                    return Some(result);
                }
            }
            None
        }
        _ => None
    }
}

fn try_by_parts(u: &Expression, dv: &Expression, var: Symbol) -> Option<Expression> {
    // du = derivative of u
    let du = u.derivative(var);

    // v = integral of dv
    let v = integrate(dv, var)?;

    // Check if ∫ v du is simpler than ∫ u dv
    // ... implementation

    // Return uv - ∫ v du
    Some(Expression::add(vec![
        Expression::mul(vec![u.clone(), v.clone()]),
        Expression::mul(vec![
            Expression::integer(-1),
            integrate(&Expression::mul(vec![v, du]), var)?
        ])
    ]))
}
```

**Tests Required**:
```rust
#[test]
fn test_integrate_power_rule() {
    // ∫ x^2 dx = x^3/3 + C
    let x = symbol!(x);
    let expr = expr!(x ^ 2);
    let result = integrate(&expr, x);

    let expected = Expression::div(
        expr!(x ^ 3),
        Expression::integer(3)
    );

    assert_eq!(result, expected);
}

#[test]
fn test_integrate_exponential() {
    // ∫ e^x dx = e^x + C
    let x = symbol!(x);
    let expr = Expression::function("exp", vec![expr!(x)]);
    let result = integrate(&expr, x);

    assert_eq!(result, expr);
}

#[test]
fn test_integrate_sin() {
    // ∫ sin(x) dx = -cos(x) + C
    let x = symbol!(x);
    let expr = Expression::function("sin", vec![expr!(x)]);
    let result = integrate(&expr, x);

    let expected = Expression::mul(vec![
        Expression::integer(-1),
        Expression::function("cos", vec![expr!(x)])
    ]);

    assert_eq!(result, expected);
}

#[test]
fn test_integrate_by_parts_x_sin() {
    // ∫ x*sin(x) dx = -x*cos(x) + sin(x) + C
    let x = symbol!(x);
    let expr = Expression::mul(vec![
        expr!(x),
        Expression::function("sin", vec![expr!(x)])
    ]);
    let result = integrate_by_parts(&expr, x).unwrap();

    // Verify result
    // ... implementation
}
```

**Implementation Steps**:
1. Audit current integration table
2. Implement all elementary function integrals
3. Test each integral (derivative should give back original)
4. Implement simple integration by parts cases
5. Enable commented-out modules in `integrals.rs`
6. Add 30+ integration tests
7. Validate against SymPy

**Verification**:
- [ ] All elementary integrals work
- [ ] Derivative of integral gives original expression
- [ ] Integration by parts works for simple cases
- [ ] All integration tests pass
- [ ] Cross-validated against SymPy

---

### TASK P1-4: Implement System of Linear Equations Solver

**Status**: UNCLEAR
**Priority**: HIGH
**Estimated Effort**: 1 week
**Impact**: Practical use cases

**Context**:
File exists but implementation status unclear. Need Gaussian elimination for linear systems.

**Files to Modify**:
```
crates/mathhook-core/src/algebra/solvers/systems.rs
crates/mathhook-core/src/matrix/operations.rs (if matrix-based)
crates/mathhook-core/tests/system_solver_tests.rs
```

**Required Functionality**:
```rust
// In crates/mathhook-core/src/algebra/solvers/systems.rs

pub struct SystemSolver {
    // Configuration options
}

impl SystemSolver {
    /// Solve system of linear equations: Ax = b
    ///
    /// # Arguments
    /// * `equations` - Vector of linear equations
    /// * `variables` - Vector of variables to solve for
    ///
    /// # Returns
    /// - `Single(solution)` - Unique solution
    /// - `NoSolution` - Inconsistent system
    /// - `InfiniteSolutions` - Underdetermined system
    pub fn solve_linear_system(
        &self,
        equations: &[Expression],
        variables: &[Symbol],
    ) -> SolverResult {
        // Convert to matrix form: Ax = b
        let (matrix_a, vector_b) = self.to_matrix_form(equations, variables)?;

        // Use Gaussian elimination
        let (reduced, constants) = self.gaussian_elimination(matrix_a, vector_b)?;

        // Back substitution
        self.back_substitution(reduced, constants, variables)
    }

    fn to_matrix_form(
        &self,
        equations: &[Expression],
        variables: &[Symbol],
    ) -> Result<(Matrix, Vec<Expression>), SolverError> {
        // Extract coefficients for each variable
        let mut matrix_rows = Vec::new();
        let mut constants = Vec::new();

        for eq in equations {
            let mut row = Vec::new();

            // Get coefficient for each variable
            for var in variables {
                let coeff = self.extract_coefficient(eq, var);
                row.push(coeff);
            }

            // Get constant term
            let constant = self.extract_constant(eq, variables);

            matrix_rows.push(row);
            constants.push(constant);
        }

        Ok((Matrix::new(matrix_rows), constants))
    }

    fn gaussian_elimination(
        &self,
        matrix: Matrix,
        constants: Vec<Expression>,
    ) -> Result<(Matrix, Vec<Expression>), SolverError> {
        // Row reduction to echelon form
        // ... implementation
    }

    fn back_substitution(
        &self,
        reduced: Matrix,
        constants: Vec<Expression>,
        variables: &[Symbol],
    ) -> SolverResult {
        // Solve from bottom up
        // ... implementation
    }
}
```

**Example Usage**:
```rust
// Solve:
// 2x + 3y = 8
// 4x - y = 2

let x = symbol!(x);
let y = symbol!(y);

let eq1 = Expression::equation(
    expr!((2*x) + (3*y)),
    Expression::integer(8)
);

let eq2 = Expression::equation(
    expr!((4*x) - y),
    Expression::integer(2)
);

let solver = SystemSolver::new();
let result = solver.solve_linear_system(&[eq1, eq2], &[x, y]);

match result {
    SolverResult::Single(solution) => {
        // solution is HashMap<Symbol, Expression>
        assert_eq!(solution[&x], Expression::integer(1));
        assert_eq!(solution[&y], Expression::integer(2));
    }
    _ => panic!("Expected unique solution"),
}
```

**Tests Required**:
```rust
#[test]
fn test_2x2_system_unique_solution() {
    // 2x + 3y = 8
    // 4x - y = 2
    // Solution: x=1, y=2
}

#[test]
fn test_3x3_system() {
    // x + y + z = 6
    // 2x - y + z = 3
    // x + 2y - z = 1
    // Solution: x=1, y=2, z=3
}

#[test]
fn test_inconsistent_system() {
    // x + y = 1
    // x + y = 2
    // No solution
}

#[test]
fn test_underdetermined_system() {
    // x + y = 1
    // (only 1 equation, 2 unknowns)
    // Infinite solutions
}
```

**Implementation Steps**:
1. Design API for system solver
2. Implement matrix conversion (equations → Ax = b)
3. Implement Gaussian elimination
4. Implement back substitution
5. Handle special cases (no solution, infinite solutions)
6. Add comprehensive tests
7. Integration with existing solver infrastructure

**Verification**:
- [ ] 2x2, 3x3, NxN systems solve correctly
- [ ] Inconsistent systems detected
- [ ] Underdetermined systems detected
- [ ] Integration with Matrix module
- [ ] All tests pass

---

### TASK P1-5: Build Cross-Validation Test Suite vs SymPy

**Status**: NOT STARTED
**Priority**: HIGH (CORRECTNESS)
**Estimated Effort**: Ongoing (start with 100 cases)
**Impact**: Mathematical correctness validation

**Context**:
No systematic comparison with SymPy exists. Need to validate mathematical correctness.

**Files to Create**:
```
crates/mathhook-core/tests/sympy_validation/mod.rs
crates/mathhook-core/tests/sympy_validation/simplification.rs
crates/mathhook-core/tests/sympy_validation/derivatives.rs
crates/mathhook-core/tests/sympy_validation/integration.rs
crates/mathhook-core/tests/sympy_validation/solving.rs
```

**Test Structure**:
```rust
// In crates/mathhook-core/tests/sympy_validation/mod.rs

/// Cross-validation test against SymPy
///
/// Each test:
/// 1. Performs operation in MathHook
/// 2. Compares to known-correct SymPy result (hardcoded)
/// 3. Asserts equality
///
/// To generate expected results, run in SymPy:
/// ```python
/// from sympy import *
/// x = Symbol('x')
/// expr = x**2 + 2*x + 1
/// result = simplify(expr)
/// print(result)  # Use this as expected value
/// ```

mod simplification;
mod derivatives;
mod integration;
mod solving;
```

**Example Tests**:
```rust
// In crates/mathhook-core/tests/sympy_validation/simplification.rs

#[test]
fn sympy_validate_simplify_polynomial() {
    // SymPy:
    // >>> simplify(x**2 + 2*x + 1)
    // (x + 1)**2

    let x = symbol!(x);
    let expr = expr!(add: (x^2), (2*x), 1);
    let result = expr.simplify();

    // Expected: (x + 1)^2
    let expected = Expression::pow(
        expr!(x + 1),
        Expression::integer(2)
    );

    assert_eq!(result, expected);
}

#[test]
fn sympy_validate_simplify_trig_identity() {
    // SymPy:
    // >>> simplify(sin(x)**2 + cos(x)**2)
    // 1

    let x = symbol!(x);
    let expr = Expression::add(vec![
        Expression::pow(Expression::function("sin", vec![expr!(x)]), Expression::integer(2)),
        Expression::pow(Expression::function("cos", vec![expr!(x)]), Expression::integer(2))
    ]);
    let result = expr.simplify();

    assert_eq!(result, Expression::integer(1));
}

// In crates/mathhook-core/tests/sympy_validation/derivatives.rs

#[test]
fn sympy_validate_derivative_polynomial() {
    // SymPy:
    // >>> diff(x**3 + 2*x**2 + 3*x + 4, x)
    // 3*x**2 + 4*x + 3

    let x = symbol!(x);
    let expr = expr!(add: (x^3), (2*(x^2)), (3*x), 4);
    let result = expr.derivative(x);

    let expected = expr!(add: (3*(x^2)), (4*x), 3);

    assert_eq!(result.simplify(), expected.simplify());
}

#[test]
fn sympy_validate_derivative_chain_rule() {
    // SymPy:
    // >>> diff(sin(x**2), x)
    // 2*x*cos(x**2)

    let x = symbol!(x);
    let expr = Expression::function("sin", vec![expr!(x^2)]);
    let result = expr.derivative(x);

    let expected = Expression::mul(vec![
        Expression::integer(2),
        expr!(x),
        Expression::function("cos", vec![expr!(x^2)])
    ]);

    assert_eq!(result.simplify(), expected.simplify());
}

// In crates/mathhook-core/tests/sympy_validation/integration.rs

#[test]
fn sympy_validate_integrate_polynomial() {
    // SymPy:
    // >>> integrate(x**2, x)
    // x**3/3

    let x = symbol!(x);
    let expr = expr!(x^2);
    let result = integrate(&expr, x);

    let expected = Expression::div(expr!(x^3), Expression::integer(3));

    assert_eq!(result, expected);
}

// In crates/mathhook-core/tests/sympy_validation/solving.rs

#[test]
fn sympy_validate_solve_quadratic() {
    // SymPy:
    // >>> solve(x**2 - 5*x + 6, x)
    // [2, 3]

    let x = symbol!(x);
    let eq = expr!(add: (x^2), (-5*x), 6);
    let result = solve(&eq, x);

    match result {
        SolverResult::Multiple(solutions) => {
            assert_eq!(solutions.len(), 2);
            assert!(solutions.contains(&Expression::integer(2)));
            assert!(solutions.contains(&Expression::integer(3)));
        }
        _ => panic!("Expected two solutions"),
    }
}
```

**Test Categories (100 initial cases)**:

1. **Simplification** (25 cases):
   - Polynomial simplification
   - Rational expression simplification
   - Trigonometric identities
   - Logarithm rules
   - Constant folding

2. **Derivatives** (25 cases):
   - Power rule
   - Product rule
   - Quotient rule
   - Chain rule
   - Trigonometric functions
   - Exponential/logarithmic
   - Implicit differentiation

3. **Integration** (20 cases):
   - Power rule
   - Elementary functions
   - Simple substitution
   - Integration by parts

4. **Equation Solving** (15 cases):
   - Linear equations
   - Quadratic equations
   - Simple polynomial equations
   - Systems of linear equations

5. **Special Functions** (15 cases):
   - Special values (sin(π), cos(0), etc.)
   - Function properties
   - Simplification rules

**Implementation Steps**:
1. Create validation test structure
2. Generate expected results from SymPy for each test
3. Implement first 25 simplification tests
4. Implement 25 derivative tests
5. Implement 20 integration tests
6. Implement 15 solving tests
7. Implement 15 special function tests
8. Document any discrepancies
9. Expand to 200+ tests over time

**Verification**:
- [ ] 100+ validation tests created
- [ ] All tests pass (or discrepancies documented)
- [ ] Test coverage across all major operations
- [ ] Continuous expansion of test suite

---

## P2: MEDIUM PRIORITY (NICE TO HAVE FOR 0.1)

### TASK P2-1: Remove All Emojis and Fix ALL CAPS

**Status**: WIDESPREAD
**Priority**: MEDIUM (CLEANUP)
**Estimated Effort**: 2-3 days
**Impact**: Code quality, CLAUDE.md compliance

**Files Affected** (200+ emoji instances, 100+ ALL CAPS):
```
crates/mathhook-core/src/algebra/solvers.rs
crates/mathhook-core/src/algebra/solvers/linear.rs
crates/mathhook-core/src/educational/message_registry.rs
crates/mathhook-core/src/educational/enhanced_steps.rs
crates/mathhook-core/src/serialize.rs
crates/mathhook-benchmarks/benches/comprehensive_performance_suite.rs
crates/mathhook-core/src/core/performance/profiler.rs
... and many more
```

**Automated Fix Strategy**:
```bash
# Step 1: Find all files with emojis
rg "[\x{1F300}-\x{1F9FF}]" crates/mathhook-core/src --files-with-matches > emoji_files.txt

# Step 2: Manual cleanup (no safe automated replacement)
# For each file:
# - Remove emoji
# - Rewrite comment/doc in plain text
# - Fix ALL CAPS to proper case

# Step 3: Find ALL CAPS abuse
rg "^[\s]*//[/!]? [A-Z\s]{10,}" crates/mathhook-core/src --type rust

# Step 4: Fix each occurrence
```

**Example Fixes**:
```rust
// BEFORE:
//! 🎯 EQUATION SOLVERS MODULE - MODERN RUST STRUCTURE

/// 🧠 SMART SOLVER - Detects equation patterns

// 🎓 STEP-BY-STEP INTEGRATION (CRITICAL USER REQUIREMENT)

// AFTER:
//! Equation solvers module with modern Rust structure

/// Smart solver that detects equation patterns

// Step-by-step integration (critical user requirement)
```

**Verification**:
- [ ] Zero emoji characters in codebase
- [ ] No ALL CAPS except const names
- [ ] All comments rewritten clearly
- [ ] Code still compiles and tests pass

---

### TASK P2-2: Split Large Modules

**Status**: 6 FILES OVER 500 LINES
**Priority**: MEDIUM (MAINTAINABILITY)
**Estimated Effort**: 1 week
**Impact**: Code organization

**Files to Split**:
1. `core/expression/constructors.rs` - 1,026 lines
2. `matrix/unified.rs` - 1,021 lines
3. `educational/enhanced_steps.rs` - 939 lines
4. `formatter/latex.rs` - 837 lines
5. `simplify/arithmetic.rs` - 738 lines
6. `educational/step_by_step.rs` - 713 lines

**Split Strategy** (example for `constructors.rs`):
```
Before:
  core/expression/constructors.rs (1,026 lines)

After:
  core/expression/constructors/
    mod.rs (re-exports)
    add.rs (addition constructor + tests)
    mul.rs (multiplication constructor + tests)
    pow.rs (power constructor + tests)
    function.rs (function constructor + tests)
    rational.rs (rational number constructor + tests)
```

**Verification**:
- [ ] All modules under 500 lines
- [ ] Logical grouping maintained
- [ ] All tests still pass
- [ ] No functionality broken

---

### TASK P2-3: Replace Panics with Result Returns

**Status**: ~10 PANICS IN LIBRARY CODE
**Priority**: MEDIUM (RELIABILITY)
**Estimated Effort**: 2-3 days
**Impact**: Error handling

**Files to Fix**:
```
crates/mathhook-core/src/calculus/derivatives/partial/utils.rs (lines 93, 99, 104)
crates/mathhook-core/src/calculus/derivatives/partial/jacobian.rs (line 155)
crates/mathhook-core/src/calculus/derivatives/partial/gradient.rs (line 106)
crates/mathhook-core/src/calculus/derivatives/partial/vector_fields.rs (lines 32, 119, 556, 697)
```

**Fix Pattern**:
```rust
// BEFORE:
pub fn compute_jacobian(matrix: Matrix) -> Matrix {
    if !matrix.is_square() {
        panic!("Matrix must be square and non-empty");
    }
    // ... implementation
}

// AFTER:
pub fn compute_jacobian(matrix: Matrix) -> Result<Matrix, MathError> {
    if !matrix.is_square() {
        return Err(MathError::InvalidInput {
            message: "Matrix must be square and non-empty".to_string()
        });
    }
    // ... implementation
    Ok(result)
}
```

**Verification**:
- [ ] No panics in library code (except debug_assert)
- [ ] All errors return Result
- [ ] Tests updated for new signatures
- [ ] Error messages helpful

---

## P3: LOW PRIORITY (CAN DEFER TO 0.2)

### TASK P3-1: Fix README and USAGE Examples

**Estimated Effort**: 1 day
**Impact**: User onboarding

See detailed issues in Section 4 of human-readable report.

---

### TASK P3-2: Add Property-Based Tests

**Estimated Effort**: 1 week
**Impact**: Correctness validation

Use `proptest` for algebraic properties (commutativity, associativity, distributivity, idempotence).

---

### TASK P3-3: Document Macro Limitations

**Estimated Effort**: 1-2 hours
**Impact**: User understanding

Add section to USAGE.md explaining `expr!` macro limitations.

---

## AGENT WORKFLOW

When assigned a task from this document:

1. **Read task context fully**
2. **Check CLAUDE.md for relevant guidelines**
3. **Locate files mentioned**
4. **Implement fix systematically**
5. **Add tests for changes**
6. **Run test suite**: `cargo test -p mathhook-core`
7. **Run doctests**: `cargo test --doc -p mathhook-core`
8. **Verify no regressions** (test count should not decrease)
9. **Update this document** with progress
10. **Report completion** with verification checklist

---

## PRIORITY SUMMARY

**P0 Critical Blockers** (6 weeks):
- P0-1: Pattern matching & substitution (2-3 weeks)
- P0-2: Fix polynomial fake roots (1 day)
- P0-3: Fix 103 failing doctests (1 week)
- P0-4: Number overflow handling (1 week)
- P0-5: Domain error system (3-4 days)

**P1 High Priority** (6 weeks):
- P1-1: Refactor hardcoded functions (1-2 weeks)
- P1-2: Complete complex arithmetic (3-5 days)
- P1-3: Complete integration table (1 week)
- P1-4: System equation solver (1 week)
- P1-5: SymPy validation suite (ongoing, start with 100 cases)

**P2 Medium Priority** (3 weeks):
- P2-1: Remove emojis/ALL CAPS (2-3 days)
- P2-2: Split large modules (1 week)
- P2-3: Replace panics with Results (2-3 days)

**P3 Low Priority** (deferred to 0.2+):
- Advanced factorization
- Groebner bases
- Full cubic/quartic formulas
- Special functions beyond basic set

**Total Estimated Timeline**: 12-15 weeks for P0+P1+P2

---

**Document Version**: 1.0
**Last Updated**: 2025-10-13
**Status**: Ready for agent consumption
