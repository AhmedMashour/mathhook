/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class AbsoluteValueIntelligence {
  constructor()
  /** Get absolute value function properties

  # Examples

  ```
  use mathhook_core::functions::elementary::abs::AbsoluteValueIntelligence;

  let intelligence = AbsoluteValueIntelligence::new();
  let props = intelligence.get_properties();
  assert!(props.contains_key("abs"));
  ``` */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is absolute value

  # Arguments

   * `name` - The function name to check

  # Examples

  ```
  use mathhook_core::functions::elementary::abs::AbsoluteValueIntelligence;

  let intelligence = AbsoluteValueIntelligence::new();
  assert!(intelligence.has_function("abs"));
  assert!(!intelligence.has_function("sin"));
  ``` */
  hasFunction(name: string): boolean
}
export type JsAbsoluteValueIntelligence = AbsoluteValueIntelligence

export declare class AbsSimplificationStrategy {
  name(): string
}
export type JsAbsSimplificationStrategy = AbsSimplificationStrategy

export declare class AccuracyVerifier {
  constructor()
  /** Get verified constant by name */
  getVerifiedConstant(name: string): JsVerifiedConstant | null
  /** Verify mathematical accuracy of a function evaluation

  Returns true if the evaluation meets research-grade accuracy standards */
  verifyAccuracy(functionClass: string, computed: number, expected: number): boolean
  /** Generate accuracy report for all verified constants and relationships */
  generateAccuracyReport(): string
  /** Get verified relationship by name */
  getVerifiedRelationship(name: string): JsVerifiedRelationship | null
}
export type JsAccuracyVerifier = AccuracyVerifier

export declare class AdaptiveConfig {
  constructor()
  cloneValue(): AdaptiveConfig
}
export type JsAdaptiveConfig = AdaptiveConfig

export declare class AdaptiveSimpson {
  constructor()
}
export type JsAdaptiveSimpson = AdaptiveSimpson

export declare class AdaptiveThresholds {
  constructor()
  cloneValue(): AdaptiveThresholds
}
export type JsAdaptiveThresholds = AdaptiveThresholds

export declare class AntiderivativeRule {
  cloneValue(): AntiderivativeRule
}
export type JsAntiderivativeRule = AntiderivativeRule

export declare class AntiderivativeRuleType {

}
export type JsAntiderivativeRuleType = AntiderivativeRuleType

export declare class BackgroundCompute {
  constructor()
  /** Clear all tasks and results */
  clear(): void
  /** Predict and precompute likely next expressions based on current expression */
  predictAndPrecompute(currentExpr: JsExpression): void
  /** Get statistics about background computation */
  getStatistics(): JsBackgroundComputeStatistics
  /** Get a precomputed result if available */
  getResult(taskId: number): JsComputeResult | null
  /** Get result by expression hash (if we've computed this expression before) */
  getResultByExpression(expr: JsExpression): JsComputeResult | null
  /** Stop the background worker */
  stopWorker(): void
  /** Submit common expressions for precomputation */
  precomputeCommonExpressions(): void
  /** Submit a task for background computation */
  submitTask(expression: JsExpression, priority: JsComputePriority, likelihood: number): number
}
export type JsBackgroundCompute = BackgroundCompute

export declare class BackgroundComputeStatistics {
  cloneValue(): BackgroundComputeStatistics
}
export type JsBackgroundComputeStatistics = BackgroundComputeStatistics

export declare class BernoulliODESolver {
  /** Detect if ODE is in Bernoulli form

  Checks if equation matches dy/dx + p(x)y = q(x)y^n

  # Arguments

   * `equation` - The ODE equation
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  Optional (p, q, n) if equation is Bernoulli form */
  detectForm(equation: JsExpression, dependent: symbol, independent: symbol): [JsExpression, JsExpression, JsExpression] | null
}
export type JsBernoulliODESolver = BernoulliODESolver

export declare class BindingContext {
  equals(other: BindingContext): boolean
  cloneValue(): BindingContext
}
export type JsBindingContext = BindingContext

export declare class BisectionMethod {
  /** Create a new bisection method with initial bracket

  # Arguments

   * `a` - Lower bound of bracket
   * `b` - Upper bound of bracket

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::BisectionMethod;

  let method = BisectionMethod::new(0.0, 2.0);
  ``` */
  constructor(a: number, b: number)
}
export type JsBisectionMethod = BisectionMethod

export declare class BoundaryCondition {
  /** Create a Dirichlet boundary condition */
  static dirichlet(value: JsExpression, location: JsBoundaryLocation): BoundaryCondition
  /** Creates a Dirichlet boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::dirichlet_at(x, expr!(0), expr!(100));
  ``` */
  static dirichletAt(variable: symbol, location: JsExpression, value: JsExpression): BoundaryCondition
  /** Create a Neumann boundary condition */
  static neumann(derivative: JsExpression, location: JsBoundaryLocation): BoundaryCondition
  /** Creates a Neumann boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::neumann_at(x, expr!(0), expr!(50));
  ``` */
  static neumannAt(variable: symbol, location: JsExpression, value: JsExpression): BoundaryCondition
  /** Create a Robin boundary condition */
  static robin(coeffU: JsExpression, coeffDu: JsExpression, value: JsExpression, location: JsBoundaryLocation): BoundaryCondition
  /** Creates a Robin boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::robin_at(
  x,
  expr!(0),
  expr!(1),
  expr!(2),
  expr!(10)
  );
  ``` */
  static robinAt(variable: symbol, location: JsExpression, alpha: JsExpression, beta: JsExpression, value: JsExpression): BoundaryCondition
  equals(other: BoundaryCondition): boolean
  cloneValue(): BoundaryCondition
}
export type JsBoundaryCondition = BoundaryCondition

export declare class BoundaryLocation {
  equals(other: BoundaryLocation): boolean
  cloneValue(): BoundaryLocation
}
export type JsBoundaryLocation = BoundaryLocation

export declare class CacheStatistics {
  constructor()
  cloneValue(): CacheStatistics
}
export type JsCacheStatistics = CacheStatistics

export declare class CacheStats {
  cloneValue(): CacheStats
}
export type JsCacheStats = CacheStats

export declare class CharacteristicPolynomial {
  /** Creates new characteristic polynomial

  # Arguments

   * `coefficients` - Polynomial coefficients [c₀, c₁, ..., cₙ]
   * `variable` - Variable symbol (typically λ)

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],  // λ² - 5λ + 6
  lambda
  );
  ``` */
  constructor(coefficients: Array<JsExpression>, variable: symbol)
  /** Evaluates polynomial at given value

  Uses Horner's method for efficient evaluation.

  # Arguments

   * `value` - Value to substitute for variable

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],  // λ² - 5λ + 6
  lambda
  );

  let result = poly.evaluate(&expr!(2));  // 2² - 5(2) + 6 = 0
  assert_eq!(result, expr!(0));
  ``` */
  evaluate(value: JsExpression): JsExpression
  /** Returns the degree of the polynomial

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(2), expr!(3)],
  lambda
  );
  assert_eq!(poly.degree(), 2);
  ``` */
  degree(): number
  /** Multiplies two characteristic polynomials

  # Arguments

   * `poly1` - First polynomial
   * `poly2` - Second polynomial

  # Returns

  Product of the two polynomials

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);

  let poly1 = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(1)],  // 1 + λ
  lambda.clone()
  );
  let poly2 = CharacteristicPolynomial::new(
  vec![expr!(2), expr!(1)],  // 2 + λ
  lambda.clone()
  );

  let product = poly1.multiply(&poly2);  // 2 + 3λ + λ²
  assert_eq!(product.degree(), 2);
  ``` */
  multiply(other: CharacteristicPolynomial): CharacteristicPolynomial
  /** Converts polynomial to expression form

  Returns: c₀ + c₁λ + c₂λ² + ... + cₙλⁿ

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],
  lambda.clone()
  );

  let expr = poly.to_expression();
  // Represents: 6 - 5λ + λ²
  ``` */
  toExpression(): JsExpression
  /** Formats polynomial as human-readable string

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],
  lambda
  );

  let formatted = poly.format();
  // Output: "6 + (-5)·λ + λ²"
  ``` */
  format(): string
  /** Adds two characteristic polynomials

  Note: This is polynomial addition, not matrix addition.
  Both polynomials must use the same variable.

  # Arguments

   * `poly1` - First polynomial
   * `poly2` - Second polynomial

  # Returns

  Sum of the two polynomials

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::{CharacteristicPolynomial, CharacteristicPolynomialBuilder};

  let lambda = symbol!(lambda);
  let builder = CharacteristicPolynomialBuilder;

  let poly1 = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(2)],  // 1 + 2λ
  lambda.clone()
  );
  let poly2 = CharacteristicPolynomial::new(
  vec![expr!(3), expr!(4)],  // 3 + 4λ
  lambda.clone()
  );

  let sum = builder.add(&poly1, &poly2);  // 4 + 6λ
  assert_eq!(sum.coefficients.len(), 2);
  ``` */
  add(other: CharacteristicPolynomial): CharacteristicPolynomial
  cloneValue(): CharacteristicPolynomial
}
export type JsCharacteristicPolynomial = CharacteristicPolynomial

export declare class CharacteristicsError {
  equals(other: CharacteristicsError): boolean
  cloneValue(): CharacteristicsError
}
export type JsCharacteristicsError = CharacteristicsError

export declare class CharacteristicSolution {
  equals(other: CharacteristicSolution): boolean
  cloneValue(): CharacteristicSolution
}
export type JsCharacteristicSolution = CharacteristicSolution

export declare class ChebyshevIntelligence {
  constructor()
  /** Get all Chebyshev polynomial properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is a Chebyshev polynomial */
  hasFunction(name: string): boolean
}
export type JsChebyshevIntelligence = ChebyshevIntelligence

export declare class ChebyshevT {
  static polynomial(n: number, var: symbol): JsExpression
  static evaluate(n: number, x: number): number
  static recurrenceCoefficients(n: number): [number, number, number]
}
export type JsChebyshevT = ChebyshevT

export declare class ChebyshevU {
  static recurrenceCoefficients(n: number): [number, number, number]
  static polynomial(n: number, var: symbol): JsExpression
  static evaluate(n: number, x: number): number
}
export type JsChebyshevU = ChebyshevU

export declare class CholeskyDecomposition {
  equals(other: CholeskyDecomposition): boolean
  cloneValue(): CholeskyDecomposition
}
export type JsCholeskyDecomposition = CholeskyDecomposition

export declare class Commutativity {
  /** Can factors be sorted during canonicalization?

  Returns true only if commutativity is guaranteed. */
  canSort(): boolean
  equals(other: Commutativity): boolean
  cloneValue(): Commutativity
}
export type JsCommutativity = Commutativity

export declare class CompatibilityInfo {
  cloneValue(): CompatibilityInfo
}
export type JsCompatibilityInfo = CompatibilityInfo

export declare class ComplexEigenDecomposition {
  equals(other: ComplexEigenDecomposition): boolean
  cloneValue(): ComplexEigenDecomposition
}
export type JsComplexEigenDecomposition = ComplexEigenDecomposition

export declare class ComplexEigenvalue {
  equals(other: ComplexEigenvalue): boolean
  cloneValue(): ComplexEigenvalue
}
export type JsComplexEigenvalue = ComplexEigenvalue

export declare class ComplexityEstimate {
  cloneValue(): ComplexityEstimate
}
export type JsComplexityEstimate = ComplexityEstimate

export declare class ComputePriority {
  equals(other: ComputePriority): boolean
  cloneValue(): ComputePriority
}
export type JsComputePriority = ComputePriority

export declare class ComputeResult {
  cloneValue(): ComputeResult
}
export type JsComputeResult = ComputeResult

export declare class ComputeTask {
  cloneValue(): ComputeTask
}
export type JsComputeTask = ComputeTask

export declare class ConfigInfo {
  cloneValue(): ConfigInfo
}
export type JsConfigInfo = ConfigInfo

export declare class ConstantCoeffSecondOrderSolver {
  constructor()
  cloneValue(): ConstantCoeffSecondOrderSolver
}
export type JsConstantCoeffSecondOrderSolver = ConstantCoeffSecondOrderSolver

export declare class ConstantOfIntegration {
  equals(other: ConstantOfIntegration): boolean
  cloneValue(): ConstantOfIntegration
}
export type JsConstantOfIntegration = ConstantOfIntegration

export declare class ConvergenceResult {
  equals(other: ConvergenceResult): boolean
  cloneValue(): ConvergenceResult
}
export type JsConvergenceResult = ConvergenceResult

export declare class CosSimplificationStrategy {
  name(): string
}
export type JsCosSimplificationStrategy = CosSimplificationStrategy

export declare class DefaultValidator {
  validatePerformance(name: string, benchmarkSize: number): JsValidationResult
}
export type JsDefaultValidator = DefaultValidator

export declare class DerivativeRule {
  cloneValue(): DerivativeRule
}
export type JsDerivativeRule = DerivativeRule

export declare class DerivativeRuleType {

}
export type JsDerivativeRuleType = DerivativeRuleType

export declare class DifferentialEquation {
  cloneValue(): DifferentialEquation
}
export type JsDifferentialEquation = DifferentialEquation

export declare class DifferentialExtension {
  equals(other: DifferentialExtension): boolean
  cloneValue(): DifferentialExtension
}
export type JsDifferentialExtension = DifferentialExtension

export declare class Domain {
  equals(other: Domain): boolean
  cloneValue(): Domain
}
export type JsDomain = Domain

export declare class EducationalMessageGenerator {
  /** Generate linear equation explanation */
  static linearEquationSteps(equation: string, variable: string, solution: string): Array<JsStep>
  /** Generate error explanation */
  static errorExplanation(category: JsMessageCategory, errorType: number, context: Record<string, string>): JsStep | null
  /** Generate mathematical insight */
  static mathematicalInsight(variant: number, variable: string): JsStep | null
  /** Generate quadratic equation explanation */
  static quadraticEquationSteps(equation: string, variable: string, a: string, b: string, c: string, solutions: string): Array<JsStep>
}
export type JsEducationalMessageGenerator = EducationalMessageGenerator

export declare class EducationalODESolver {
  constructor()
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  canSolve(equation: JsExpression): boolean
}
export type JsEducationalODESolver = EducationalODESolver

export declare class EducationalPDESolver {
  constructor()
  canSolve(equation: JsExpression): boolean
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  solve(equation: JsExpression, variable: symbol): JsSolverResult
}
export type JsEducationalPDESolver = EducationalPDESolver

export declare class EigenDecomposition {
  equals(other: EigenDecomposition): boolean
  cloneValue(): EigenDecomposition
}
export type JsEigenDecomposition = EigenDecomposition

export declare class EigenvalueSolution {
  equals(other: EigenvalueSolution): boolean
  cloneValue(): EigenvalueSolution
}
export type JsEigenvalueSolution = EigenvalueSolution

export declare class ElementaryIntelligence {
  constructor()
  /** Check if function is elementary */
  isElementaryFunction(name: string): boolean
  /** Get all elementary function properties

  Returns a HashMap of all elementary functions and their properties
  for integration with the universal registry. */
  getAllProperties(): Record<string, JsFunctionProperties>
}
export type JsElementaryIntelligence = ElementaryIntelligence

export declare class ElementaryProperties {
  cloneValue(): ElementaryProperties
}
export type JsElementaryProperties = ElementaryProperties

export declare class EquationAnalyzer {
  /** Analyze equation and determine type for solver dispatch */
  static analyze(equation: JsExpression, variable: symbol): JsEquationType
}
export type JsEquationAnalyzer = EquationAnalyzer

export declare class EquationType {
  equals(other: EquationType): boolean
  cloneValue(): EquationType
}
export type JsEquationType = EquationType

export declare class EvalContext {
  constructor()
  /** Create context for numerical evaluation with substitutions

  Returns a context that substitutes variables and converts to numerical form.
  Simplification is enabled by default for numerical stability.

  # Arguments

   * `variables` - Map from symbol name to replacement expression

  # Returns

  Context with:
  - Provided variable substitutions
  - Numerical mode (numeric = true)
  - Default precision (53 bits for f64)
  - Pre-simplification enabled (simplify_first = true)

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;
  use std::collections::HashMap;

  let x = symbol!(x);
  let e = expr!((x ^ 2) + (2*x) + 1);

  let mut vars = HashMap::new();
  vars.insert("x".to_string(), expr!(3));

  let ctx = EvalContext::numeric(vars);
  let result = e.evaluate_with_context(&ctx).unwrap();
  // Result is numerical: 16 (= 3^2 + 2*3 + 1)
  ``` */
  static numeric(variables: Record<string, JsExpression>): EvalContext
  /** Set precision for numerical operations (bits)

  Consumes self and returns a new context with the specified precision.

  # Arguments

   * `precision` - Number of bits of precision (53 for f64, 128+ for arbitrary precision)

  # Returns

  New context with updated precision

  # Examples

  ```rust
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  let ctx = EvalContext::symbolic().with_precision(128);
  assert_eq!(ctx.precision, 128);
  ``` */
  withPrecision(precision: number): EvalContext
  /** Create context for symbolic evaluation (no numerical conversion)

  Returns a context that performs variable substitution but keeps expressions
  in symbolic form. No numerical evaluation is performed.

  # Returns

  Context with:
  - No variable substitutions
  - Symbolic mode (numeric = false)
  - Default precision (53 bits)
  - No pre-simplification

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  let x = symbol!(x);
  let e = expr!((x ^ 2) + (2*x) + 1);

  let ctx = EvalContext::symbolic();
  let result = e.evaluate_with_context(&ctx).unwrap();
  // Result is still symbolic: x^2 + 2*x + 1
  ``` */
  static symbolic(): EvalContext
  /** Control whether to simplify symbolically before numerical evaluation

  Consumes self and returns a new context with the specified simplification flag.

  # Arguments

   * `simplify` - Whether to call `simplify()` before `eval_numeric()`

  # Returns

  New context with updated simplification setting

  # Examples

  ```rust
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  // Disable simplification for performance
  let ctx = EvalContext::symbolic().with_simplify(false);
  assert!(!ctx.simplify_first);

  // Enable simplification for numerical stability
  let ctx = EvalContext::symbolic().with_simplify(true);
  assert!(ctx.simplify_first);
  ``` */
  withSimplify(simplify: boolean): EvalContext
  cloneValue(): EvalContext
}
export type JsEvalContext = EvalContext

export declare class EvaluationMethod {
  equals(other: EvaluationMethod): boolean
  cloneValue(): EvaluationMethod
}
export type JsEvaluationMethod = EvaluationMethod

export declare class EvaluationResult {
  cloneValue(): EvaluationResult
}
export type JsEvaluationResult = EvaluationResult

export declare class EvaluationStrategy {
  equals(other: EvaluationStrategy): boolean
  cloneValue(): EvaluationStrategy
}
export type JsEvaluationStrategy = EvaluationStrategy

export declare class ExactODESolver {
  /** Find integrating factor for non-exact ODE

  Attempts to find integrating factor μ(x) or μ(y) to make ODE exact.

  # Arguments

   * `m` - Coefficient of dx
   * `n` - Coefficient of dy
   * `x` - Independent variable
   * `y` - Dependent variable

  # Returns

  Integrating factor if found */
  findIntegratingFactor(m: JsExpression, n: JsExpression, x: symbol, y: symbol): JsExpression | null
  /** Check if ODE is exact

  # Arguments

   * `m` - Coefficient of dx: M(x,y)
   * `n` - Coefficient of dy: N(x,y)
   * `x` - Independent variable
   * `y` - Dependent variable

  # Returns

  True if ∂M/∂y = ∂N/∂x

  # Examples

  ```rust
  use mathhook_core::calculus::ode::first_order::exact::ExactODESolver;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let y = symbol!(y);

  // 2xy dx + x^2 dy = 0 is exact
  let m = expr!((2 * x) * y);
  let n = expr!(x ^ 2);

  let solver = ExactODESolver;
  assert!(solver.is_exact(&m, &n, &x, &y));
  ``` */
  isExact(m: JsExpression, n: JsExpression, x: symbol, y: symbol): boolean
}
export type JsExactODESolver = ExactODESolver

export declare class ExponentialIntelligence {
  constructor()
  /** Check if function is exponential */
  hasFunction(name: string): boolean
  /** Get all exponential function properties */
  getProperties(): Record<string, JsFunctionProperties>
}
export type JsExponentialIntelligence = ExponentialIntelligence

export declare class Expression {
  /** Compute the complex conjugate

  Returns the complex conjugate (a + bi → a - bi). For non-complex
  expressions, returns the expression itself.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let conjugate = z.conjugate();
  if let Expression::Complex(data) = conjugate {
    assert_eq!(data.real, expr!(3));
    assert_eq!(data.imag, expr!(-4));
  }
  ``` */
  conjugate(): Expression
  /** Compute commutativity of this expression

  Commutativity is inferred from the symbols and operations:
  - Numbers, constants: Commutative
  - Symbols: Depends on symbol type (Scalar → Commutative, Matrix/Operator/Quaternion → Noncommutative)
  - Mul: Noncommutative if ANY factor is noncommutative
  - Add, Pow, Function: Depends on subexpressions

  # Examples

  Basic scalar symbols (commutative):
  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::expression::Expression;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  let y = Symbol::scalar("y");
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::symbol(y.clone()),
  ]);
  assert_eq!(expr.commutativity(), Commutativity::Commutative);
  ```

  Matrix symbols (noncommutative):
  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::expression::Expression;
  use mathhook_core::core::commutativity::Commutativity;

  let a = Symbol::matrix("A");
  let b = Symbol::matrix("B");
  let expr = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);
  assert_eq!(expr.commutativity(), Commutativity::Noncommutative);
  ``` */
  commutativity(): Commutativity
  leadingCoefficient(var: symbol): Expression
  primitivePart(): Expression
  /** Create a square root expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let sqrt_2 = Expression::sqrt(Expression::integer(2));
  ``` */
  static sqrt(arg: Expression): Expression
  complexAdd(other: Expression): Expression
  /** Create natural logarithm expression */
  static ln(arg: Expression): Expression
  complexDivide(other: Expression): Expression
  isZeroMatrix(): boolean
  polyRem(divisor: Expression, var: symbol): Expression
  /** Compute transpose of matrix expression

  For symbolic matrix expressions, this implements proper order reversal
  according to the mathematical rule: (AB)^T = B^T A^T

  # Mathematical Rules

  - For products: (AB)^T = B^T A^T (order reverses)
  - For sums: (A+B)^T = A^T + B^T (distributes)
  - For scalars: scalar^T = scalar (no change)
  - For matrix symbols: A^T creates transpose function

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let a = symbol!(A; matrix);
  let b = symbol!(B; matrix);

  let product = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);

  let transposed = product.transpose();
  ``` */
  transpose(): Expression
  isPolynomial(): boolean
  isDiagonal(): boolean
  polynomialCofactors(other: Expression): [Expression, Expression, Expression]
  /** Fast path: solve matrix equation with steps (skip classification) */
  solveMatrixEquationWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Compute GCD and cofactors

  Returns a tuple of (gcd, cofactor_a, cofactor_b) where:
  - gcd is the greatest common divisor
  - cofactor_a = a / gcd
  - cofactor_b = b / gcd

  # Arguments

   * `other` - The expression to compute cofactors with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let (gcd, cofactor_a, cofactor_b) = a.cofactors(&b);
  assert_eq!(gcd, expr!(4));
  assert_eq!(cofactor_a, expr!(3));
  assert_eq!(cofactor_b, expr!(2));
  ``` */
  cofactors(other: Expression): [Expression, Expression, Expression]
  /** Compute GCD and cofactors: returns (gcd, a/gcd, b/gcd) */
  cofactorsWithOther(other: Expression): [Expression, Expression, Expression]
  /** Create factorial expression */
  static factorial(arg: Expression): Expression
  explainSolvingSteps(variable: symbol): JsStepByStepExplanation
  complexSubtract(other: Expression): Expression
  /** Create an equation (equality relation)

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let expr = Expression::equation(
  expr!(x),
  expr!(5),
  );
  ``` */
  static equation(left: Expression, right: Expression): Expression
  /** Create an integer expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::integer(42);
  ``` */
  static integer(value: number): Expression
  flattenAddTerms(): Array<Expression>
  matrixAdd(other: Expression): Expression
  definiteIntegrate(variable: symbol, lower: Expression, upper: Expression): Expression
  /** High-level evaluation with context

  This is the PRIMARY user-facing evaluation method following SymPy's two-level architecture.
  It handles:
  1. Variable substitution
  2. Optional symbolic simplification
  3. Optional numerical evaluation

  This mirrors SymPy's `evalf(subs={...}, ...)` high-level API.

  # Arguments

   * `context` - Evaluation context (variables, numeric mode, precision, etc.)

  # Returns

  Evaluated expression

  # Errors

  Returns `MathError` for domain violations, undefined operations, etc.

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;
  use std::collections::HashMap;

  // Symbolic evaluation (no substitution)
  let x = symbol!(x);
  let f = expr!(x ^ 2);
  let result = f.evaluate_with_context(&EvalContext::symbolic()).unwrap();
  assert_eq!(result, expr!(x ^ 2)); // Unchanged

  // Numerical evaluation with substitution
  let mut vars = HashMap::new();
  vars.insert("x".to_string(), expr!(3));
  let ctx = EvalContext::numeric(vars);
  let result = f.evaluate_with_context(&ctx).unwrap();
  assert_eq!(result, expr!(9));
  ``` */
  evaluateWithContext(context: EvalContext): Expression
  toLatexWithDepth(context: JsLaTeXContext, depth: number): string
  /** Create a multiplication expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Flattening nested multiplications: `(a * b) * c` → `a * b * c`
  - Removing identity elements: `x * 1` → `x`
  - Handling zero: `x * 0` → `0`
  - Sorting factors in canonical order: `y * x` → `x * y`
  - Evaluating constant subexpressions: `2 * 3` → `6`
  - Converting division to multiplication: `a / b` → `a * b^(-1)`

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Constant folding
  let expression = Expression::mul(vec![
  Expression::integer(2),
  Expression::integer(3),
  ]);
  assert_eq!(expression, Expression::integer(6));

  // Identity element removal
  let x = expr!(x);
  let expr = Expression::mul(vec![x.clone(), Expression::integer(1)]);
  assert_eq!(expr, x);

  // Zero handling
  let expression = Expression::mul(vec![x.clone(), Expression::integer(0)]);
  assert_eq!(expression, Expression::integer(0));

  // Commutativity (canonical ordering)
  let y = expr!(y);
  let expr1 = Expression::mul(vec![x.clone(), y.clone()]);
  let expr2 = Expression::mul(vec![y.clone(), x.clone()]);
  assert_eq!(expr1, expr2); // Both produce x * y in canonical order
  ``` */
  static mul(factors: Array<Expression>): Expression
  /** Fast literal zero check without simplification

  This is a performance-optimized version that only checks if the expression
  is literally `Number(0)`. It does NOT simplify the expression first.

  Use this in performance-critical loops where you know the expression
  is already in simplified form, or where you specifically want to check
  for literal zeros only.

  # Examples

  ```rust
  use mathhook_core::Expression;

  // Detects literal zero
  assert!(Expression::integer(0).is_zero_fast());

  // Mul constructor auto-simplifies, so this IS detected
  let expr = Expression::mul(vec![Expression::integer(0), Expression::integer(5)]);
  assert!(expr.is_zero_fast()); // Simplified to 0 by constructor

  // Example of what is_zero_fast() does NOT detect (without simplification):
  // If we had a raw unsimplified Mul expression, is_zero_fast() wouldn't detect it
  ``` */
  isZeroFast(): boolean
  /** Simplify complex rational expressions */
  simplifyComplexRational(): Expression
  /** Fast path: solve as ordinary differential equation (skip classification)

  Directly solves ODEs using the cached ODE solver registry without running
  equation type classification. Supports separable, linear, and homogeneous
  first-order ODE types.

  Uses a static cached registry for optimal performance on repeated calls.

  # Arguments

   * `dependent` - The dependent variable (e.g., y)
   * `independent` - The independent variable (e.g., x)

  # Returns

  The solver result containing the ODE solution */
  solveOde(dependent: symbol, independent: symbol): JsSolverResult
  /** Simplify complex expressions by removing zero parts

  Converts complex numbers to their simplest form by removing zero
  real or imaginary components.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};
  use mathhook_core::simplify::Simplify;

  let z = Expression::complex(expr!(3), expr!(0));
  let simplified = z.simplify();
  ``` */
  static simplifyComplex(expr: Expression): Expression
  /** Convert to polar form (magnitude, angle)

  Returns (r, θ) where z = r·e^(iθ). The angle is in radians,
  in the range (-π, π].

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let (magnitude, angle) = z.to_polar();
  ``` */
  toPolar(): [Expression, Expression]
  /** Create an imaginary unit expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let i = Expression::i();
  ``` */
  static i(): Expression
  finiteSum(variable: symbol, start: Expression, end: Expression): Expression
  explainPolyDivision(divisor: Expression, var: symbol): JsStepByStepExplanation
  /** Fast path: solve as PDE with steps (skip classification) */
  solvePdeWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Create a division expression with division-by-zero checking

  This constructor checks if the denominator is zero and returns an error if so.
  Use this in evaluation contexts where division by zero should be detected.

  For symbolic contexts where the denominator is unknown or symbolic, use `div()` instead.

  # Errors

  Returns `MathError::DivisionByZero` if the denominator is exactly zero.

  # Examples

  ```rust
  use mathhook_core::{Expression, MathError};

  // Valid division
  let result = Expression::div_checked(
  Expression::integer(10),
  Expression::integer(2),
  );
  assert!(result.is_ok());

  // Division by zero
  let result = Expression::div_checked(
  Expression::integer(1),
  Expression::integer(0),
  );
  assert!(matches!(result, Err(MathError::DivisionByZero)));
  ``` */
  static divChecked(numerator: Expression, denominator: Expression): Expression
  quoPolynomial(divisor: Expression, var: symbol): Expression
  /** Create an identity matrix expression

  # Examples

  ```rust
  use mathhook_core::Expression;
  use mathhook_core::matrices::operations::MatrixOperations;

  let identity = Expression::identity_matrix(3);
  assert!(identity.is_identity_matrix());
  ``` */
  static identityMatrix(size: number): Expression
  complexConjugate(): Expression
  /** Extract the imaginary part of a complex number

  Returns the imaginary component of a complex expression. For non-complex
  expressions, returns zero.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let imag_part = z.imag();
  assert_eq!(imag_part, expr!(4));
  ``` */
  imag(): Expression
  laurentSeries(variable: symbol, point: Expression, order: number): Expression
  /** Create an e constant expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let e = Expression::e();
  ``` */
  static e(): Expression
  /** Create an anticommutator: {A, B} = AB + BA

  The anticommutator is the symmetric combination of two operators.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let A = Expression::symbol(symbol!(A; matrix));
  let B = Expression::symbol(symbol!(B; matrix));
  let anticomm = Expression::anticommutator(A.clone(), B.clone());
  // Represents: AB + BA
  ```

  # Mathematical Properties

  - {A, B} = {B, A} (symmetry)
  - {A, A} = 2A^2 (self-anticommutator)

  # Physics Example

  ```rust
  use mathhook_core::{Expression, symbol};

  let sigma_x = Expression::symbol(symbol!(sigma_x; operator));
  let sigma_y = Expression::symbol(symbol!(sigma_y; operator));
  let anticomm = Expression::anticommutator(sigma_x, sigma_y);
  // For Pauli matrices: {sigma_x, sigma_y} = 0
  ``` */
  static anticommutator(a: Expression, b: Expression): Expression
  nthDerivative(variable: symbol, order: number): Expression
  /** Check if expression is just the variable itself */
  isSimpleVariable(var: symbol): boolean
  /** Format expression using default LaTeX formatting

  This is the most convenient way to format expressions when you don't need
  specific formatting options. Always uses LaTeX format.

  # Examples
  ```rust
  use mathhook_core::core::Expression;
  use mathhook_core::{expr};

  let x_expr = expr!(x);
  let formatted = x_expr.format().unwrap();
  // Returns LaTeX formatted string
  ``` */
  format(): string
  explainPolyFactorization(var: symbol): JsStepByStepExplanation
  matrixInverse(): Expression
  /** Format expression with specific language/format

  # Examples
  ```rust
  use mathhook_core::core::Expression;
  use mathhook_core::formatter::MathLanguage;
  use mathhook_core::expr;

  let x_expr = expr!(x);
  let latex = x_expr.format_as(MathLanguage::LaTeX).unwrap();
  let simple = x_expr.format_as(MathLanguage::Simple).unwrap();
  let wolfram = x_expr.format_as(MathLanguage::Wolfram).unwrap();
  ``` */
  formatAs(language: JsMathLanguage): string
  /** Factor out the GCD from an expression */
  factorOutGcd(): Expression
  /** Combine like terms in the expression */
  combineLikeTerms(): Expression
  /** Solve equation for a variable with auto-detection

  Solves the equation `self = 0` for the given variable.
  Automatically detects equation type (linear, quadratic, ODE, etc.) and
  routes to the appropriate solver. For performance-critical code where
  you already know the equation type, use the fast path methods instead:
  - `solve_linear()`
  - `solve_quadratic()`
  - `solve_polynomial()`
  - `solve_ode()`
  - `solve_pde()`
  - `solve_system()`

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing solutions or error information

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};
  use mathhook_core::algebra::solvers::SolverResult;

  let x = symbol!(x);
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  let result = equation.solve(&x);
  match result {
    SolverResult::Single(solution) => {
      assert_eq!(solution, Expression::integer(3));
    }
    _ => panic!("Expected single solution"),
  }
  ``` */
  solve(variable: symbol): JsSolverResult
  /** Check if expression is any kind of matrix */
  isMatrix(): boolean
  isDivisibleBy(divisor: Expression, var: symbol): boolean
  polynomialVariables(): Array<symbol>
  isIntpolyCompatible(): boolean
  taylorSeries(variable: symbol, point: Expression, order: number): Expression
  /** Polynomial remainder */
  polynomialRemainder(divisor: Expression): Expression
  derivativeWithSteps(variable: symbol, order: number): JsStepByStepExplanation
  /** Simplify factorial expressions */
  simplifyFactorial(): Expression
  /** Create a pi constant expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let pi = Expression::pi();
  ``` */
  static pi(): Expression
  contourIntegral(variable: symbol): Expression
  /** Expand binomial expressions: (a + b)^n using binomial theorem

  For commutative terms, uses binomial theorem: C(n,k) * a^k * b^(n-k)
  For noncommutative terms, uses direct multiplication to preserve order */
  expandBinomial(a: Expression, b: Expression, n: number): Expression
  /** Factor difference of squares: a^2 - b^2 = (a + b)(a - b) */
  factorDifferenceOfSquares(a: Expression, b: Expression): Expression
  maclaurinSeries(variable: symbol, order: number): Expression
  /** Compute the absolute value (modulus) of a complex number

  Returns |z| = √(re² + im²). For complex numbers, this is the magnitude.
  For real numbers, this is the absolute value.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let magnitude = z.abs();
  ``` */
  abs(): Expression
  /** Create a definite integral expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::definite_integral(
  expr!(x),
  symbol!(x),
  Expression::integer(0),
  Expression::integer(1),
  );
  ``` */
  static definiteIntegral(integrand: Expression, variable: symbol, start: Expression, end: Expression): Expression
  /** Extract rational coefficient as string parts (FFI-friendly, no BigRational)

  Returns (numerator, denominator, remainder) where numerator/denominator
  is the rational coefficient and remainder is the non-rational part. */
  extractRationalParts(): [string, string, Expression]
  /** Generate step-by-step explanation for factorization */
  explainFactorization(): JsStepByStepExplanation
  explainInfiniteSum(variable: symbol, start: Expression): JsStepByStepExplanation
  /** Detect if an expression is algebraically equivalent to zero */
  isAlgebraicZero(): boolean
  /** Generate educational explanation for function expressions

  Perfect integration with the educational system */
  explainFunction(): Array<JsStep>
  /** Substitute and simplify in one step

  Convenience method that applies substitutions and then simplifies the result.

  # Arguments

   * `substitutions` - Map from symbol name to replacement expression

  # Returns

  New simplified expression with substitutions applied */
  substituteAndSimplify(substitutions: Record<string, Expression>): Expression
  residue(variable: symbol, pole: Expression): Expression
  /** Detect common patterns that equal zero */
  detectZeroPatterns(): boolean
  /** Polynomial degree computation */
  polynomialDegree(var: symbol): number | null
  /** Check if this expression is a positive number

  Returns true if the expression is a positive integer, rational, or float.
  Returns false for symbolic expressions (even if they might evaluate to positive).

  # Examples

  ```rust
  use mathhook_core::Expression;

  assert!(Expression::integer(5).is_positive_number());
  assert!(Expression::rational(1, 2).is_positive_number());
  assert!(!Expression::integer(-5).is_positive_number());
  assert!(!Expression::symbol("x").is_positive_number()); // Symbolic, not a number
  ``` */
  isPositiveNumber(): boolean
  polynomialResultant(other: Expression, var: symbol): Expression
  /** Generate step-by-step explanation for simplification */
  explainSimplification(): JsStepByStepExplanation
  polynomialDiscriminant(var: symbol): Expression
  /** Create a constant expression

  # Examples

  ```rust
  use mathhook_core::{Expression, core::MathConstant};

  let expr = Expression::constant(MathConstant::Pi);
  ``` */
  static constant(constant: JsMathConstant): Expression
  /** Compute the argument (phase angle) of a complex number

  Returns the angle θ = atan2(im, re) in radians, in the range (-π, π].
  This is the principal value of the argument.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(1), expr!(1));
  let angle = z.arg();
  ``` */
  arg(): Expression
  /** Create a commutator: [A, B] = AB - BA

  The commutator measures the failure of two operators to commute.
  It is zero for commutative operators and nonzero for noncommutative.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let A = Expression::symbol(symbol!(A; matrix));
  let B = Expression::symbol(symbol!(B; matrix));
  let comm = Expression::commutator(A.clone(), B.clone());
  // Represents: AB - BA
  ```

  # Mathematical Properties

  - [A, B] = -[B, A] (antisymmetry)
  - [A, A] = 0 (self-commutator is zero)
  - Jacobi identity: [A, [B, C]] + [B, [C, A]] + [C, [A, B]] = 0

  # Quantum Mechanics Example

  ```rust
  use mathhook_core::{Expression, symbol};

  let x = Expression::symbol(symbol!(x; operator));
  let p = Expression::symbol(symbol!(p; operator));
  let comm = Expression::commutator(x, p);
  // In quantum mechanics: [x, p] = ih (canonical commutation relation)
  ``` */
  static commutator(a: Expression, b: Expression): Expression
  complexMultiply(other: Expression): Expression
  matrixMultiply(other: Expression): Expression
  /** Separate variables and constants */
  separateConstants(): [Expression, Expression]
  toSimpleWithDepth(context: JsSimpleContext, depth: number): string
  /** Fast path: solve matrix/noncommutative equation (skip classification)

  Directly solves equations involving matrices, operators, or quaternions
  where multiplication order matters.

  Handles:
  - Left multiplication: A*X = B (solution: X = A^(-1)*B)
  - Right multiplication: X*A = B (solution: X = B*A^(-1))

  # Arguments

   * `variable` - The matrix/operator variable to solve for

  # Returns

  The solver result containing the matrix equation solution */
  solveMatrixEquation(variable: symbol): JsSolverResult
  polynomialLeadingCoefficient(var: symbol): Expression
  isImaginary(): boolean
  toPolarForm(): [Expression, Expression]
  /** Compute the least common multiple of two expressions

  For integer expressions, computes the mathematical LCM.
  For other expressions, returns the first expression.

  # Arguments

   * `other` - The expression to compute LCM with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let lcm = a.lcm(&b);
  assert_eq!(lcm, expr!(24));
  ```

  ```rust
  use mathhook_core::expr;

  // LCM with zero is zero
  let a = expr!(0);
  let b = expr!(15);
  let lcm = a.lcm(&b);
  assert_eq!(lcm, expr!(0));
  ``` */
  lcm(other: Expression): Expression
  /** Least Common Multiple */
  lcmWithOther(other: Expression): Expression
  /** Factor common elements */
  factorCommon(): Expression
  /** Check if the expression is one (robust version with simplification)

  This method simplifies the expression first before checking if it equals one.
  It correctly detects one for expressions like:
  - Literal ones: `1`, `1.0`, `2/2`
  - Symbolic ones: `x / x`, `x^0`, `cos(0)`
  - Simplified ones: `(x + 1) / (x + 1)`

  # Performance Note

  This method calls `simplify()`, which may be expensive for complex expressions.
  For performance-critical code where you only need to check literal ones,
  use `is_one_fast()` instead.

  # Examples

  ```rust
  use mathhook_core::simplify::Simplify;
  use mathhook_core::Expression;

  // Literal one
  assert!(Expression::integer(1).is_one());

  // Symbolic one after simplification
  let expr = Expression::pow(Expression::integer(5), Expression::integer(0));
  assert!(expr.is_one());
  ``` */
  isOne(): boolean
  complexArgument(): Expression
  findPoles(variable: symbol): Array<Expression>
  infiniteProduct(variable: symbol, start: Expression): Expression
  /** Check if this expression is a negative number

  Returns true if the expression is a negative integer, rational, or float.
  Returns false for symbolic expressions (even if they might evaluate to negative).

  # Examples

  ```rust
  use mathhook_core::Expression;

  assert!(Expression::integer(-5).is_negative_number());
  assert!(Expression::rational(-1, 2).is_negative_number());
  assert!(!Expression::integer(5).is_negative_number());
  assert!(!Expression::symbol("x").is_negative_number()); // Symbolic, not a number
  ``` */
  isNegativeNumber(): boolean
  subs(old: Expression, new: Expression): Expression
  totalDegree(): number | null
  /** Create a function expression

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let expression = Expression::function("sin", vec![expr!(x)]);
  ``` */
  static function(name: string, args: Array<Expression>): Expression
  polynomialContent(): Expression
  /** Check if expression is a valid mathematical expression */
  isValidExpression(): boolean
  /** Factor the expression by extracting common factors */
  factor(): Expression
  /** Try to simplify expression to zero if it's algebraically zero */
  simplifyToZero(): Expression | null
  /** Collect terms with respect to a specific variable */
  collect(var: symbol): Expression
  /** Get matrix dimensions for any matrix type

  Returns (rows, columns) for all matrix types.

  # Examples

  ```rust
  use mathhook_core::Expression;

  let matrix = Expression::matrix(vec![
  vec![Expression::integer(1), Expression::integer(2)],
  vec![Expression::integer(3), Expression::integer(4)]
  ]);
  assert_eq!(matrix.matrix_dimensions(), Some((2, 2)));

  let identity = Expression::identity_matrix(3);
  assert_eq!(identity.matrix_dimensions(), Some((3, 3)));
  ``` */
  matrixDimensions(): [number, number] | null
  /** Perform advanced simplification including special functions */
  advancedSimplify(): Expression
  /** Check if this expression represents a mathematical function

  Returns true for expressions like sin(x), cos(x), etc.
  Now integrated with Universal Function Intelligence System */
  isFunction(): boolean
  /** Fast path: solve as quadratic equation with steps (skip classification) */
  solveQuadraticWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Substitute variables with expressions

  Recursively replaces all occurrences of symbols with provided expressions.

  # Arguments

   * `substitutions` - Map from symbol name to replacement expression

  # Returns

  New expression with substitutions applied

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};
  use std::collections::HashMap;

  let x = symbol!(x);
  let y = symbol!(y);
  let e = expr!(x + y);

  let mut subs = HashMap::new();
  subs.insert("x".to_string(), expr!(3));
  subs.insert("y".to_string(), expr!(4));

  let result = e.substitute(&subs);
  assert_eq!(result, expr!(3 + 4));
  ``` */
  substitute(substitutions: Record<string, Expression>): Expression
  limitAtNegativeInfinity(variable: symbol): Expression
  /** Create a complex number from polar form

  Converts polar coordinates (magnitude, angle) to rectangular form (a + bi).
  The angle should be in radians.

  # Arguments

   * `magnitude` - The magnitude (r) of the complex number
   * `angle` - The angle (θ) in radians

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let magnitude = expr!(5);
  let angle = Expression::pi();
  let z = Expression::from_polar(magnitude, angle);
  ``` */
  static fromPolar(magnitude: Expression, angle: Expression): Expression
  /** Simplify trigonometric expressions */
  simplifyTrigonometric(): Expression
  /** Fast path: solve as polynomial equation (skip classification)

  Directly solves polynomial equations of degree 3+ (cubic, quartic, etc.)
  without running equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing polynomial roots */
  solvePolynomial(variable: symbol): JsSolverResult
  /** Advanced zero detection for specific algebraic patterns */
  detectAdvancedZeroPatterns(): boolean
  matrixDeterminant(): Expression
  /** Create an Euler-Mascheroni constant (gamma) expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let gamma = Expression::euler_gamma();
  ``` */
  static eulerGamma(): Expression
  /** Create a golden ratio (phi) expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let phi = Expression::golden_ratio();
  ``` */
  static goldenRatio(): Expression
  isPureImaginary(): boolean
  /** Fast path: solve as quadratic equation (skip classification)

  Directly solves equations of the form `ax^2 + bx + c = 0` using the
  quadratic formula without running equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing solutions from the quadratic formula */
  solveQuadratic(variable: symbol): JsSolverResult
  /** Generate step-by-step explanation for expansion */
  explainExpansion(): JsStepByStepExplanation
  /** Check if the expression is zero (robust version with simplification)

  This method simplifies the expression first before checking if it equals zero.
  It correctly detects zero for expressions like:
  - Literal zeros: `0`, `0.0`, `0/1`
  - Symbolic zeros: `x - x`, `0 * y`, `sin(0)`
  - Simplified zeros: `(x + 1) - (x + 1)`

  # Performance Note

  This method calls `simplify()`, which may be expensive for complex expressions.
  For performance-critical code where you only need to check literal zeros,
  use `is_zero_fast()` instead.

  # Examples

  ```rust
  use mathhook_core::simplify::Simplify;
  use mathhook_core::Expression;

  // Literal zero
  assert!(Expression::integer(0).is_zero());

  // Symbolic zero after simplification
  let expr = Expression::mul(vec![Expression::integer(0), Expression::integer(5)]);
  assert!(expr.is_zero());
  ``` */
  isZero(): boolean
  /** Evaluate method calls on expressions

  This handles method calls like matrix.det(), matrix.trace(), etc.
  by calling the appropriate methods on the underlying objects. */
  evaluateMethodCall(): Expression
  /** Create a division expression (symbolic, always succeeds)

  This constructor is for symbolic division where the denominator may be unknown
  or symbolic. It converts division to multiplication by the reciprocal: `a / b` → `a * b^(-1)`

  For numerical evaluation contexts where you need to detect division by zero,
  use `div_checked()` instead.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  // Symbolic division (denominator is unknown)
  let x = symbol!(x);
  let expr = Expression::div(Expression::integer(1), Expression::symbol(x));
  // Produces: 1 * x^(-1)

  // Constant division (still symbolic context)
  let expr = Expression::div(Expression::integer(3), Expression::integer(4));
  // Produces: 3 * 4^(-1), which simplifies to 3/4
  ``` */
  static div(numerator: Expression, denominator: Expression): Expression
  /** Create a complex number expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::complex(
  Expression::integer(3),
  Expression::integer(4),
  );
  ``` */
  static complex(real: Expression, imag: Expression): Expression
  /** Create a zero matrix expression

  # Examples

  ```rust
  use mathhook_core::matrices::operations::MatrixOperations;
  use mathhook_core::Expression;

  let zero = Expression::zero_matrix(2, 3);
  assert!(zero.is_zero_matrix());
  ``` */
  static zeroMatrix(rows: number, cols: number): Expression
  /** Fast path: solve as polynomial equation with steps (skip classification) */
  solvePolynomialWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  divPolynomial(divisor: Expression, var: symbol): [Expression, Expression]
  matrixPower(exponent: Expression): Expression
  /** Add rational expressions: a/b + c/d = (ad + bc)/(bd) */
  addRationals(other: Expression): Expression
  derivative(variable: symbol): Expression
  /** Create a derivative expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::derivative(
  Expression::pow(expr!(x), Expression::integer(2)),
  symbol!(x),
  1,
  );
  ``` */
  static derivativeWithExpressionVariableOrder(expression: Expression, variable: symbol, order: number): Expression
  /** Compute inverse of matrix expression

  For symbolic matrix expressions, this implements proper order reversal
  according to the mathematical rule: (AB)^(-1) = B^(-1) A^(-1)

  # Mathematical Rules

  - For products: (AB)^(-1) = B^(-1) A^(-1) (order reverses)
  - For matrix symbols: A^(-1) creates inverse function
  - For identity: I^(-1) = I
  - For scalars: a^(-1) = 1/a (reciprocal)

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let a = symbol!(A; matrix);
  let b = symbol!(B; matrix);

  let product = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);

  let inverse = product.inverse();
  ``` */
  inverse(): Expression
  /** Create an interval expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let interval = Expression::interval(
  Expression::integer(0),
  Expression::integer(10),
  true,
  false,
  );
  ``` */
  static interval(start: Expression, end: Expression, startInclusive: boolean, endInclusive: boolean): Expression
  /** Check if this expression is a specific symbol

  Convenience method for pattern matching against a specific symbol.
  More readable than inline matches! pattern in complex conditions.

  # Arguments

   * `symbol` - The symbol to check against

  # Returns

  True if this expression is exactly the given symbol

  # Examples

  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let y = symbol!(y);
  let expr = Expression::symbol(x.clone());

  assert!(expr.is_symbol_matching(&x));
  assert!(!expr.is_symbol_matching(&y));
  ``` */
  isSymbolMatching(symbol: symbol): boolean
  /** Evaluate expression with domain checking

  Computes numerical values from expressions while validating mathematical
  domain constraints. Returns `Result<Expression, MathError>` to handle
  domain violations gracefully.

  # Evaluation vs Simplification

   **Use `evaluate()` when:** You need numerical results with domain validation
   **Use `simplify()` when:** You need algebraic reduction without domain checking
   **Use `evaluate_with_context()` when:** You need variable substitution + computation

  # Domain Constraints Checked

  - `sqrt(x)`: Requires x >= 0 in real domain
  - `log(x)`: Requires x > 0 (pole at 0)
  - `tan(x)`: Has poles at π/2 + nπ
  - `arcsin(x)`, `arccos(x)`: Require |x| <= 1 in real domain
  - `csc(x)`, `sec(x)`, `cot(x)`: Have poles where sin/cos/tan = 0
  - Division by zero: Checked in `x/y` and `x^(-n)` for n > 0

  # Returns

  - `Ok(Expression)`: Evaluated result (numerical or symbolic if can't evaluate)
  - `Err(MathError::DomainError)`: Domain constraint violated
  - `Err(MathError::DivisionByZero)`: Division by zero detected

  # Examples

  ## Successful Evaluation

  ```rust
  use mathhook_core::{Expression, MathError};

  // Constants evaluate to numbers
  let sum = Expression::add(vec![Expression::integer(2), Expression::integer(3)]);
  assert_eq!(sum.evaluate().unwrap(), Expression::integer(5));

  let product = Expression::mul(vec![Expression::integer(2), Expression::integer(3), Expression::integer(4)]);
  assert_eq!(product.evaluate().unwrap(), Expression::integer(24));

  // Special values
  let sin_zero = Expression::function("sin".to_string(), vec![Expression::integer(0)]);
  assert_eq!(sin_zero.evaluate().unwrap(), Expression::integer(0));
  ```

  ## Domain Errors

  ```rust,ignore
  use mathhook_core::{expr, Expression, MathError};

  // sqrt requires non-negative input
  let sqrt_neg = Expression::function("sqrt".to_string(), vec![Expression::integer(-1)]);
  assert!(matches!(
  sqrt_neg.evaluate(),
  Err(MathError::Pole { .. })
  ));

  // log has pole at 0
  assert!(matches!(
  expr!(log(0)).evaluate(),
  Err(MathError::Pole { .. })
  ));

  // Division by zero
  assert!(matches!(
  expr!(1 / 0).evaluate(),
  Err(MathError::DivisionByZero)
  ));
  ```

  ## Symbolic Results (No Variables to Substitute)

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::simplify::Simplify;

  let x = symbol!(x);

  // Can't evaluate without variable value - returns simplified symbolic
  let result = expr!(x + 1).evaluate().unwrap();
  assert_eq!(result, expr!(x + 1).simplify());

  // For variable substitution, use evaluate_with_context() instead
  ```

  ## Handling Errors

  ```rust
  use mathhook_core::{Expression, MathError};

  let sqrt_neg = Expression::function("sqrt".to_string(), vec![Expression::integer(-1)]);
  match sqrt_neg.evaluate() {
    Ok(result) => println!("Result: {}", result),
    Err(MathError::DomainError { operation, value, reason }) => {
      eprintln!("Domain error in {}: {} ({})", operation, value, reason);
    }
    Err(e) => eprintln!("Other error: {:?}", e),
  }
  ``` */
  evaluate(): Expression
  /** Create a scalar matrix expression (c*I)

  # Examples

  ```rust
  use mathhook_core::Expression;

  let scalar = Expression::scalar_matrix(3, Expression::integer(5));
  // Creates 5*I (5 times the 3x3 identity matrix)
  ``` */
  static scalarMatrix(size: number, scalarValue: Expression): Expression
  toWolframWithDepth(context: JsWolframContext, depth: number): string
  /** Create a relation expression

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};
  use mathhook_core::core::expression::RelationType;

  let relation = Expression::relation(
  expr!(x),
  expr!(5),
  RelationType::Greater,
  );
  ``` */
  static relation(left: Expression, right: Expression, relationType: JsRelationType): Expression
  polynomialPrimitivePart(): Expression
  /** Simplify logarithmic expressions */
  simplifyLogarithms(): Expression
  matrixScalarMultiply(scalar: Expression): Expression
  /** Fast path: solve as linear equation (skip classification)

  Directly solves equations of the form `ax + b = 0` without running
  equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing the solution x = -b/a */
  solveLinear(variable: symbol): JsSolverResult
  matrixTrace(): Expression
  polyQuo(divisor: Expression, var: symbol): Expression
  /** Find all variables in expression

  Returns a vector of all unique Symbol nodes found in the expression tree.
  This is used by GCD algorithms to detect univariate polynomials. */
  findVariables(): Array<symbol>
  /** Collect and combine all like terms */
  collectTerms(): Expression
  /** Solve equation with step-by-step educational explanation

  Solves the equation `self = 0` for the given variable and generates
  an educational explanation showing each solving step. Use this when you need
  to teach or explain the solving process. For performance-critical code where
  you only need the answer, use `solve()` instead.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  A tuple of (solver result, step-by-step explanation)

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  let (result, explanation) = equation.solve_with_steps(&x);
  // The explanation contains educational content showing how to solve the equation
  ``` */
  solveWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  solveWithStepsWithVar(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  integrate(variable: symbol, depth: number): Expression
  /** Check if an expression is constant (contains no variables) */
  isConstant(): boolean
  remPolynomial(divisor: Expression, var: symbol): Expression
  /** Create a complex number from polar form

  Converts polar coordinates (magnitude, angle) to rectangular form (a + bi).

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let magnitude = expr!(5);
  let angle = Expression::pi();
  let z = Expression::from_polar_form(magnitude, angle);
  ``` */
  static fromPolarForm(magnitude: Expression, angle: Expression): Expression
  containsVariable(symbol: symbol): boolean
  /** Create an addition expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Flattening nested additions: `(a + b) + c` → `a + b + c`
  - Removing identity elements: `x + 0` → `x`
  - Combining like terms: `2x + 3x` → `5x`
  - Sorting terms in canonical order: `y + x` → `x + y`
  - Evaluating constant subexpressions: `2 + 3` → `5`

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Constant folding
  let expression = Expression::add(vec![
  Expression::integer(1),
  Expression::integer(2),
  ]);
  assert_eq!(expression, Expression::integer(3));

  // Identity element removal
  let x = expr!(x);
  let expression = Expression::add(vec![x.clone(), Expression::integer(0)]);
  assert_eq!(expression, x);

  // Commutativity (canonical ordering)
  let y = expr!(y);
  let expr1 = Expression::add(vec![x.clone(), y.clone()]);
  let expr2 = Expression::add(vec![y.clone(), x.clone()]);
  assert_eq!(expr1, expr2); // Both produce x + y in canonical order
  ``` */
  static add(terms: Array<Expression>): Expression
  finiteProduct(variable: symbol, start: Expression, end: Expression): Expression
  /** Convert evaluated expression to f64

  First evaluates the expression, then attempts to convert the result to f64.
  Returns error if the result is non-numerical (symbolic).

  # Returns

  f64 value if expression evaluates to a number

  # Errors

  Returns `MathError::NonNumericalResult` if evaluation produces symbolic expression

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};

  // Numerical expression
  let e = expr!(2 + 3);
  assert_eq!(e.evaluate_to_f64().unwrap(), 5.0);

  // Symbolic expression fails
  let x = symbol!(x);
  assert!(x.evaluate_to_f64().is_err());
  ``` */
  evaluateToF64(): number
  complexModulus(): Expression
  infiniteSum(variable: symbol, start: Expression): Expression
  /** Factor out the GCD from an expression

  Currently a stub that returns the original expression.
  Will be implemented to extract common factors.

  # Examples

  ```rust
  use mathhook_core::{expr, Expression};

  let expr = Expression::add(vec![
  expr!(6*x),
  expr!(9),
  ]);
  let factored = expr.factor_gcd();
  ``` */
  factorGcd(): Expression
  /** Factor out GCD from expression */
  factorGcdAll(): Expression
  /** Simplify rational expressions by canceling common factors */
  simplifyRational(): Expression
  /** Rationalize denominators (remove radicals from denominators) */
  rationalize(): Expression
  /** Count occurrences of a variable in the expression

  Recursively counts how many times a specific variable symbol appears
  in the expression tree. This is useful for:
  - Determining if an expression is polynomial in a variable
  - Analyzing variable dependencies
  - Checking if a variable appears in an equation

  # Arguments

   * `variable` - The symbol to count occurrences of

  # Returns

  The number of times the variable appears in the expression

  # Examples

  Basic counting in simple expressions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let expr = Expression::mul(vec![
  Expression::integer(2),
  Expression::symbol(x.clone()),
  ]);
  assert_eq!(expr.count_variable_occurrences(&x), 1);
  ```

  Counting multiple occurrences:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // x^2 + 2*x + 1 has 2 occurrences of x (in x^2 and in 2*x)
  let expr = Expression::Add(Box::new(vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(1),
  ]));
  assert_eq!(expr.count_variable_occurrences(&x), 2);
  ```

  Counting in power expressions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // x^x has 2 occurrences (base and exponent)
  let expr = Expression::pow(
  Expression::symbol(x.clone()),
  Expression::symbol(x.clone())
  );
  assert_eq!(expr.count_variable_occurrences(&x), 2);
  ```

  Counting in functions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // sin(x)
  let expr = Expression::function("sin", vec![Expression::symbol(x.clone())]);
  assert_eq!(expr.count_variable_occurrences(&x), 1);

  // f(x, x, 2) has 2 occurrences
  let expr2 = Expression::function("f", vec![
  Expression::symbol(x.clone()),
  Expression::symbol(x.clone()),
  Expression::integer(2),
  ]);
  assert_eq!(expr2.count_variable_occurrences(&x), 2);
  ```

  Zero occurrences when variable is not present:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let y = symbol!(y);
  let expr = Expression::symbol(y.clone());
  assert_eq!(expr.count_variable_occurrences(&x), 0);
  ``` */
  countVariableOccurrences(variable: symbol): number
  /** Create a rational number expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::rational(3, 4); // 3/4
  let expr = Expression::rational(-1, 2); // -1/2
  ``` */
  static rational(numerator: number, denominator: number): Expression
  explainFiniteSum(variable: symbol, start: Expression, end: Expression): JsStepByStepExplanation
  /** Fast path: solve as linear equation with steps (skip classification) */
  solveLinearWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Create a power expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Applying power identities: `x^0` → `1`, `x^1` → `x`, `1^x` → `1`
  - Evaluating constant powers: `2^3` → `8`
  - Converting negative exponents to rationals: `x^(-1)` → `1/x`
  - Flattening nested powers: `(x^a)^b` → `x^(a*b)`
  - Handling special cases: `0^n` → `0` for positive n

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Power identities
  let x = expr!(x);
  let expression = Expression::pow(x.clone(), Expression::integer(1));
  assert_eq!(expression, x);

  let expression = Expression::pow(x.clone(), Expression::integer(0));
  assert_eq!(expression, Expression::integer(1));

  // Constant evaluation
  let expression = expr!(2 ^ 3);
  assert_eq!(expression, Expression::integer(8));

  // Nested power flattening
  let expression = Expression::pow(
  Expression::pow(x.clone(), Expression::integer(2)),
  Expression::integer(3),
  );
  // Produces x^6 in canonical form
  ``` */
  static pow(base: Expression, exponent: Expression): Expression
  /** Compute the greatest common divisor of two expressions

  For integer expressions, computes the mathematical GCD.
  For polynomial expressions with integer coefficients, uses fast IntPoly algorithm.
  For other expressions, returns 1.

  # Arguments

   * `other` - The expression to compute GCD with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let gcd = a.gcd(&b);
  assert_eq!(gcd, expr!(4));
  ```

  ```rust
  use mathhook_core::expr;

  // GCD of zero with any number is that number
  let a = expr!(0);
  let b = expr!(15);
  let gcd = a.gcd(&b);
  assert_eq!(gcd, expr!(15));
  ``` */
  gcd(other: Expression): Expression
  /** GCD using IntPoly fast-path (primary path)

  Converts to IntPoly at API boundary, performs pure numeric GCD,
  converts result back. NO Expression tree walking in fast path. */
  gcdWithOther(other: Expression): Expression
  /** Create a negative infinity expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let neg_inf = Expression::negative_infinity();
  ``` */
  static negativeInfinity(): Expression
  /** Negate an expression */
  negate(): Expression
  isDifferentiable(variable: symbol): boolean
  /** Fast path: solve as ODE with steps (skip classification) */
  solveOdeWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Create a product expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::product(
  expr!(i),
  symbol!(i),
  Expression::integer(1),
  Expression::integer(10),
  );
  ``` */
  static product(expression: Expression, variable: symbol, start: Expression, end: Expression): Expression
  polynomialLcm(other: Expression): Expression
  /** Simplify other special functions */
  simplifySpecialFunctions(): Expression
  /** Create an infinity expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let inf = Expression::infinity();
  ``` */
  static infinity(): Expression
  /** Extract the real part of a complex number

  Returns the real component of a complex expression. For non-complex
  expressions, returns the expression itself.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let real_part = z.real();
  assert_eq!(real_part, expr!(3));
  ``` */
  real(): Expression
  /** Create a sum expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::sum(
  expr!(i),
  symbol!(i),
  Expression::integer(1),
  Expression::integer(10),
  );
  ``` */
  static sum(expression: Expression, variable: symbol, start: Expression, end: Expression): Expression
  matrixSubtract(other: Expression): Expression
  /** Fast literal one check without simplification

  This is a performance-optimized version that only checks if the expression
  is literally `Number(1)`. It does NOT simplify the expression first.

  Use this in performance-critical loops where you know the expression
  is already in simplified form, or where you specifically want to check
  for literal ones only.

  # Examples

  ```rust
  use mathhook_core::Expression;

  // Detects literal one
  assert!(Expression::integer(1).is_one_fast());

  // Pow constructor auto-simplifies, so x^0 = 1 IS detected
  let expr = Expression::pow(Expression::integer(5), Expression::integer(0));
  assert!(expr.is_one_fast()); // Simplified to 1 by constructor

  // is_one_fast() checks ONLY for literal Number(1)
  // It does not simplify complex expressions first
  ``` */
  isOneFast(): boolean
  simplify(): Expression
  /** Get the symbol if this is a simple symbol expression */
  asSymbol(): symbol | null
  degree(var: symbol): number | null
  powerSeriesCoefficients(variable: symbol, point: Expression, order: number): Array<Expression>
  /** Multiply rational expressions: (a/b) * (c/d) = (ac)/(bd) */
  multiplyRationals(other: Expression): Expression
  /** Create a float expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::float(3.14159);
  ``` */
  static float(value: number): Expression
  content(): Expression
  /** Create an integral expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::integral(
  expr!(x),
  symbol!(x),
  );
  ``` */
  static integral(integrand: Expression, variable: symbol): Expression
  limitDirected(variable: symbol, point: Expression, direction: JsLimitDirection): Expression
  /** Convert to rational form (numerator/denominator) */
  toRationalForm(): [Expression, Expression]
  limit(variable: symbol, point: Expression): Expression
  /** Create a limit expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::limit(
  expr!(x),
  symbol!(x),
  Expression::integer(0),
  );
  ``` */
  static limitWithExpressionVariablePoint(expression: Expression, variable: symbol, point: Expression): Expression
  /** Convert to LaTeX representation for solvers (avoid conflict) */
  solverToLatex(): string
  evalNumeric(precision: number): Expression
  classify(): JsExpressionClass
  matrixTranspose(): Expression
  /** Create an undefined expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let undef = Expression::undefined();
  ``` */
  static undefined(): Expression
  limitAtInfinity(variable: symbol): Expression
  simplifyMatrix(): Expression
  /** Polynomial division using optimized algorithms */
  polynomialDivide(divisor: Expression): [Expression, Expression]
  isReal(): boolean
  /** Get function intelligence properties if available

  Seamless integration between core expressions and function intelligence */
  getFunctionIntelligence(): JsFunctionProperties | null
  /** Create a diagonal matrix expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let diag = Expression::diagonal_matrix(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  ``` */
  static diagonalMatrix(diagonalElements: Array<Expression>): Expression
  polynomialGcd(other: Expression): Expression
  explainPolyGcd(other: Expression): JsStepByStepExplanation
  /** Create a set expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let set = Expression::set(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3),
  ]);
  ``` */
  static set(elements: Array<Expression>): Expression
  polyDiv(divisor: Expression, var: symbol): [Expression, Expression]
  /** Expand the expression by distributing multiplication over addition */
  expand(): Expression
  isIdentityMatrix(): boolean
  equals(other: Expression): boolean
  cloneValue(): Expression
}
export type JsExpression = Expression

export declare class ExpressionClass {
  equals(other: ExpressionClass): boolean
  cloneValue(): ExpressionClass
}
export type JsExpressionClass = ExpressionClass

export declare class ExpSimplificationStrategy {
  name(): string
}
export type JsExpSimplificationStrategy = ExpSimplificationStrategy

export declare class ExtensionError {
  cloneValue(): ExtensionError
}
export type JsExtensionError = ExtensionError

export declare class ExtensionRegistry {
  constructor()
  /** Get all properties from all registered extensions

  This method uses caching to avoid recomputing properties on every call.
  The cache is automatically invalidated when new extensions are registered. */
  getAllProperties(): Record<string, JsFunctionProperties>
  /** Check if any registered extension provides a function */
  hasFunction(name: string): boolean
  /** Get list of all registered extension families */
  registeredFamilies(): Array<string>
}
export type JsExtensionRegistry = ExtensionRegistry

export declare class FactorialSimplificationStrategy {
  name(): string
}
export type JsFactorialSimplificationStrategy = FactorialSimplificationStrategy

export declare class FiniteFieldError {
  equals(other: FiniteFieldError): boolean
  cloneValue(): FiniteFieldError
}
export type JsFiniteFieldError = FiniteFieldError

export declare class FormattingError {
  equals(other: FormattingError): boolean
  cloneValue(): FormattingError
}
export type JsFormattingError = FormattingError

export declare class FunctionEducator {
  constructor()
}
export type JsFunctionEducator = FunctionEducator

export declare class FunctionFamily {
  equals(other: FunctionFamily): boolean
  cloneValue(): FunctionFamily
}
export type JsFunctionFamily = FunctionFamily

export declare class FunctionProperties {
  /** Get Wolfram Language function name

  Used for Wolfram formatting without hardcoded function name matching.
  Returns the Wolfram name if registered, otherwise None.

  # Examples

  ```
  use mathhook_core::functions::intelligence::get_universal_registry;

  let registry = get_universal_registry();
  if let Some(props) = registry.get_properties("sin") {
    assert_eq!(props.wolfram_name(), Some("Sin"));
  }
  if let Some(props) = registry.get_properties("ln") {
    assert_eq!(props.wolfram_name(), Some("Log"));
  }
  ``` */
  wolframName(): string | null
  /** Check if function has derivative rule

  Hot path method for performance-critical operations */
  hasDerivative(): boolean
  /** Get function family for quick classification */
  family(): FunctionFamily
  /** Get derivative expression using registry rules

  Computes the derivative of f(arg) with respect to arg using the
  registered derivative rule. The chain rule (multiplying by d(arg)/dx)
  must be applied separately.

  # Arguments

   * `arg` - The argument expression to the function

  # Returns

  Returns the derivative expression, or None if no derivative rule exists

  # Examples

  ```
  use mathhook_core::functions::intelligence::get_universal_registry;
  use mathhook_core::{expr, symbol};

  let registry = get_universal_registry();
  let x = symbol!(x);

  if let Some(props) = registry.get_properties("sin") {
    let derivative = props.get_derivative_expression(&x.into());
  }
  ``` */
  getDerivativeExpression(arg: Expression): Expression | null
  /** Check if function has antiderivative rule

  Hot path method for performance-critical operations */
  hasAntiderivative(): boolean
  /** Get special value count for caching optimization */
  specialValueCount(): number
  cloneValue(): FunctionProperties
}
export type JsFunctionProperties = FunctionProperties

export declare class GammaSimplificationStrategy {
  name(): string
}
export type JsGammaSimplificationStrategy = GammaSimplificationStrategy

export declare class GaussianQuadrature {
  /** Create a new Gaussian quadrature integrator

  # Arguments

   * `order` - Number of quadrature points (2, 3, 4, or 5)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::numerical::GaussianQuadrature;

  let integrator = GaussianQuadrature::new(5);
  ``` */
  constructor(order: number)
}
export type JsGaussianQuadrature = GaussianQuadrature

export declare class GeneratingFunction {
  cloneValue(): GeneratingFunction
}
export type JsGeneratingFunction = GeneratingFunction

export declare class GeneratingFunctionType {
  cloneValue(): GeneratingFunctionType
}
export type JsGeneratingFunctionType = GeneratingFunctionType

export declare class GenericTrigSimplificationStrategy {
  name(): string
  constructor(functionName: string)
}
export type JsGenericTrigSimplificationStrategy = GenericTrigSimplificationStrategy

export declare class GpuAccelerator {
  constructor()
  /** Get GPU capabilities */
  getCapabilities(): JsGpuCapabilities | null
  /** Update GPU thresholds based on performance measurements */
  updateThresholds(thresholds: JsGpuThresholds): void
  /** Check if GPU acceleration should be used for an operation */
  shouldUseGpu(operation: JsGpuOperation, size: number): boolean
}
export type JsGpuAccelerator = GpuAccelerator

export declare class GpuBackend {
  equals(other: GpuBackend): boolean
  cloneValue(): GpuBackend
}
export type JsGpuBackend = GpuBackend

export declare class GpuCapabilities {
  cloneValue(): GpuCapabilities
}
export type JsGpuCapabilities = GpuCapabilities

export declare class GpuOperation {
  equals(other: GpuOperation): boolean
  cloneValue(): GpuOperation
}
export type JsGpuOperation = GpuOperation

export declare class GpuStatistics {
  constructor()
  cloneValue(): GpuStatistics
}
export type JsGpuStatistics = GpuStatistics

export declare class GpuThresholds {
  constructor()
  cloneValue(): GpuThresholds
}
export type JsGpuThresholds = GpuThresholds

export declare class GroebnerBasis {
  /** Get all variables that appear in the basis */
  getVariables(): Array<symbol>
  /** Reduce the Gröbner basis to minimal form

  A reduced Gröbner basis has:
  1. Leading coefficients are 1 (monic)
  2. No monomial of any basis element is divisible by the leading
  term of another basis element */
  reduce(): void
  /** Test if a polynomial is in the ideal generated by this basis

  # Arguments

   * `poly` - Polynomial to test for membership

  # Returns

  Returns `true` if the polynomial reduces to zero modulo the basis

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::groebner::{GroebnerBasis, MonomialOrder};

  let x = symbol!(x);
  let y = symbol!(y);
  let f1 = expr!(x - y);
  let f2 = Expression::add(vec![Expression::pow(y.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  let mut gb = GroebnerBasis::new(
  vec![f1, f2],
  vec![x.clone(), y.clone()],
  MonomialOrder::Lex
  );
  gb.compute();

  let test = Expression::add(vec![Expression::pow(x.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  assert!(gb.contains(&test));
  ``` */
  contains(poly: Expression): boolean
  /** Compute the Gröbner basis using Buchberger's algorithm

  Transforms the initial generators into a Gröbner basis by computing
  S-polynomials and adding non-zero remainders to the basis.

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::groebner::{GroebnerBasis, MonomialOrder};

  let x = symbol!(x);
  let y = symbol!(y);
  let f1 = Expression::add(vec![Expression::pow(x.clone().into(), Expression::integer(2)), Expression::pow(y.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  let f2 = Expression::add(vec![x.clone().into(), Expression::mul(vec![Expression::integer(-1), y.clone().into()])]);
  let mut gb = GroebnerBasis::new(
  vec![f1, f2],
  vec![x, y],
  MonomialOrder::Lex
  );
  gb.compute();
  ``` */
  compute(): void
  cloneValue(): GroebnerBasis
}
export type JsGroebnerBasis = GroebnerBasis

export declare class HeatEquationSolver {
  constructor()
  canSolve(pdeType: JsPdeType): boolean
  priority(): number
  description(): string
  name(): string
  /** Creates solver with custom maximum number of terms */
  static withMaxTerms(maxTerms: number): HeatEquationSolver
}
export type JsHeatEquationSolver = HeatEquationSolver

export declare class Hermite {
  static polynomial(n: number, var: symbol): Expression
  static recurrenceCoefficients(n: number): [number, number, number]
  static evaluate(n: number, x: number): number
}
export type JsHermite = Hermite

export declare class HermiteIntelligence {
  constructor()
  /** Get all Hermite polynomial properties */
  getProperties(): Record<string, FunctionProperties>
  /** Check if function is a Hermite polynomial */
  hasFunction(name: string): boolean
}
export type JsHermiteIntelligence = HermiteIntelligence

export declare class HeuristicGCDFailed {
  cloneValue(): HeuristicGCDFailed
}
export type JsHeuristicGCDFailed = HeuristicGCDFailed

export declare class HomogeneousODESolver {
  /** Detect if ODE is homogeneous

  Checks if dy/dx can be expressed as function of y/x only.

  # Arguments

   * `equation` - The ODE equation
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  True if equation is homogeneous */
  isHomogeneous(equation: Expression, dependent: symbol, independent: symbol): boolean
  /** Extract homogeneous function f(v) from ODE

  Given dy/dx = expression, extract f(v) where v = y/x

  # Arguments

   * `rhs` - Right-hand side of dy/dx = rhs
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  Function f(v) if successfully extracted */
  extractHomogeneousFunction(rhs: Expression, dependent: symbol, independent: symbol): Expression | null
}
export type JsHomogeneousODESolver = HomogeneousODESolver

export declare class HyperbolicIntelligence {
  constructor()
  /** Get all hyperbolic function properties */
  getProperties(): Record<string, FunctionProperties>
  /** Check if function is hyperbolic */
  hasFunction(name: string): boolean
}
export type JsHyperbolicIntelligence = HyperbolicIntelligence

export declare class ImplicitMultiplicationProcessor {
  /** Insert implicit multiplication with maximum performance and comprehensive token support */
  static insertImplicitMultiplication(input: string): string
}
export type JsImplicitMultiplicationProcessor = ImplicitMultiplicationProcessor

export declare class InitialCondition {
  /** Create an initial derivative condition */
  static derivative(function: Expression): InitialCondition
  /** Create an initial value condition */
  static value(function: Expression): InitialCondition
  equals(other: InitialCondition): boolean
  cloneValue(): InitialCondition
}
export type JsInitialCondition = InitialCondition

export declare class IntegrationByParts {
  /** Attempt integration by parts on an expression

  Uses LIATE rule to select u and dv:
  - L: Logarithmic functions (ln, log)
  - I: Inverse trigonometric functions (arcsin, arctan, etc.)
  - A: Algebraic functions (polynomials, powers)
  - T: Trigonometric functions (sin, cos, tan)
  - E: Exponential functions (e^x, a^x)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::calculus::integrals::Integration;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // ∫ x·e^x dx
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationByParts::integrate(&expr, x, 0);
  ``` */
  static integrate(expr: Expression, variable: symbol, depth: number): Expression | null
  /** Integration by parts with strategy context tracking

  Prevents infinite recursion by using strategy context.
  The context is already marked with IntegrationByParts active,
  so recursive calls won't try by_parts again. */
  static integrateWithContext(expr: Expression, variable: symbol, context: JsStrategyContext, depth: number): Expression | null
  /** Determine if an expression is a good choice for u (LIATE priority)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let expr = Expression::function("ln", vec![Expression::symbol(x.clone())]);
  let is_good = IntegrationByParts::is_good_u_choice(&expr, &x);
  ``` */
  static isGoodUChoice(expr: Expression, variable: symbol): boolean
  /** Try integration by parts with specific u and dv

  ∫ u dv = uv - ∫ v du

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let u = Expression::symbol(x.clone());
  let dv = Expression::function("exp", vec![Expression::symbol(x.clone())]);
  let result = IntegrationByParts::try_by_parts(&u, &dv, x, 0);
  ``` */
  static tryByParts(u: Expression, dv: Expression, variable: symbol, depth: number): Expression | null
  /** Apply integration by parts multiple times (for cases like ∫ x²·e^x dx)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // ∫ x²·e^x dx requires two applications of by parts
  let expr = Expression::mul(vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationByParts::integrate_repeated(&expr, &x, 2);
  ``` */
  static integrateRepeated(expr: Expression, variable: symbol, maxIterations: number): Expression | null
}
export type JsIntegrationByParts = IntegrationByParts

export declare class IntegrationConfig {
  constructor()
  cloneValue(): IntegrationConfig
}
export type JsIntegrationConfig = IntegrationConfig

export declare class IntegrationExplanation {
  /** Get the integration strategy/technique that was used */
  strategyUsed(): string
  /** Generate explanation for integrating an expression

  Analyzes the integrand and provides step-by-step explanation
  of the integration process, automatically selecting the appropriate
  technique (power rule, substitution, trigonometric, etc.)

  # Arguments

   * `expr` - The integrand to explain
   * `var` - The variable of integration

  # Examples

  ```rust
  use mathhook_core::{symbol, Expression};
  use mathhook_core::calculus::integrals::educational::IntegrationExplanation;

  let x = symbol!(x);
  let expr = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
  let explanation = IntegrationExplanation::generate(&expr, &x);
  assert!(!explanation.steps().is_empty());
  ``` */
  static generate(expr: Expression, var: symbol): IntegrationExplanation
  /** Get the step-by-step explanation as a vector of strings */
  steps(): Array<string>
}
export type JsIntegrationExplanation = IntegrationExplanation

export declare class IntegrationMethods {
  /** Attempt integration by parts

  Uses the IntegrationByParts module to attempt integration by parts.

  # Errors

  Returns `MathError::NotImplemented` if integration by parts cannot be applied
  or if no antiderivative can be found.

  # Examples

  ```rust
  use mathhook_core::Expression;
  use mathhook_core::symbol;
  use mathhook_core::calculus::integrals::IntegrationMethods;

  let x = symbol!(x);
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationMethods::by_parts(&expr, x);
  # Ok::<(), Box<dyn std::error::Error>>(())
  ``` */
  static byParts(expr: Expression, variable: symbol): Expression
  /** Attempt integration by substitution

  Uses u-substitution to integrate composite functions f(g(x)) where
  the derivative g'(x) appears in the integrand.

  # Errors

  Returns `MathError::NotImplemented` if no suitable substitution can be found.

  # Examples

  ```rust
  use mathhook_core::{Expression, Symbol};
  use mathhook_core::symbol;
  use mathhook_core::calculus::integrals::IntegrationMethods;

  let x = symbol!(x);
  let expr = Expression::function("sin", vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))
  ]);
  let result = IntegrationMethods::substitution(&expr, x);
  # Ok::<(), Box<dyn std::error::Error>>(())
  ``` */
  static substitution(expr: Expression, variable: symbol): Expression
}
export type JsIntegrationMethods = IntegrationMethods

export declare class IntegrationResult {
  cloneValue(): IntegrationResult
}
export type JsIntegrationResult = IntegrationResult

export declare class IntegrationStrategy {
  equals(other: IntegrationStrategy): boolean
  cloneValue(): IntegrationStrategy
}
export type JsIntegrationStrategy = IntegrationStrategy

export declare class IntelligenceConfig {
  constructor()
  cloneValue(): IntelligenceConfig
}
export type JsIntelligenceConfig = IntelligenceConfig

export declare class IntelligenceReport {
  cloneValue(): IntelligenceReport
}
export type JsIntelligenceReport = IntelligenceReport

export declare class IssueSeverity {
  equals(other: IssueSeverity): boolean
  cloneValue(): IssueSeverity
}
export type JsIssueSeverity = IssueSeverity

export declare class Laguerre {
  static recurrenceCoefficients(n: number): [number, number, number]
  static polynomial(n: number, var: symbol): Expression
  static evaluate(n: number, x: number): number
}
export type JsLaguerre = Laguerre

export declare class LaguerreIntelligence {
  constructor()
  /** Check if function is a Laguerre polynomial */
  hasFunction(name: string): boolean
  /** Get all Laguerre polynomial properties */
  getProperties(): Record<string, FunctionProperties>
}
export type JsLaguerreIntelligence = LaguerreIntelligence

export declare class LaplaceEquationSolver {
  constructor()
  priority(): number
  name(): string
  description(): string
  canSolve(pdeType: JsPdeType): boolean
  static withMaxTerms(maxTerms: number): LaplaceEquationSolver
}
export type JsLaplaceEquationSolver = LaplaceEquationSolver

export declare class LaplaceSolution {
  equals(other: LaplaceSolution): boolean
  cloneValue(): LaplaceSolution
}
export type JsLaplaceSolution = LaplaceSolution

export declare class LaTeXContext {
  constructor()
  cloneValue(): LaTeXContext
}
export type JsLaTeXContext = LaTeXContext

export declare class Legendre {
  static polynomial(n: number, var: symbol): Expression
  static evaluate(n: number, x: number): number
  static recurrenceCoefficients(n: number): [number, number, number]
}
export type JsLegendre = Legendre

export declare class LegendreIntelligence {
  constructor()
  /** Check if function is a Legendre polynomial */
  hasFunction(name: string): boolean
  /** Get all Legendre polynomial properties */
  getProperties(): Record<string, FunctionProperties>
}
export type JsLegendreIntelligence = LegendreIntelligence

export declare class LimitDirection {
  equals(other: LimitDirection): boolean
  cloneValue(): LimitDirection
}
export type JsLimitDirection = LimitDirection

export declare class LimitEducation {

}
export type JsLimitEducation = LimitEducation

export declare class LimitMethods {
  /** Apply L'Hôpital's rule for limits at infinity

  For indeterminate forms ∞/∞ as x→∞:
  lim[x→∞] f(x)/g(x) = lim[x→∞] f'(x)/g'(x) */
  static lhopitalRuleAtInfinity(numerator: Expression, denominator: Expression, variable: symbol): Expression
  /** Compute trigonometric limits */
  static trigonometricLimit(expr: Expression, variable: symbol, point: Expression): Expression
  /** Check if expression represents infinity */
  static isInfinite(expr: Expression): boolean
  /** Compute rational function limit */
  static rationalLimit(numerator: Expression, denominator: Expression, variable: symbol, point: Expression): Expression
  /** Check for indeterminate forms */
  static isIndeterminateForm(expr: Expression, variable: symbol, point: Expression): boolean
  /** Compute polynomial limit */
  static polynomialLimit(expr: Expression, variable: symbol, point: Expression): Expression
  /** Substitute variable with point and evaluate */
  static substituteAndEvaluate(expr: Expression, variable: symbol, point: Expression): Expression
  /** Compute rational function limit at infinity

  Handles cases like ln(x)/x where degree-based analysis doesn't work */
  static rationalLimitAtInfinity(numerator: Expression, denominator: Expression, variable: symbol): Expression
  /** Apply L'Hôpital's rule for indeterminate forms

  For indeterminate forms 0/0 or ∞/∞:
  lim[x→a] f(x)/g(x) = lim[x→a] f'(x)/g'(x)

  Order is preserved for noncommutative expressions.
  Applies L'Hôpital's rule recursively up to 5 times if needed. */
  static lhopitalRule(numerator: Expression, denominator: Expression, variable: symbol, point: Expression): Expression
}
export type JsLimitMethods = LimitMethods

export declare class LinearFirstOrderSolver {

}
export type JsLinearFirstOrderSolver = LinearFirstOrderSolver

export declare class LinearSolver {
  constructor()
  /** Solve with step-by-step explanation */
  solveWithExplanation(equation: Expression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Solve linear equation ax + b = 0

  Fractional solutions are automatically simplified to lowest terms via
  `BigRational::new()`, which reduces fractions using GCD. Integer solutions
  (where numerator is divisible by denominator) are returned as integers.

  # Examples

  ```rust
  use mathhook_core::algebra::solvers::{linear::LinearSolver, EquationSolver, SolverResult};
  use mathhook_core::core::{Expression, Number};
  use mathhook_core::symbol;
  use num_bigint::BigInt;

  let solver = LinearSolver::new_fast();
  let x = symbol!(x);

  // Example: 4x = 6 gives x = 3/2 (simplified from 6/4)
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(4), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  match solver.solve(&equation, &x) {
    SolverResult::Single(solution) => {
      if let Expression::Number(Number::Rational(r)) = solution {
        assert_eq!(r.numer(), &BigInt::from(3));
        assert_eq!(r.denom(), &BigInt::from(2));
      }
    }
    _ => panic!("Expected single solution"),
  }
  ``` */
  solve(equation: Expression, variable: symbol): JsSolverResult
  /** Check if this solver can handle the equation */
  canSolve(equation: Expression): boolean
  /** Create solver without step-by-step (for performance) */
  static newFast(): LinearSolver
  cloneValue(): LinearSolver
}
export type JsLinearSolver = LinearSolver

export declare class LinearSystemSolver {
  /** Solve 2×2 linear system dx/dt = Ax

  Specialized solver for 2×2 systems with explicit formulas.

  # Complexity

   * **Time:** O(1) for 2×2 eigenvalue computation (quadratic formula)
   * **Space:** O(1) for storing solution components

  # Arguments

   * `a11`, `a12`, `a21`, `a22` - Matrix coefficients [a11 a12; a21 a22]
   * `independent_var` - The independent variable (typically t)

  # Returns

  Vector [x₁(t), x₂(t)] representing the solution

  # Examples

  ```rust
  use mathhook_core::calculus::ode::systems::LinearSystemSolver;
  use mathhook_core::{symbol, expr};

  let t = symbol!(t);

  // dx/dt = [1 0; 0 2]x
  let solver = LinearSystemSolver;
  let solution = solver.solve_2x2(
  &expr!(1), &expr!(0),
  &expr!(0), &expr!(2),
  &t
  );
  ``` */
  solve2x2(a11: Expression, a12: Expression, a21: Expression, a22: Expression, independentVar: symbol): Array<Expression>
  /** Solve linear system dx/dt = Ax

  Uses eigenvalue-eigenvector method. For an n×n system:
  - Compute eigenvalues λ₁, λ₂, ..., λₙ and eigenvectors v₁, v₂, ..., vₙ
  - General solution: x(t) = c₁e^(λ₁t)v₁ + c₂e^(λ₂t)v₂ + ... + cₙe^(λₙt)vₙ

  # Complexity

   * **Time:** O(n³) for eigenvalue decomposition of n×n matrix
   * **Space:** O(n²) for storing eigenvectors and intermediate results

  # Arguments

   * `coefficient_matrix` - The constant coefficient matrix A
   * `independent_var` - The independent variable (typically t)
   * `initial_conditions` - Optional initial state vector x(t₀) = x₀

  # Returns

  Vector of expressions representing the solution [x₁(t), x₂(t), ..., xₙ(t)]

  # Examples

  ```rust
  use mathhook_core::calculus::ode::systems::LinearSystemSolver;
  use mathhook_core::matrices::Matrix;
  use mathhook_core::{symbol, expr};

  let t = symbol!(t);

  // 2×2 system: dx/dt = [1 0; 0 2]x
  let matrix = Matrix::diagonal(vec![expr!(1), expr!(2)]);

  let solver = LinearSystemSolver;
  let solution = solver.solve(&matrix, &t, None);
  ``` */
  solve(coefficientMatrix: JsMatrix, independentVar: symbol, initialConditions?: Array<Expression> | undefined | null): Array<Expression>
}
export type JsLinearSystemSolver = LinearSystemSolver

export declare class LinearTerm {
  cloneValue(): LinearTerm
}
export type JsLinearTerm = LinearTerm

export declare class LogarithmicIntelligence {
  constructor()
  /** Get all logarithmic function properties */
  getProperties(): Record<string, FunctionProperties>
  /** Check if function is logarithmic */
  hasFunction(name: string): boolean
}
export type JsLogarithmicIntelligence = LogarithmicIntelligence

export declare class LogarithmSimplificationStrategy {
  name(): string
}
export type JsLogarithmSimplificationStrategy = LogarithmSimplificationStrategy

export declare class LUDecomposition {
  equals(other: LUDecomposition): boolean
  cloneValue(): LUDecomposition
}
export type JsLUDecomposition = LUDecomposition

export declare class MathConstant {
  /** Get the approximate floating-point value of the constant

  # Examples

  ```rust
  use mathhook_core::MathConstant;

  assert!((MathConstant::Pi.to_f64() - std::f64::consts::PI).abs() < 1e-10);
  assert!((MathConstant::E.to_f64() - std::f64::consts::E).abs() < 1e-10);
  ``` */
  toF64(): number
  equals(other: MathConstant): boolean
  cloneValue(): MathConstant
}
export type JsMathConstant = MathConstant

export declare class MathIdentity {
  cloneValue(): MathIdentity
}
export type JsMathIdentity = MathIdentity

export declare class MathLanguage {
  constructor()
  /** Convert to format string for conditional formatting */
  asStr(): string
  equals(other: MathLanguage): boolean
  cloneValue(): MathLanguage
}
export type JsMathLanguage = MathLanguage

export declare class MathSerializer {
  /** Parse - convert serialized data to Expression */
  static parse(dataStr: string): Expression
  /** Stringify compact - compact format */
  static stringifyCompact(expr: Expression): string
  /** Stringify - convert Expression to serialized format */
  static stringify(expr: Expression): string
}
export type JsMathSerializer = MathSerializer

export declare class Matrix {
  /** Check if matrix is nilpotent (A^k = 0 for some positive integer k)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let zero_matrix = Matrix::zero(3, 3);
  assert!(zero_matrix.is_nilpotent());

  let identity = Matrix::identity(3);
  assert!(!identity.is_nilpotent());
  ``` */
  isNilpotent(): boolean
  isNilpotentAll(): boolean
  conditionNumber(): Expression
  /** Compute matrix square root using eigendecomposition
  sqrt(A) = P sqrt(D) P^(-1) where sqrt(D) = diag(sqrt(d_1), sqrt(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(4),
  Expression::integer(9)
  ]);
  let sqrt_matrix = matrix.matrix_sqrt_eigen().unwrap();
  let eigenvals = sqrt_matrix.eigenvalues();
  // Eigenvalues are sqrt(4) and sqrt(9) in symbolic form
  assert_eq!(eigenvals.len(), 2);
  assert_eq!(eigenvals[0], Expression::pow(Expression::integer(4), Expression::rational(1, 2)));
  assert_eq!(eigenvals[1], Expression::pow(Expression::integer(9), Expression::rational(1, 2)));
  ``` */
  matrixSqrtEigen(): Matrix | null
  /** Perform Singular Value Decomposition

  Decomposes matrix A into A = UΣV^T where:
  - U contains left singular vectors (orthogonal)
  - Σ contains singular values (diagonal, non-negative)
  - V^T contains right singular vectors (orthogonal)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [1, 2],
  [3, 4]
  ]);

  let svd = matrix.svd_decomposition().unwrap();
  let (u_rows, u_cols) = svd.u.dimensions();
  assert_eq!(u_rows, 2);
  ``` */
  svdDecomposition(): JsSVDDecomposition | null
  svdDecompositionAll(): JsSVDDecomposition | null
  /** Check if this is an identity matrix */
  isIdentity(): boolean
  matrixExponential(): Matrix | null
  /** Check if this is symmetric */
  isSymmetric(): boolean
  /** Compute eigenvalues and eigenvectors

  Returns eigenvalues and corresponding eigenvectors for real matrices.
  For matrices with complex eigenvalues, use `complex_eigen_decomposition`.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(3)
  ]);

  let eigen = matrix.eigen_decomposition().unwrap();
  assert_eq!(eigen.eigenvalues.len(), 2);
  assert_eq!(eigen.eigenvalues[0], Expression::integer(2));
  assert_eq!(eigen.eigenvalues[1], Expression::integer(3));
  ``` */
  eigenDecomposition(): EigenDecomposition | null
  eigenDecompositionAll(): EigenDecomposition | null
  /** Create a permutation matrix
  Memory efficient: O(n) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let perm = Matrix::permutation(vec![2, 0, 1]);
  ``` */
  static permutation(permutation: Array<number>): Matrix
  /** Scalar multiplication */
  scalarMultiply(scalar: Expression): Matrix
  /** Check if a value is small (simplified convergence test) */
  isSmallValue(value: Expression, tolerance: Expression): boolean
  /** Check if matrix is positive definite using Cholesky test

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  assert!(identity.is_positive_definite_cholesky());

  let scalar = Matrix::scalar(2, Expression::integer(5));
  assert!(scalar.is_positive_definite_cholesky());
  ``` */
  isPositiveDefiniteCholesky(): boolean
  determinantViaEigenvalues(): Expression
  add(other: Matrix): Matrix
  matrixLogarithm(): Matrix | null
  /** Compute matrix power using eigendecomposition (A^n = P D^n P^(-1))

  This method is particularly efficient for diagonal and diagonalizable matrices.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(3)
  ]);

  let power = matrix.matrix_power_eigen(3).unwrap();
  let eigenvals = power.eigenvalues();
  assert_eq!(eigenvals[0], Expression::integer(8)); // 2^3
  assert_eq!(eigenvals[1], Expression::integer(27)); // 3^3
  ``` */
  matrixPowerEigen(n: number): Matrix | null
  matrixPowerEigenWithN(n: number): Matrix | null
  /** Get matrix dimensions efficiently

  This method provides O(1) dimension lookup for all matrix types. */
  dimensions(): [number, number]
  /** Compute matrix power for special cases

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  let power = identity.matrix_power_special(5).unwrap();
  assert!(matches!(power, Matrix::Identity(_)));

  let scalar = Matrix::scalar(2, Expression::integer(3));
  let power = scalar.matrix_power_special(2).unwrap();
  // (3I)² = 9I
  ``` */
  matrixPowerSpecial(n: number): Matrix | null
  /** Create a scalar matrix (c*I)
  Memory efficient: O(1) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let scalar = Matrix::scalar(3, Expression::integer(5));
  ``` */
  static scalar(size: number, scalarValue: Expression): Matrix
  /** Create a diagonal matrix from diagonal elements
  Memory efficient: O(n) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let diag = Matrix::diagonal(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  assert_eq!(diag.dimensions(), (3, 3));
  assert!(diag.is_diagonal());
  ``` */
  static diagonal(diagonalElements: Array<Expression>): Matrix
  /** Create an upper triangular matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let upper = Matrix::upper_triangular(3, vec![
  Expression::integer(1), Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5),
  Expression::integer(6)
  ]);
  ``` */
  static upperTriangular(size: number, elements: Array<Expression>): Matrix
  transpose(): Matrix
  isPositiveDefinite(): boolean
  /** Get condition number using SVD

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(2);
  let cond = identity.condition_number_via_svd();
  assert_eq!(cond, Expression::integer(1));
  ``` */
  conditionNumberViaSvd(): Expression
  /** Perform QR decomposition using Gram-Schmidt process

  Decomposes matrix A into A = QR where:
  - Q is orthogonal (Q^T * Q = I)
  - R is upper triangular

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [1, 1],
  [0, 1]
  ]);

  let qr = matrix.qr_decomposition().unwrap();
  let (q_rows, q_cols) = qr.q.dimensions();
  assert_eq!(q_rows, 2);
  assert_eq!(q_cols, 2);
  ``` */
  qrDecomposition(): JsQRDecomposition | null
  qrDecompositionAll(): JsQRDecomposition | null
  rank(): number
  /** Create a lower triangular matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let lower = Matrix::lower_triangular(3, vec![
  Expression::integer(1),
  Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5), Expression::integer(6)
  ]);
  ``` */
  static lowerTriangular(size: number, elements: Array<Expression>): Matrix
  /** Get matrix rank using SVD

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  assert_eq!(identity.rank_via_svd(), 3);

  let zero = Matrix::zero(3, 3);
  assert_eq!(zero.rank_via_svd(), 0);
  ``` */
  rankViaSvd(): number
  /** Check if matrix is diagonalizable

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let diagonal = Matrix::diagonal(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  assert!(diagonal.is_diagonalizable());

  let identity = Matrix::identity(3);
  assert!(identity.is_diagonalizable());
  ``` */
  isDiagonalizable(): boolean
  isDiagonalizableAll(): boolean
  /** Perform LU decomposition with partial pivoting

  Decomposes matrix A into PA = LU where:
  - P is a permutation matrix
  - L is lower triangular with 1s on diagonal
  - U is upper triangular

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [2, 1],
  [4, 3]
  ]);

  let lu = matrix.lu_decomposition().unwrap();
  assert!(lu.p.is_some());
  ``` */
  luDecomposition(): LUDecomposition | null
  luDecompositionAll(): LUDecomposition | null
  /** Check if this is a square matrix */
  isSquare(): boolean
  /** Create an identity matrix of given size
  Memory efficient: O(1) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let identity = Matrix::identity(3);
  assert_eq!(identity.dimensions(), (3, 3));
  assert!(identity.is_identity());
  ``` */
  static identity(size: number): Matrix
  /** Perform Cholesky decomposition for positive definite matrices

  Decomposes symmetric positive definite matrix A into A = LL^T where:
  - L is lower triangular with positive diagonal elements

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::from_arrays([
  [4, 2],
  [2, 3]
  ]);

  if let Some(chol) = matrix.cholesky_decomposition() {
    let (l_rows, l_cols) = chol.l.dimensions();
    assert_eq!(l_rows, 2);
    assert_eq!(l_cols, 2);
  }
  ``` */
  choleskyDecomposition(): CholeskyDecomposition | null
  choleskyDecompositionAll(): CholeskyDecomposition | null
  multiply(other: Matrix): Matrix
  /** Convert to the most efficient representation

  This method analyzes the matrix and converts it to the most
  memory-efficient representation possible. */
  optimize(): Matrix
  characteristicPolynomial(): CharacteristicPolynomial
  /** Compute only eigenvalues (faster than full decomposition)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::scalar(3, Expression::integer(5));
  let eigenvals = matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 3);
  assert_eq!(eigenvals[0], Expression::integer(5));
  ``` */
  eigenvalues(): Array<Expression>
  eigenvaluesAll(): Array<Expression>
  /** Check if this is a diagonal matrix */
  isDiagonal(): boolean
  /** Compute the minimal polynomial (smallest degree polynomial that annihilates the matrix)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  let min_poly = matrix.minimal_polynomial();
  // For this matrix, minimal polynomial is (λ-2)(λ-3)
  assert!(!min_poly.coefficients.is_empty());
  ``` */
  minimalPolynomial(): CharacteristicPolynomial
  matrixSqrt(): Matrix | null
  /** Check if this is a zero matrix */
  isZero(): boolean
  /** Get the determinant efficiently (for square matrices)

  # Returns
  Result containing the determinant expression, or MathError for non-square matrices

  # Errors
  Returns DomainError if matrix is not square

  # Algorithm
  - Special matrices (Identity, Zero, Scalar, Diagonal): O(1) or O(n)
  - Small matrices (1x1, 2x2): Direct formulas
  - Numeric matrices: NumericMatrix fast-path with O(n³) LU decomposition
  - Larger symbolic matrices (n≥3): LU decomposition O(n³) */
  determinant(): Expression
  /** Compute matrix logarithm using eigendecomposition
  log(A) = P log(D) P^(-1) where log(D) = diag(log(d_1), log(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(2);
  let log_matrix = identity.matrix_logarithm_eigen().unwrap();
  // log(I) has eigenvalues log(1) = 0, so result is diagonal matrix with zeros
  let eigenvals = log_matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 2);
  assert_eq!(eigenvals[0], Expression::function("log", vec![Expression::integer(1)]));
  assert_eq!(eigenvals[1], Expression::function("log", vec![Expression::integer(1)]));
  ``` */
  matrixLogarithmEigen(): Matrix | null
  /** Compute complex eigenvalues and eigenvectors

  Handles matrices that may have complex eigenvalues and eigenvectors.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [0, -1],
  [1, 0]
  ]);

  // This matrix has complex eigenvalues ±i
  let complex_eigen = matrix.complex_eigen_decomposition();
  // Returns None as complex eigenvalue computation requires specialized algorithms
  assert!(complex_eigen.is_none());
  ``` */
  complexEigenDecomposition(): ComplexEigenDecomposition | null
  complexEigenDecompositionAll(): ComplexEigenDecomposition | null
  /** Try to convert this matrix to a NumericMatrix for fast numeric operations.

  Returns Some(NumericMatrix) if all elements can be converted to f64,
  None otherwise (e.g., if matrix contains symbolic expressions). */
  asNumeric(): JsNumericMatrix | null
  /** Compute matrix exponential using eigendecomposition
  exp(A) = P exp(D) P^(-1) where exp(D) = diag(exp(d_1), exp(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::zero(2, 2);
  let exp_matrix = matrix.matrix_exponential_eigen().unwrap();
  // exp(0) = 1, so result is diagonal(exp(0), exp(0))
  let eigenvals = exp_matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 2);
  // Eigenvalues are exp(0) in symbolic form
  assert_eq!(eigenvals[0], Expression::function("exp", vec![Expression::integer(0)]));
  ``` */
  matrixExponentialEigen(): Matrix | null
  /** Get the trace (sum of diagonal elements) efficiently */
  trace(): Expression
  traceAll(): Expression
  /** Get element at position (i, j) efficiently

  This method provides optimized element access for each matrix type. */
  getElement(i: number, j: number): Expression
  /** Create a zero matrix of given dimensions
  Memory efficient: O(1) storage vs O(n*m) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let zero = Matrix::zero(2, 3);
  assert_eq!(zero.dimensions(), (2, 3));
  assert!(zero.is_zero());
  ``` */
  static zero(rows: number, cols: number): Matrix
  /** Power iteration method for finding dominant eigenvalue
  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::{Expression, expr};

  let matrix = Matrix::diagonal(vec![expr!(2), expr!(3)]);
  let eigen = matrix.power_iteration_eigenvalues().unwrap();
  // Power iteration returns the dominant (largest) eigenvalue
  // For symbolic computation, the result may be a complex expression
  assert_eq!(eigen.eigenvalues.len(), 1);
  // The eigenvalue exists but may not simplify to integer form symbolically
  assert!(!eigen.eigenvalues[0].is_zero());
  ``` */
  powerIterationEigenvalues(): EigenDecomposition | null
  /** Create a symmetric matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let symmetric = Matrix::symmetric(3, vec![
  Expression::integer(1), Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5),
  Expression::integer(6)
  ]);
  ``` */
  static symmetric(size: number, elements: Array<Expression>): Matrix
  inverse(): Matrix
  equals(other: Matrix): boolean
  cloneValue(): Matrix
}
export type JsMatrix = Matrix

export declare class MatrixEquationSolver {
  constructor()
  solve(equation: Expression, variable: symbol): JsSolverResult
  /** Create solver without step-by-step explanations (for performance)

  # Examples

  ```rust,ignore
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new_fast();
  ``` */
  static newFast(): MatrixEquationSolver
  solveWithExplanation(equation: Expression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Solve right division: X*A = B → X = B*A^(-1)

  # Arguments

   * `A` - The right coefficient matrix/operator
   * `B` - The right-hand side

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new();
  let A = symbol!(A; matrix);
  let B = symbol!(B; matrix);

  let solution = solver.solve_right_division(&A, &B);
  // solution should be B*A^(-1)
  ``` */
  solveRightDivision(a: Expression, b: Expression): Expression
  /** Solve left division: A*X = B → X = A^(-1)*B

  # Arguments

   * `A` - The left coefficient matrix/operator
   * `B` - The right-hand side

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new();
  let A = symbol!(A; matrix);
  let B = symbol!(B; matrix);

  let solution = solver.solve_left_division(&A, &B);
  // solution should be A^(-1)*B
  ``` */
  solveLeftDivision(a: Expression, b: Expression): Expression
  canSolve(equation: Expression): boolean
  cloneValue(): MatrixEquationSolver
}
export type JsMatrixEquationSolver = MatrixEquationSolver

export declare class MessageCategory {
  equals(other: MessageCategory): boolean
  cloneValue(): MessageCategory
}
export type JsMessageCategory = MessageCategory

export declare class MessageHashSystem {
  /** Validate message registry integrity */
  static validateRegistry(): boolean
  /** Get message hash for efficient lookup */
  static hashMessageKey(category: MessageCategory, messageType: JsMessageType, variant: number): number
  /** Get message by hash (for performance-critical paths) */
  static getMessageByHash(hash: number): JsMessageTemplate | null
}
export type JsMessageHashSystem = MessageHashSystem

export declare class MessageOptimizer {
  /** Pre-compute common message combinations for performance */
  static precomputeCommonMessages(): Record<string, Array<JsStep>>
  /** Get cached message or generate new one */
  static getOptimizedMessage(scenario: string): Array<JsStep> | null
}
export type JsMessageOptimizer = MessageOptimizer

export declare class MessageTemplate {
  cloneValue(): MessageTemplate
}
export type JsMessageTemplate = MessageTemplate

export declare class MessageType {
  equals(other: MessageType): boolean
  cloneValue(): MessageType
}
export type JsMessageType = MessageType

export declare class NaturalLogSimplificationStrategy {
  name(): string
}
export type JsNaturalLogSimplificationStrategy = NaturalLogSimplificationStrategy

export declare class NewtonRaphson {
  /** Create a new Newton-Raphson method with initial guess

  # Arguments

   * `initial_guess` - Starting point for iteration

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::NewtonRaphson;

  let method = NewtonRaphson::new(1.5);
  ``` */
  constructor(initialGuess: number)
}
export type JsNewtonRaphson = NewtonRaphson

export declare class NumberTheoryIntelligence {
  constructor()
  /** Get all number theory function properties */
  getAllProperties(): Record<string, FunctionProperties>
  /** Check if function has number theory intelligence */
  hasIntelligence(name: string): boolean
}
export type JsNumberTheoryIntelligence = NumberTheoryIntelligence

export declare class NumericMatrix {
  isSquare(): boolean
  static tryFromMatrix(matrix: Matrix): NumericMatrix | null
  inverse(): NumericMatrix
  add(other: NumericMatrix): NumericMatrix
  static canConvert(expr: Expression): boolean
  toMatrix(): Matrix
  scalarMul(scalar: number): NumericMatrix
  determinant(): number
  static zeros(rows: number, cols: number): NumericMatrix
  sub(other: NumericMatrix): NumericMatrix
  dimensions(): [number, number]
  isSymmetric(): boolean
  static canConvertMatrix(matrix: Matrix): boolean
  static fromFlat(rows: number, cols: number, data: Array<number>): NumericMatrix
  transpose(): NumericMatrix
  get(row: number, col: number): number
  multiply(other: NumericMatrix): NumericMatrix
  toExpression(): Expression
  static identity(n: number): NumericMatrix
  negate(): NumericMatrix
  static tryFromExpression(expr: Expression): NumericMatrix | null
  set(row: number, col: number, value: number): void
  equals(other: NumericMatrix): boolean
  cloneValue(): NumericMatrix
}
export type JsNumericMatrix = NumericMatrix

export declare class ODEClassifier {
  /** Classify a second-order ODE

  # Arguments

   * `lhs` - Left-hand side expression (usually y'', y', y terms)
   * `rhs` - Right-hand side expression (forcing function)
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Examples

  ```rust
  use mathhook_core::calculus::ode::classifier::{ODEClassifier, ODEType};
  use mathhook_core::{symbol, expr, Expression};

  let x = symbol!(x);
  let y = symbol!(y);

  let ode_type = ODEClassifier::classify_second_order(
  &expr!(y + y),
  &Expression::integer(0),
  &y,
  &x
  );
  assert_eq!(ode_type, ODEType::ConstantCoefficients);
  ``` */
  static classifySecondOrder(lhs: Expression, rhs: Expression, dependent: symbol, independent: symbol): JsODEType
  /** Classify a first-order ODE

  Attempts to classify the ODE in order of computational efficiency:
  1. Separable (fastest, widest coverage)
  2. Linear first-order (integrating factor method)
  3. Exact (requires exactness condition check)
  4. Bernoulli (transforms to linear)
  5. Homogeneous (substitution method)

  # Arguments

   * `rhs` - Right-hand side of dy/dx = rhs
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Examples

  ```rust
  use mathhook_core::calculus::ode::classifier::{ODEClassifier, ODEType};
  use mathhook_core::{symbol, expr, Expression};

  let x = symbol!(x);
  let y = symbol!(y);

  let rhs = expr!(x * y);
  let ode_type = ODEClassifier::classify_first_order(&rhs, &y, &x);
  assert_eq!(ode_type, ODEType::Separable);
  ``` */
  static classifyFirstOrder(rhs: Expression, dependent: symbol, independent: symbol): JsODEType
}
export type JsODEClassifier = ODEClassifier

export declare class ODEExamples {
  /** Example: Exponential growth dy/dx = y

  # Solution

  y = C·e^x

  # Common Pitfalls

  - Forgetting absolute value in ln|y| = x + C
  - Incorrect handling of integration constant when exponentiating
  - Not recognizing this as both separable and linear */
  static exponentialGrowth(): JsODEExplanation
  /** Example: Linear first-order dy/dx + y = x

  # Solution

  y = x - 1 + C·e^(-x)

  # Common Pitfalls

  - Incorrectly computing integrating factor μ(x) = e^(∫P(x)dx)
  - Forgetting to multiply Q(x) by μ(x) before integrating
  - Sign errors in the exponent */
  static linearFirstOrder(): JsODEExplanation
  /** Get all example explanations */
  static allExamples(): Array<JsODEExplanation>
  /** Example: Simplest separable ODE dy/dx = x

  # Solution

  y = x²/2 + C

  # Common Pitfalls

  - Forgetting the constant of integration
  - Incorrect integration of x (getting x²/2 instead of x²/2) */
  static separableSimple(): JsODEExplanation
  /** Example: Product form dy/dx = xy

  # Solution

  y = C·e^(x²/2)

  # Common Pitfalls

  - Incorrectly integrating x to get x²/2 vs x²
  - Forgetting to include constant in exponential
  - Not simplifying e^(x²/2 + C) to C'·e^(x²/2) */
  static productSeparable(): JsODEExplanation
  /** Get list of available example names */
  static exampleNames(): Array<string>
  /** Example: Initial value problem dy/dx = x, y(0) = 1

  # Solution

  y = x²/2 + 1

  # Common Pitfalls

  - Forgetting to apply initial condition
  - Incorrectly solving for constant C
  - Not verifying that y(0) = 1 in final solution */
  static initialValueProblem(): JsODEExplanation
  /** Get example by name */
  static getExample(name: string): JsODEExplanation | null
}
export type JsODEExamples = ODEExamples

export declare class ODEExplanation {
  /** Get human-readable explanation */
  toHumanReadable(): string
  /** Get LaTeX formatted explanation */
  toLatex(): string
  /** Get steps for a specific phase */
  stepsByPhase(phase: JsODEPhase): Array<JsODESolutionStep>
  /** Create a new ODE explanation */
  constructor(solution: Expression, steps: Array<JsODESolutionStep>, odeType: string, methodSummary: string)
  cloneValue(): ODEExplanation
}
export type JsODEExplanation = ODEExplanation

export declare class ODEPhase {
  equals(other: ODEPhase): boolean
  cloneValue(): ODEPhase
}
export type JsODEPhase = ODEPhase

export declare class ODESolution {
  equals(other: ODESolution): boolean
  cloneValue(): ODESolution
}
export type JsODESolution = ODESolution

export declare class ODESolutionStep {
  /** Get LaTeX representation with custom formatting */
  toLatexDetailed(): string
  /** Add metadata to the step */
  withMetadata(key: string, value: string): ODESolutionStep
  /** Create a new ODE solution step */
  constructor(stepId: string, phase: ODEPhase, title: string, description: string, justification: string, before: Expression, after: Expression)
  cloneValue(): ODESolutionStep
}
export type JsODESolutionStep = ODESolutionStep

export declare class ODESolver {
  constructor()
  /** Create an ODE solver with custom configuration */
  static withConfig(config: JsSolverConfig): ODESolver
  /** Get current solver configuration */
  config(): JsSolverConfig
}
export type JsODESolver = ODESolver

export declare class ODESolverRegistry {
  constructor()
}
export type JsODESolverRegistry = ODESolverRegistry

export declare class ODEStepFactory {
  /** Create solution construction step */
  static solutionConstruction(implicit: Expression, explicit: Expression, method: string): ODESolutionStep
  /** Create verification step */
  static verification(solution: Expression, originalOde: Expression, verificationResult: boolean): ODESolutionStep
  /** Create detection step */
  static detection(odeType: string, equation: Expression, reason: string): ODESolutionStep
  /** Create separation step for separable ODEs */
  static separation(original: Expression, separated: Expression, gX: string, hY: string): ODESolutionStep
  /** Create integration step */
  static integration(integrand: Expression, result: Expression, variable: symbol, side: string): ODESolutionStep
}
export type JsODEStepFactory = ODEStepFactory

export declare class ODEType {
  toString(): string
  equals(other: ODEType): boolean
  cloneValue(): ODEType
}
export type JsODEType = ODEType

export declare class OperationContext {
  /** Create context for equation solving */
  static equationSolving(difficultyLevel: number): OperationContext
  /** Create context for simplification */
  static simplification(difficultyLevel: number): OperationContext
  /** Create context for differentiation */
  static differentiation(difficultyLevel: number): OperationContext
  equals(other: OperationContext): boolean
  cloneValue(): OperationContext
}
export type JsOperationContext = OperationContext

export declare class ParallelStatistics {
  constructor()
  cloneValue(): ParallelStatistics
}
export type JsParallelStatistics = ParallelStatistics

export declare class ParseError {
  equals(other: ParseError): boolean
  cloneValue(): ParseError
}
export type JsParseError = ParseError

export declare class Parser {
  /** Create parser with implicit multiplication enabled */
  constructor(config: JsParserConfig)
  /** Parse mathematical expression with full integration

  # Examples

  ```rust
  use mathhook_core::parser::Parser;
  use mathhook_core::parser::config::ParserConfig;

  let parser = Parser::new(&ParserConfig::default());

  // These will work with implicit multiplication:
  let expr = parser.parse("2x").unwrap();           // -> 2 * x
  let expr = parser.parse("xy").unwrap();           // -> x * y
  let expr = parser.parse("2(x+1)").unwrap();       // -> 2 * (x + 1)

  // These work normally:
  let expr = parser.parse("x + y").unwrap();        // -> x + y
  let expr = parser.parse("x^2").unwrap();          // -> x^2
  ``` */
  parse(input: string): Expression
}
export type JsParser = Parser

export declare class ParserConfig {
  constructor()
}
export type JsParserConfig = ParserConfig

export declare class PartialFractionDecomposition {
  cloneValue(): PartialFractionDecomposition
}
export type JsPartialFractionDecomposition = PartialFractionDecomposition

export declare class PatternKey {
  equals(other: PatternKey): boolean
  cloneValue(): PatternKey
}
export type JsPatternKey = PatternKey

export declare class Pde {
  /** Create a new PDE

  # Arguments

   * `equation` - The PDE expression (should equal zero)
   * `dependent_var` - The dependent variable
   * `independent_vars` - The independent variables

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::Pde;
  use mathhook_core::{symbol, expr};

  let u = symbol!(u);
  let x = symbol!(x);
  let t = symbol!(t);
  let equation = expr!(u + x + t);
  let pde = Pde::new(equation, u, vec![x, t]);
  ``` */
  constructor(equation: Expression, dependentVar: symbol, independentVars: Array<symbol>)
  /** Determine the linearity classification */
  linearity(): JsPdeLinearity
  /** Determine the order of the PDE */
  order(): JsPdeOrder
  equals(other: Pde): boolean
  cloneValue(): Pde
}
export type JsPde = Pde

export declare class PdeCoefficients {
  equals(other: PdeCoefficients): boolean
  cloneValue(): PdeCoefficients
}
export type JsPdeCoefficients = PdeCoefficients

export declare class PdeLinearity {
  equals(other: PdeLinearity): boolean
  cloneValue(): PdeLinearity
}
export type JsPdeLinearity = PdeLinearity

export declare class PdeMessageKey {
  equals(other: PdeMessageKey): boolean
  cloneValue(): PdeMessageKey
}
export type JsPdeMessageKey = PdeMessageKey

export declare class PdeMessageVariant {

}
export type JsPdeMessageVariant = PdeMessageVariant

export declare class PdeOrder {
  equals(other: PdeOrder): boolean
  cloneValue(): PdeOrder
}
export type JsPdeOrder = PdeOrder

export declare class PDESolution {
  /** Creates a Laplace equation solution

  # Arguments

   * `solution` - The general solution expression
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static laplace(solution: Expression, eigenvalues: Array<Expression>, coefficients: Array<Expression>): PDESolution
  /** Creates a heat equation solution

  # Arguments

   * `solution` - The general solution expression
   * `alpha` - Thermal diffusivity coefficient
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static heat(solution: Expression, alpha: Expression, eigenvalues: Array<Expression>, coefficients: Array<Expression>): PDESolution
  /** Creates a wave equation solution

  # Arguments

   * `solution` - The general solution expression
   * `c` - Wave speed
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static wave(solution: Expression, c: Expression, eigenvalues: Array<Expression>, coefficients: Array<Expression>): PDESolution
  /** Creates a general PDE solution with no specific metadata

  # Arguments

   * `solution` - The general solution expression */
  static general(solution: Expression): PDESolution
  equals(other: PDESolution): boolean
  cloneValue(): PDESolution
}
export type JsPDESolution = PDESolution

export declare class PDESolverRegistry {
  constructor()
  /** Get all registered solver types */
  registeredTypes(): Array<JsPdeType>
  /** Get solver count */
  solverCount(): number
}
export type JsPDESolverRegistry = PDESolverRegistry

export declare class PdeType {
  equals(other: PdeType): boolean
  cloneValue(): PdeType
}
export type JsPdeType = PdeType

export declare class PerformanceConfig {
  constructor()
  /** Configuration for high-performance native usage */
  static nativeOptimized(): PerformanceConfig
  /** Configuration optimized for Node.js bindings */
  static nodejsOptimized(): PerformanceConfig
  /** Configuration for WebAssembly bindings (memory-constrained) */
  static wasmOptimized(): PerformanceConfig
  /** Configuration optimized for Python bindings (GIL-aware) */
  static pythonOptimized(): PerformanceConfig
  /** Factory method to create configuration based on binding context */
  static forBinding(context: BindingContext): PerformanceConfig
  cloneValue(): PerformanceConfig
}
export type JsPerformanceConfig = PerformanceConfig

export declare class PerformanceMeasurement {
  cloneValue(): PerformanceMeasurement
}
export type JsPerformanceMeasurement = PerformanceMeasurement

export declare class PerformanceMetrics {
  cloneValue(): PerformanceMetrics
}
export type JsPerformanceMetrics = PerformanceMetrics

export declare class PerformanceOptimizer {
  /** Determine if parallel processing should be used */
  shouldUseParallel(operationSize: number): boolean
  /** Check cache for memoized result */
  getCachedSimplify(exprHash: number): Expression | null
  constructor(config: PerformanceConfig)
  /** Cache a simplification result */
  cacheSimplify(exprHash: number, result: Expression): void
  /** Get cache statistics for monitoring */
  cacheStats(): CacheStats
  /** Determine if SIMD should be used for bulk operations */
  shouldUseSimd(operationSize: number): boolean
}
export type JsPerformanceOptimizer = PerformanceOptimizer

export declare class PersistentCache {
  /** Force save cache to disk */
  forceSave(): void
  /** Store a result in the cache */
  put(expressionHash: number, simplified: Expression): void
  /** Save cache to disk */
  saveToDisk(): void
  /** Get a cached result */
  get(expressionHash: number): Expression | null
  /** Clear all cache entries */
  clear(): void
}
export type JsPersistentCache = PersistentCache

export declare class PersistentCacheConfig {
  constructor()
  cloneValue(): PersistentCacheConfig
}
export type JsPersistentCacheConfig = PersistentCacheConfig

export declare class PersistentCacheEntry {
  cloneValue(): PersistentCacheEntry
}
export type JsPersistentCacheEntry = PersistentCacheEntry

export declare class PersistentCacheStatistics {
  constructor()
  cloneValue(): PersistentCacheStatistics
}
export type JsPersistentCacheStatistics = PersistentCacheStatistics

export declare class PolynomialArithmetic {
  /** Polynomial addition */
  static addPolynomials(poly1: Expression, poly2: Expression): Expression
  /** Polynomial evaluation using Horner's method */
  static evaluatePolynomial(poly: Expression, var: symbol, value: Expression): Expression
  /** Polynomial multiplication using convolution */
  static multiplyPolynomials(poly1: Expression, poly2: Expression): Expression
  /** Polynomial composition f(g(x)) */
  static composePolynomials(f: Expression, g: Expression, var: symbol): Expression
}
export type JsPolynomialArithmetic = PolynomialArithmetic

export declare class PolynomialFamily {
  equals(other: PolynomialFamily): boolean
  cloneValue(): PolynomialFamily
}
export type JsPolynomialFamily = PolynomialFamily

export declare class PolynomialIntelligence {
  constructor()
  /** Check if function is a polynomial */
  isPolynomialFunction(name: string): boolean
  /** Get all polynomial function properties

  Returns a HashMap of all polynomial functions and their properties
  for integration with the universal registry. */
  getAllProperties(): Record<string, FunctionProperties>
}
export type JsPolynomialIntelligence = PolynomialIntelligence

export declare class PolynomialProperties {
  cloneValue(): PolynomialProperties
}
export type JsPolynomialProperties = PolynomialProperties

export declare class ProfilerStatistics {
  cloneValue(): ProfilerStatistics
}
export type JsProfilerStatistics = ProfilerStatistics

export declare class QRDecomposition {
  equals(other: QRDecomposition): boolean
  cloneValue(): QRDecomposition
}
export type JsQRDecomposition = QRDecomposition

export declare class QuadraticSolver {
  constructor()
  canSolve(equation: Expression): boolean
  solve(equation: Expression, variable: symbol): JsSolverResult
  solveWithExplanation(equation: Expression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  cloneValue(): QuadraticSolver
}
export type JsQuadraticSolver = QuadraticSolver

export declare class QuadraticTerm {
  cloneValue(): QuadraticTerm
}
export type JsQuadraticTerm = QuadraticTerm

export declare class Range {
  cloneValue(): Range
}
export type JsRange = Range

export declare class RationalIntegral {
  equals(other: RationalIntegral): boolean
  cloneValue(): RationalIntegral
}
export type JsRationalIntegral = RationalIntegral

export declare class RecurrenceRule {
  cloneValue(): RecurrenceRule
}
export type JsRecurrenceRule = RecurrenceRule

export declare class Reference {
  cloneValue(): Reference
}
export type JsReference = Reference

export declare class RelationType {
  equals(other: RelationType): boolean
  cloneValue(): RelationType
}
export type JsRelationType = RelationType

export declare class ResidueMethods {
  /** Compute residue for pole of order m using derivative formula

  # Arguments

   * `numerator` - Numerator of the rational function
   * `denominator` - Denominator of the rational function
   * `variable` - The variable symbol
   * `pole` - Location of the pole
   * `order` - Order of the pole

  # Returns

  Expression representing the residue */
  static higherOrderPoleResidue(numerator: Expression, denominator: Expression, variable: symbol, pole: Expression, order: number): Expression
  /** Compute factorial

  # Arguments

   * `n` - The number to compute factorial of

  # Returns

  Expression representing n! */
  static factorial(n: number): Expression
  /** Compute residue for simple pole using limit formula

  # Arguments

   * `numerator` - Numerator of the rational function
   * `denominator` - Denominator of the rational function
   * `variable` - The variable symbol
   * `pole` - Location of the pole

  # Returns

  Expression representing the residue computation */
  static simplePoleResidue(numerator: Expression, denominator: Expression, variable: symbol, pole: Expression): Expression
}
export type JsResidueMethods = ResidueMethods

export declare class RischResult {
  equals(other: RischResult): boolean
  cloneValue(): RischResult
}
export type JsRischResult = RischResult

export declare class RodriguesFormula {
  cloneValue(): RodriguesFormula
}
export type JsRodriguesFormula = RodriguesFormula

export declare class RombergIntegration {
  /** Create a new Romberg integrator

  # Arguments

   * `max_order` - Maximum order of extrapolation (typically 5-10)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::numerical::RombergIntegration;

  let integrator = RombergIntegration::new(8);
  ``` */
  constructor(maxOrder: number)
}
export type JsRombergIntegration = RombergIntegration

export declare class RootFindingConfig {
  constructor()
  cloneValue(): RootFindingConfig
}
export type JsRootFindingConfig = RootFindingConfig

export declare class RootType {
  equals(other: RootType): boolean
  cloneValue(): RootType
}
export type JsRootType = RootType

export declare class RuntimeProfiler {
  constructor()
  /** Record a performance measurement */
  recordMeasurement(measurement: PerformanceMeasurement): void
  /** Get current adaptive thresholds */
  getThresholds(): AdaptiveThresholds
  /** Get performance statistics for monitoring */
  getStatistics(): ProfilerStatistics
}
export type JsRuntimeProfiler = RuntimeProfiler

export declare class SecantMethod {
  /** Create a new secant method with two initial guesses

  # Arguments

   * `x0` - First initial guess
   * `x1` - Second initial guess (should be close to but different from x0)

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::SecantMethod;

  let method = SecantMethod::new(1.0, 2.0);
  ``` */
  constructor(x0: number, x1: number)
}
export type JsSecantMethod = SecantMethod

export declare class SeparableODESolver {
  constructor()
  /** Check if ODE is separable

  An ODE dy/dx = f(x,y) is separable if it can be written as g(x)*h(y)

  # Examples

  ```rust
  use mathhook_core::{symbol, expr};
  use mathhook_core::calculus::ode::first_order::separable::SeparableODESolver;

  let x = symbol!(x);
  let y = symbol!(y);
  let solver = SeparableODESolver::new();

  // Separable: x*y
  assert!(solver.is_separable(&expr!(x * y), &y, &x));

  // Not separable: x + y
  assert!(!solver.is_separable(&expr!(x + y), &y, &x));
  ```

  # Example: Common Separable Forms

  ```rust
  use mathhook_core::{symbol, expr};
  use mathhook_core::calculus::ode::first_order::separable::SeparableODESolver;

  let x = symbol!(x);
  let y = symbol!(y);
  let solver = SeparableODESolver::new();

  // Separable examples
  assert!(solver.is_separable(&expr!(x), &y, &x));      // dy/dx = x
  assert!(solver.is_separable(&expr!(y), &y, &x));      // dy/dx = y
  assert!(solver.is_separable(&expr!(x * y), &y, &x));  // dy/dx = xy

  // Non-separable examples
  assert!(!solver.is_separable(&expr!(x + y), &y, &x)); // dy/dx = x + y
  ``` */
  isSeparable(rhs: Expression, dependent: symbol, independent: symbol): boolean
}
export type JsSeparableODESolver = SeparableODESolver

export declare class SeparatedSolution {
  equals(other: SeparatedSolution): boolean
  cloneValue(): SeparatedSolution
}
export type JsSeparatedSolution = SeparatedSolution

export declare class SerializationError {
  cloneValue(): SerializationError
}
export type JsSerializationError = SerializationError

export declare class SeriesMethods {
  /** Compute binomial coefficient */
  static binomialCoefficient(n: number, k: number): Expression
  /** Compute general Taylor series using derivatives

  Taylor series: f(x) = Σ [f^(n)(a) / n!] * (x-a)^n

  For noncommutative expressions, order is preserved:
  - Derivative f^(n)(a) comes first
  - Power (x-a)^n comes second
  - Division by n! comes last */
  static generalTaylorSeries(expr: Expression, variable: symbol, point: Expression, order: number): Expression
  /** Get known series expansion for common functions */
  static knownSeries(functionName: string, variable: symbol, point: Expression, order: number): Expression | null
  /** Evaluate expression at a specific point */
  static evaluateAtPoint(expr: Expression, variable: symbol, point: Expression): Expression
  /** Compute factorial */
  static factorial(n: number): Expression
}
export type JsSeriesMethods = SeriesMethods

export declare class SeriesType {
  equals(other: SeriesType): boolean
  cloneValue(): SeriesType
}
export type JsSeriesType = SeriesType

export declare class SimdOptimized {

}
export type JsSimdOptimized = SimdOptimized

export declare class SimdStatistics {
  constructor()
  cloneValue(): SimdStatistics
}
export type JsSimdStatistics = SimdStatistics

export declare class SimpleContext {
  constructor()
  cloneValue(): SimpleContext
}
export type JsSimpleContext = SimpleContext

export declare class SimplificationRegistry {
  constructor()
  /** Get count of registered strategies (for debugging) */
  strategyCount(): number
  /** List all registered function names (for debugging) */
  listFunctions(): Array<string>
  /** Check if function has simplification strategy registered */
  hasStrategy(name: string): boolean
}
export type JsSimplificationRegistry = SimplificationRegistry

export declare class SinSimplificationStrategy {
  name(): string
}
export type JsSinSimplificationStrategy = SinSimplificationStrategy

export declare class SmartDisplayFormatter {
  /** Check if an expression is in division form

  High-level utility to detect if multiplication represents division */
  static isDivisionExpression(expr: Expression): boolean
  /** Check if an expression is in negated form

  This is a high-level utility that checks if an expression
  represents a negated value using the canonical Neg trait pattern. */
  static isNegatedExpression(expr: Expression): boolean
  /** Extract the positive form of a negated expression

  If the expression is negated (-1 * expr), returns the positive part.
  Otherwise returns None. */
  static extractNegatedExpression(expr: Expression): Expression | null
}
export type JsSmartDisplayFormatter = SmartDisplayFormatter

export declare class SmartEquationSolver {
  constructor()
  /** Legacy solve method (deprecated, use solve_with_equation instead) */
  solve(): [JsSolverResult, JsStepByStepExplanation]
  /** Solve equation with educational explanation, including equation analysis

  This is the primary entry point for solving equations with full educational
  integration. It automatically:
  1. Analyzes the equation type
  2. Explains the equation structure
  3. Selects the appropriate solver
  4. Provides step-by-step solution with explanations

  # Arguments

   * `equation` - The equation expression to solve
   * `variable` - The variable to solve for

  # Returns

  A tuple containing:
  - The solver result (solutions or error)
  - Complete step-by-step explanation starting with equation analysis */
  solveWithEquation(equation: Expression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
}
export type JsSmartEquationSolver = SmartEquationSolver

export declare class SolutionMetadata {
  equals(other: SolutionMetadata): boolean
  cloneValue(): SolutionMetadata
}
export type JsSolutionMetadata = SolutionMetadata

export declare class SolverConfig {
  constructor()
  equals(other: SolverConfig): boolean
  cloneValue(): SolverConfig
}
export type JsSolverConfig = SolverConfig

export declare class SolverError {
  equals(other: SolverError): boolean
  cloneValue(): SolverError
}
export type JsSolverError = SolverError

export declare class SolverResult {
  /** Check if result represents a valid solution */
  isValidSolution(): boolean
  /** Get number of solutions */
  solutionCount(): number | null
  equals(other: SolverResult): boolean
  cloneValue(): SolverResult
}
export type JsSolverResult = SolverResult

export declare class SpecialIntelligence {
  constructor()
  /** Get all properties for registration

  Returns a vector of (function_name, properties) pairs for all special
  functions. Used by UniversalFunctionRegistry for automatic registration. */
  getAllProperties(): Array<[string, FunctionProperties]>
}
export type JsSpecialIntelligence = SpecialIntelligence

export declare class SpecialProperties {
  cloneValue(): SpecialProperties
}
export type JsSpecialProperties = SpecialProperties

export declare class SpecialStepGenerator {

}
export type JsSpecialStepGenerator = SpecialStepGenerator

export declare class SpecialValue {
  cloneValue(): SpecialValue
}
export type JsSpecialValue = SpecialValue

export declare class SqrtIntelligence {
  constructor()
  /** Check if function is square root

  # Arguments

   * `name` - The function name to check

  # Examples

  ```
  use mathhook_core::functions::elementary::sqrt::SqrtIntelligence;

  let intelligence = SqrtIntelligence::new();
  assert!(intelligence.has_function("sqrt"));
  assert!(!intelligence.has_function("sin"));
  ``` */
  hasFunction(name: string): boolean
  /** Get square root function properties

  # Examples

  ```
  use mathhook_core::functions::elementary::sqrt::SqrtIntelligence;

  let intelligence = SqrtIntelligence::new();
  let props = intelligence.get_properties();
  assert!(props.contains_key("sqrt"));
  ``` */
  getProperties(): Record<string, FunctionProperties>
}
export type JsSqrtIntelligence = SqrtIntelligence

export declare class SqrtSimplificationStrategy {
  name(): string
}
export type JsSqrtSimplificationStrategy = SqrtSimplificationStrategy

export declare class StableCache {
  /** Get cache statistics without locks */
  static stats(): [number, number, number]
  /** Get cached result without locks */
  static get(hash: number): Expression | null
  /** Store result in cache without locks */
  static store(hash: number, result: Expression): void
}
export type JsStableCache = StableCache

export declare class StableMatrix {

}
export type JsStableMatrix = StableMatrix

export declare class StableSIMD {

}
export type JsStableSIMD = StableSIMD

export declare class Step {
  /** Create a new step from String arguments (FFI-friendly, no generics) */
  static fromStrings(title: string, description: string): Step
  equals(other: Step): boolean
  cloneValue(): Step
}
export type JsStep = Step

export declare class StepByStepExplanation {
  /** Create a new step-by-step explanation */
  constructor(steps: Array<Step>)
  equals(other: StepByStepExplanation): boolean
  cloneValue(): StepByStepExplanation
}
export type JsStepByStepExplanation = StepByStepExplanation

export declare class StrategyContext {
  constructor()
  /** Get current recursion depth */
  depth(): number
  /** Check if a strategy is currently active (would cause recursion) */
  isActive(strategy: IntegrationStrategy): boolean
  cloneValue(): StrategyContext
}
export type JsStrategyContext = StrategyContext

export declare class SummationMethods {
  /** Compute geometric series sum: Σ(ar^(i-1)) from i=1 to n

  # Formula
  Sum = a * (1 - r^n) / (1 - r) for r ≠ 1

  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static geometricSeries(firstTerm: Expression, commonRatio: Expression, numTerms: Expression): Expression
  /** Check convergence of infinite series

  Simplified p-series test: Σ(1/n^p) converges iff p > 1

  # Performance
  - **Time Complexity:** O(1) - pattern matching only
  - **Space Complexity:** O(1) - returns enum variant */
  static convergenceTest(expr: Expression, variable: symbol): ConvergenceResult
  /** Compute arithmetic series sum: Σ(a + (i-1)d) from i=1 to n

  # Formula
  Sum = n/2 * (2a + (n-1)d)
  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static arithmeticSeries(firstTerm: Expression, commonDifference: Expression, numTerms: Expression): Expression
  /** Compute power sum: Σ(i^k) from i=1 to n using Faulhaber's formulas

  # Formulas (SymPy Validated)
  - k=0: Σ1 = n
  - k=1: Σi = n(n+1)/2
  - k=2: Σi² = n(n+1)(2n+1)/6
  - k=3: Σi³ = [n(n+1)/2]²

  # Performance
  - **Time Complexity:** O(1) for k ∈ {0,1,2,3}, symbolic for k > 3
  - **Space Complexity:** O(1) - constant expression construction */
  static powerSum(power: Expression, upperLimit: Expression): Expression
  /** Compute infinite geometric series sum: Σ(ar^(i-1)) from i=1 to ∞

  # Formula
  Sum = a / (1 - r) for |r| < 1

  # Domain Restriction
  Convergence requires |r| < 1. For |r| ≥ 1, series diverges.

  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static infiniteGeometricSeries(firstTerm: Expression, commonRatio: Expression): Expression
}
export type JsSummationMethods = SummationMethods

export declare class SVDDecomposition {
  equals(other: SVDDecomposition): boolean
  cloneValue(): SVDDecomposition
}
export type JsSVDDecomposition = SVDDecomposition

export declare class Symbol {
  /** Create a new scalar symbol (default behavior, backward compatible)

   **Note**: Prefer using `symbol!(x)` macro in application code.
  This method is kept for backward compatibility and internal use.

  # Examples

  ```rust
  use mathhook_core::symbol;

  let x = symbol!(x);
  let alpha = symbol!(alpha);
  ``` */
  constructor(name: string)
  /** Create a scalar symbol (commutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  assert_eq!(x.commutativity(), Commutativity::Commutative);
  ``` */
  static scalar(name: string): symbol
  /** Create a matrix symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let A = Symbol::matrix("A");
  assert_eq!(A.commutativity(), Commutativity::Noncommutative);
  ``` */
  static matrix(name: string): symbol
  /** Create a quaternion symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let i = Symbol::quaternion("i");
  assert_eq!(i.commutativity(), Commutativity::Noncommutative);
  ``` */
  static quaternion(name: string): symbol
  /** Create an operator symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let p = Symbol::operator("p");
  assert_eq!(p.commutativity(), Commutativity::Noncommutative);
  ``` */
  static operator(name: string): symbol
  /** Get commutativity of this symbol

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  assert_eq!(x.commutativity(), Commutativity::Commutative);

  let A = Symbol::matrix("A");
  assert_eq!(A.commutativity(), Commutativity::Noncommutative);
  ``` */
  commutativity(): Commutativity
  /** Get the type of this symbol

  # Examples

  ```
  use mathhook_core::core::symbol::{Symbol, SymbolType};

  let x = Symbol::scalar("x");
  assert_eq!(x.symbol_type(), SymbolType::Scalar);

  let A = Symbol::matrix("A");
  assert_eq!(A.symbol_type(), SymbolType::Matrix);
  ``` */
  symbolType(): JsSymbolType
  /** Get the symbol name

  # Examples

  ```rust
  use mathhook_core::symbol;

  let x = symbol!(x);
  assert_eq!(x.name(), "x");
  ``` */
  name(): string
  equals(other: symbol): boolean
  cloneValue(): symbol
}
export type JsSymbol = Symbol

export declare class SymbolicExpander {
  cloneValue(): SymbolicExpander
}
export type JsSymbolicExpander = SymbolicExpander

export declare class SymbolType {
  constructor()
  equals(other: SymbolType): boolean
  cloneValue(): SymbolType
}
export type JsSymbolType = SymbolType

export declare class SystemSolver {
  constructor()
  solve(equation: Expression, variable: symbol): SolverResult
  solveWithExplanation(equation: Expression, variable: symbol): [SolverResult, StepByStepExplanation]
  canSolve(equation: Expression): boolean
  cloneValue(): SystemSolver
}
export type JsSystemSolver = SystemSolver

export declare class TanSimplificationStrategy {
  name(): string
}
export type JsTanSimplificationStrategy = TanSimplificationStrategy

export declare class ThreeTermRecurrence {
  cloneValue(): ThreeTermRecurrence
}
export type JsThreeTermRecurrence = ThreeTermRecurrence

export declare class TokenCategory {
  equals(other: TokenCategory): boolean
  cloneValue(): TokenCategory
}
export type JsTokenCategory = TokenCategory

export declare class TrigonometricIntelligence {
  constructor()
  /** Check if function is trigonometric */
  hasFunction(name: string): boolean
  /** Get all trigonometric function properties */
  getProperties(): Record<string, FunctionProperties>
}
export type JsTrigonometricIntelligence = TrigonometricIntelligence

export declare class UniversalFunctionRegistry {
  constructor()
  /** Get function properties */
  getProperties(name: string): FunctionProperties | null
  /** Debug: List all registered functions */
  listAllFunctions(): Array<string>
  /** Debug: Get registry size */
  registrySize(): number
  /** Check if function has mathematical intelligence */
  hasIntelligence(name: string): boolean
}
export type JsUniversalFunctionRegistry = UniversalFunctionRegistry

export declare class UserProperties {
  cloneValue(): UserProperties
}
export type JsUserProperties = UserProperties

export declare class UserProperty {
  cloneValue(): UserProperty
}
export type JsUserProperty = UserProperty

export declare class ValidationIssue {
  cloneValue(): ValidationIssue
}
export type JsValidationIssue = ValidationIssue

export declare class ValidationLevel {
  equals(other: ValidationLevel): boolean
  cloneValue(): ValidationLevel
}
export type JsValidationLevel = ValidationLevel

export declare class ValidationMetrics {
  cloneValue(): ValidationMetrics
}
export type JsValidationMetrics = ValidationMetrics

export declare class ValidationResult {
  cloneValue(): ValidationResult
}
export type JsValidationResult = ValidationResult

export declare class VerifiedConstant {
  cloneValue(): VerifiedConstant
}
export type JsVerifiedConstant = VerifiedConstant

export declare class VerifiedRelationship {
  cloneValue(): VerifiedRelationship
}
export type JsVerifiedRelationship = VerifiedRelationship

export declare class Version {
  equals(other: Version): boolean
  cloneValue(): Version
}
export type JsVersion = Version

export declare class WaveEquationSolver {
  constructor()
  name(): string
  priority(): number
  canSolve(pdeType: PdeType): boolean
  description(): string
  static withMaxTerms(maxTerms: number): WaveEquationSolver
}
export type JsWaveEquationSolver = WaveEquationSolver

export declare class WaveSolution {
  equals(other: WaveSolution): boolean
  cloneValue(): WaveSolution
}
export type JsWaveSolution = WaveSolution

export declare class WolframContext {
  constructor()
  cloneValue(): WolframContext
}
export type JsWolframContext = WolframContext

export declare function abs(x: ExpressionOrNumber): Expression

export declare function acos(x: ExpressionOrNumber): Expression

/** Get complete algorithm overview */
export declare function algorithmOverview(): string

export declare function asin(x: ExpressionOrNumber): Expression

/** Assemble a RationalIntegral into a single Expression */
export declare function assembleIntegral(integral: RationalIntegral): Expression

export declare function atan(x: ExpressionOrNumber): Expression

export declare function besselJ(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

export declare function besselY(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

export declare function beta(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

/** Numerically evaluates the beta function B(a, b) = Γ(a)·Γ(b)/Γ(a+b)

Uses Lanczos gamma approximation for high accuracy.

# Arguments

 * `a` - First parameter
 * `b` - Second parameter

# Examples

```rust
use mathhook_core::functions::special::beta::beta_numerical;

let result = beta_numerical(2.0, 3.0);
assert!((result - 1.0/12.0).abs() < 1e-14);
``` */
export declare function betaNumerical(a: number, b: number): number

/** Build a function expression with cached name construction

Combines function name caching with expression construction for
optimal performance in indexed function parsing.

# Examples

```rust
use mathhook_core::parser::cache::build_cached_function;
use mathhook_core::Expression;

let args = vec![Expression::integer(1), Expression::symbol("x")];
let func = build_cached_function("bessel", "j_indexed", args);
``` */
export declare function buildCachedFunction(base: string, suffix: string, args: Array<Expression>): Expression

/** Reuse Vec allocations for expression lists

Builds a `Vec<Expression>` using a thread-local buffer to minimize
heap allocations during parsing.

# Examples

```rust
use mathhook_core::parser::cache::build_expr_list;
use mathhook_core::Expression;

let exprs = vec![Expression::integer(1), Expression::integer(2)];
let result = build_expr_list(exprs);
```

# Performance

- Reuses pre-allocated Vec capacity
- Single clone operation instead of multiple allocations
- Thread-local storage avoids synchronization overhead */
export declare function buildExprList(exprs: Array<Expression>): Array<Expression>

/** Build differential extension tower for expression

Analyzes the expression structure and identifies transcendental
extensions (exponentials and logarithms).

# Arguments

 * `expr` - The expression to analyze
 * `var` - The variable of integration

# Examples

```rust
use mathhook_core::calculus::integrals::risch::differential_extension::build_extension_tower;
use mathhook_core::Expression;
use mathhook_core::symbol;

let x = symbol!(x);
let expr = Expression::function("exp", vec![Expression::symbol(x.clone())]);
let tower = build_extension_tower(&expr, x);
assert!(tower.is_some());
``` */
export declare function buildExtensionTower(expr: Expression, var: symbol): Array<DifferentialExtension> | null

/** Cache a computation result */
export declare function cacheResult(exprHash: number, result: Expression): void

/** Get comprehensive cache statistics for monitoring */
export declare function cacheStats(): CacheStatistics

export declare function ceil(x: ExpressionOrNumber): Expression

/** Classify a PDE and return its type */
export declare function classifyPde(pde: Pde): PdeType

/** Clear background computation cache */
export declare function clearBackgroundCompute(): void

/** Clear the global cache */
export declare function clearCache(): void

/** Clear all thread-local caches

Useful for testing or when memory usage needs to be minimized.
Should rarely be needed in normal operation. */
export declare function clearCaches(): void

/** Clear persistent cache */
export declare function clearPersistentCache(): void

/** Compute hash for expression (for memoization) */
export declare function computeExprHash(expr: Expression): number

/** Compute Heaviside coefficient for repeated linear factors

For `(x-r)^n` in denominator, coefficient k is:
```text
Aₖ = (1/(n-k)!) · [d^(n-k)/dx^(n-k) of g(x)]|ₓ₌ᵣ
```
where `g(x) = (x-r)^n · P(x)/Q(x)`

# Arguments

 * `numerator` - Numerator polynomial `P(x)`
 * `denominator` - Full denominator `Q(x)`
 * `root` - The root `r`
 * `total_power` - Multiplicity `n`
 * `k` - Coefficient index (1 to n)
 * `var` - Integration variable

# Returns

The coefficient `Aₖ` or `None` if computation fails

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::linear::compute_heaviside_coefficient;

let x = symbol!(x);
let numerator = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-1),
]),
Expression::integer(3),
);
let root = Expression::integer(1);

let coeff = compute_heaviside_coefficient(&numerator, &denominator, &root, 3, 1, &x);
assert!(coeff.is_some());
``` */
export declare function computeHeavisideCoefficient(numerator: Expression, denominator: Expression, root: Expression, totalPower: number, k: number, var: symbol): Expression | null

export declare function cos(x: ExpressionOrNumber): Expression

export declare function cosh(x: ExpressionOrNumber): Expression

/** Get polynomial degree

# Mathematical Definition

degree(p(x)) = highest power of x in polynomial p

# Arguments

 * `poly` - Polynomial expression
 * `var` - Variable to check degree for

# Returns

Degree as integer expression or symbolic

# Examples

```ignore
use mathhook_core::functions::polynomials::polynomial_eval::degree;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let poly = expr!((x ^ 3) + (2 * (x ^ 2)) + x + 1);
let deg = degree(&poly, &x);
assert_eq!(deg, expr!(3));
``` */
export declare function degree(poly: Expression, var: symbol): Expression

/**
 * Get polynomial degree with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to check degree for
 *
 * # Returns
 *
 * Degree as integer expression or symbolic
 *
 * # Examples
 *
 * ```javascript
 * const { degree, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^3 + 2*x^2 + x + 1');
 * const deg = degree(poly, 'x');  // Returns 3
 * ```
 */
export declare function degree(poly: Expression, variable: string): Expression

export declare function digamma(x: ExpressionOrNumber): Expression

/** Numerically evaluates the digamma function using series expansion

Uses reflection formula for z < 0.5 and asymptotic series for z ≥ 0.5.

# Arguments

 * `z` - Value to evaluate digamma at

# Returns

ψ(z) value */
export declare function digammaNumerical(z: number): number

export declare function erf(x: ExpressionOrNumber): Expression

export declare function erfc(x: ExpressionOrNumber): Expression

/** Evaluate polynomial using three-term recurrence relation

Generic implementation for all orthogonal polynomials that uses the
recurrence relation defined in PolynomialProperties. This is mathematically
the most stable approach for polynomial evaluation.

# Recurrence Form

For orthogonal polynomials, the three-term recurrence has the form:
```text
P_{n+1}(x) = (alpha_n * x + beta_n) * P_n(x) + gamma_n * P_{n-1}(x)
```

# Arguments

 * `properties` - Polynomial properties containing recurrence coefficients
 * `n` - Polynomial degree (must be non-negative)
 * `x` - Evaluation point

# Returns

Numerical value of P_n(x) computed using recurrence relation

# Examples

```rust
use mathhook_core::functions::polynomials::evaluation::evaluate_recurrence;
use mathhook_core::functions::polynomials::legendre::LegendreIntelligence;
use mathhook_core::functions::properties::FunctionProperties;

let legendre = LegendreIntelligence::new();
let props = legendre.get_properties();
if let Some(FunctionProperties::Polynomial(legendre_props)) = props.get("legendre_p") {
  let result = evaluate_recurrence(legendre_props, 5, 0.5);
  assert!((result - 0.08984375).abs() < 1e-10);
}
``` */
export declare function evaluateRecurrence(properties: PolynomialProperties, n: number, x: number): number

export declare function exp(x: ExpressionOrNumber): Expression

/** Expand polynomial expression

# Mathematical Definition

expand((x+1)²) = x² + 2x + 1

# Arguments

 * `expr` - Expression to expand

# Returns

Expanded expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::expand;
use mathhook_core::expr;

let result = expand(&expr!(1));
assert_eq!(result, expr!(1));
``` */
export declare function expand(expr: Expression): Expression

/** Expand Chebyshev polynomial of the first kind T_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- T_0(x) = 1
- T_1(x) = x
- T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)

Chebyshev polynomials of the first kind are important in approximation theory
and have the explicit form T_n(x) = cos(n arccos(x)) for |x| ≤ 1.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Chebyshev polynomial T_n(x)

# Mathematical Background

Chebyshev polynomials of the first kind are solutions to:
(1-x²)y'' - xy' + n²y = 0

They are orthogonal on [-1, 1] with weight function w(x) = 1/√(1-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_chebyshev_first_symbolic;
use mathhook_core::core::Expression;

let t0 = expand_chebyshev_first_symbolic(0);
let t1 = expand_chebyshev_first_symbolic(1);
let t2 = expand_chebyshev_first_symbolic(2);
let t3 = expand_chebyshev_first_symbolic(3);
``` */
export declare function expandChebyshevFirstSymbolic(n: number): Expression

/** Expand Chebyshev polynomial of the second kind U_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- U_0(x) = 1
- U_1(x) = 2x
- U_{n+1}(x) = 2x U_n(x) - U_{n-1}(x)

Chebyshev polynomials of the second kind have the explicit form
U_n(x) = sin((n+1) arccos(x)) / sin(arccos(x)) for |x| < 1.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Chebyshev polynomial U_n(x)

# Mathematical Background

Chebyshev polynomials of the second kind are orthogonal on [-1, 1]
with weight function w(x) = √(1-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_chebyshev_second_symbolic;
use mathhook_core::core::Expression;

let u0 = expand_chebyshev_second_symbolic(0);
let u1 = expand_chebyshev_second_symbolic(1);
let u2 = expand_chebyshev_second_symbolic(2);
let u3 = expand_chebyshev_second_symbolic(3);
``` */
export declare function expandChebyshevSecondSymbolic(n: number): Expression

/** Expand Hermite polynomial H_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- H_0(x) = 1
- H_1(x) = 2x
- H_{n+1}(x) = 2x H_n(x) - 2n H_{n-1}(x)

These are the physicist's Hermite polynomials used in quantum mechanics
for the harmonic oscillator eigenfunctions.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Hermite polynomial H_n(x)

# Mathematical Background

Hermite polynomials are solutions to Hermite's differential equation:
y'' - 2xy' + 2ny = 0

They are orthogonal on (-∞, ∞) with weight function w(x) = e^(-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_hermite_symbolic;
use mathhook_core::core::Expression;

let h0 = expand_hermite_symbolic(0);
let h1 = expand_hermite_symbolic(1);
let h2 = expand_hermite_symbolic(2);
let h3 = expand_hermite_symbolic(3);
``` */
export declare function expandHermiteSymbolic(n: number): Expression

/** Expand Laguerre polynomial L_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- L_0(x) = 1
- L_1(x) = 1 - x
- (n+1)L_{n+1}(x) = (2n+1-x)L_n(x) - nL_{n-1}(x)

These are the standard Laguerre polynomials (not generalized).

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Laguerre polynomial L_n(x)

# Mathematical Background

Laguerre polynomials are solutions to Laguerre's differential equation:
xy'' + (1-x)y' + ny = 0

They are orthogonal on [0, ∞) with weight function w(x) = e^(-x).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_laguerre_symbolic;
use mathhook_core::core::Expression;

let l0 = expand_laguerre_symbolic(0);
let l1 = expand_laguerre_symbolic(1);
let l2 = expand_laguerre_symbolic(2);
let l3 = expand_laguerre_symbolic(3);
``` */
export declare function expandLaguerreSymbolic(n: number): Expression

/** Expand Legendre polynomial P_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- P_0(x) = 1
- P_1(x) = x
- P_{n+1}(x) = [(2n+1)x P_n(x) - n P_{n-1}(x)] / (n+1)

This implementation builds the polynomial iteratively using the Expression system,
applying simplification at each step to maintain manageable expression size.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Legendre polynomial P_n(x)

# Mathematical Background

Legendre polynomials are solutions to Legendre's differential equation:
(1-x²)y'' - 2xy' + n(n+1)y = 0

They are orthogonal on [-1, 1] with weight function w(x) = 1.

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_legendre_symbolic;
use mathhook_core::core::Expression;

let p0 = expand_legendre_symbolic(0);
let p1 = expand_legendre_symbolic(1);
let p2 = expand_legendre_symbolic(2);
let p3 = expand_legendre_symbolic(3);
``` */
export declare function expandLegendreSymbolic(n: number): Expression

/** Explain algorithm selection criteria for polynomial GCD

Provides educational explanation of when to use each GCD algorithm
based on polynomial characteristics. */
export declare function explainAlgorithmSelection(): string

/** Generate educational explanation for constant integration

# Arguments

 * `constant` - The constant expression
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_constant_rule;

let x = symbol!(x);
let constant = Expression::integer(5);
let explanation = explain_constant_rule(&constant, &x);
assert!(explanation.steps.len() >= 2);
``` */
export declare function explainConstantRule(constant: Expression, variable: symbol): StepByStepExplanation

/** Explain the content extraction step */
export declare function explainContentExtraction(): string

/** Explain the CRT reconstruction step */
export declare function explainCrtReconstruction(): string

/** Generate educational explanation for definite integral evaluation

# Arguments

 * `integrand` - The integrand expression
 * `variable` - The variable of integration
 * `lower_bound` - The lower limit of integration
 * `upper_bound` - The upper limit of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_definite_integral;

let x = symbol!(x);
let integrand = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let lower = Expression::integer(0);
let upper = Expression::integer(2);
let explanation = explain_definite_integral(&integrand, &x, &lower, &upper);
assert!(explanation.steps.len() >= 5);
``` */
export declare function explainDefiniteIntegral(integrand: Expression, variable: symbol, lowerBound: Expression, upperBound: Expression): StepByStepExplanation

/** Generate educational explanation for integration by parts

# Arguments

 * `u_choice` - The u function choice
 * `dv_choice` - The dv function choice
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_integration_by_parts;

let x = symbol!(x);
let u_choice = Expression::symbol(x.clone());
let dv_choice = Expression::function("exp", vec![Expression::symbol(x.clone())]);
let explanation = explain_integration_by_parts(&u_choice, &dv_choice, &x);
assert!(explanation.steps.len() >= 7);
``` */
export declare function explainIntegrationByParts(uChoice: Expression, dvChoice: Expression, variable: symbol): StepByStepExplanation

/** Generate step-by-step description for a specific GCD iteration

# Arguments
 * `iteration` - Current iteration number (1-based)
 * `prime` - The prime used in this iteration
 * `gcd_degree` - Degree of GCD computed mod p
 * `converged` - Whether coefficients have stabilized */
export declare function explainIterationStep(iteration: number, prime: number, gcdDegree: number, converged: boolean): string

/** Explain multivariate evaluation-interpolation */
export declare function explainMultivariateEvaluation(): string

export declare function explainPolyDivisionImpl(expr: Expression, divisor: Expression, var: symbol): StepByStepExplanation

export declare function explainPolyFactorizationImpl(expr: Expression, var: symbol): StepByStepExplanation

export declare function explainPolyGcdImpl(expr: Expression, other: Expression): StepByStepExplanation

/** Generate educational explanation for power rule integration

# Arguments

 * `base` - The base expression (typically a variable)
 * `exponent` - The exponent expression
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_power_rule;

let x = symbol!(x);
let base = Expression::symbol(x.clone());
let exponent = Expression::integer(2);
let explanation = explain_power_rule(&base, &exponent, &x);
assert!(explanation.steps.len() >= 3);
``` */
export declare function explainPowerRule(base: Expression, exponent: Expression, variable: symbol): StepByStepExplanation

/** Explain why a particular algorithm was chosen

# Arguments
 * `is_univariate` - Whether polynomial is univariate
 * `max_degree` - Maximum degree of input polynomials
 * `is_sparse` - Whether polynomial is sparse (density < 0.3)
 * `large_coeffs` - Whether coefficients exceed 64-bit range */
export declare function explainSelectionRationale(isUnivariate: boolean, maxDegree: number, isSparse: boolean, largeCoeffs: boolean): string

/** Explain sparse polynomial optimization */
export declare function explainSparseOptimization(): string

/** Explain trial division verification */
export declare function explainTrialDivision(): string

/** Generate educational explanation for u-substitution

# Arguments

 * `integrand` - The integrand expression
 * `substitution` - The u substitution
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_u_substitution;

let x = symbol!(x);
let integrand = Expression::mul(vec![
Expression::integer(2),
Expression::symbol(x.clone()),
Expression::function("sin", vec![Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))]),
]);
let substitution = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let explanation = explain_u_substitution(&integrand, &substitution, &x);
assert!(explanation.steps.len() >= 6);
``` */
export declare function explainUSubstitution(integrand: Expression, substitution: Expression, variable: symbol): StepByStepExplanation

/** Extract division pattern from expression

Division can be represented as:
1. Mul([numerator, Pow(denominator, -1)]) for general divisions like 3/x
2. Pow(denominator, -1) for 1/x (the 1 is simplified away)

Returns Some((numerator, denominator)) if pattern matches. */
export declare function extractDivision(expr: Expression): [Expression, Expression] | null

/** Extract coefficients A and B from linear expression `Ax+B`

# Arguments

 * `expr` - Expression to analyze
 * `var` - Variable to extract coefficient for

# Returns

`Some((A, B))` if expression is linear, `None` otherwise

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::extract_linear_coefficients;

let x = symbol!(x);

let expr1 = Expression::add(vec![
Expression::mul(vec![Expression::integer(3), Expression::symbol(x.clone())]),
Expression::integer(5),
]);
let (a, b) = extract_linear_coefficients(&expr1, &x).unwrap();

let expr2 = Expression::integer(7);
let (a2, b2) = extract_linear_coefficients(&expr2, &x).unwrap();
``` */
export declare function extractLinearCoefficients(expr: Expression, var: symbol): [Expression, Expression] | null

/** Extract numerator and denominator from rational expression

# Arguments

 * `expr` - Rational expression

# Returns

Tuple `(numerator, denominator)`

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::extract_numerator_denominator;

let x = symbol!(x);
let expr = Expression::mul(vec![
Expression::integer(2),
Expression::pow(
Expression::symbol(x.clone()),
Expression::integer(-1),
),
]);

let (num, den) = extract_numerator_denominator(&expr);
``` */
export declare function extractNumeratorDenominator(expr: Expression): [Expression, Expression]

/** Factor polynomial expression

# Mathematical Definition

factor(x² - 1) = (x - 1)(x + 1)

# Arguments

 * `expr` - Expression to factor

# Returns

Factored expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::factor;
use mathhook_core::expr;

let result = factor(&expr!(1));
assert_eq!(result, expr!(1));
``` */
export declare function factor(expr: Expression): Expression

export declare function factorial(x: ExpressionOrNumber): Expression

/** Compute factorial of a non-negative integer

# Arguments

 * `n` - Non-negative integer

# Examples

```
use mathhook_core::calculus::integrals::rational::helpers::factorial;

assert_eq!(factorial(0), 1);
assert_eq!(factorial(1), 1);
assert_eq!(factorial(5), 120);
assert_eq!(factorial(10), 3628800);
``` */
export declare function factorialWithN(n: number): number

export declare function floor(x: ExpressionOrNumber): Expression

export declare function gamma(x: ExpressionOrNumber): Expression

export declare function gcd(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

/** Get current adaptive thresholds from the global profiler */
export declare function getAdaptiveThresholds(): AdaptiveThresholds

/** Get background computation statistics */
export declare function getBackgroundComputeStatistics(): BackgroundComputeStatistics

/** Get a precomputed result */
export declare function getBackgroundResult(taskId: number): ComputeResult | null

/** Get result by expression if available */
export declare function getBackgroundResultByExpression(expr: Expression): ComputeResult | null

/** Efficient function name construction with caching

Constructs function names like "bessel_j_indexed" and caches them
to avoid repeated string allocations.

# Examples

```rust
use mathhook_core::parser::cache::get_cached_function_name;

let name1 = get_cached_function_name("bessel", "j_indexed");
let name2 = get_cached_function_name("bessel", "j_indexed");
// Second call reuses cached result
```

# Performance

- First call: O(n) string construction + HashMap insertion
- Subsequent calls: O(1) HashMap lookup + clone */
export declare function getCachedFunctionName(base: string, suffix: string): string

/** Get cached result for expression hash */
export declare function getCachedResult(exprHash: number): Expression | null

/** Get configuration statistics for monitoring */
export declare function getConfigInfo(): ConfigInfo

/** Get the current global performance configuration */
export declare function getGlobalConfig(): PerformanceConfig

/** Get GPU capabilities information */
export declare function getGpuCapabilities(): GpuCapabilities | null

/** Get GPU acceleration statistics */
export declare function getGpuStatistics(): GpuStatistics

/** Get a PDE educational message by key */
export declare function getPdeMessage(key: PdeMessageKey): string | null

/** Get comprehensive performance metrics for monitoring and debugging

Note: SIMD and parallel statistics tracking is not yet implemented.
These fields return default values until runtime tracking is added. */
export declare function getPerformanceMetrics(): PerformanceMetrics

/** Get performance summary as human-readable string */
export declare function getPerformanceSummary(): string

/** Get a cached result from the global persistent cache */
export declare function getPersistentCachedResult(expressionHash: number): Expression | null

/** Get profiler statistics for monitoring */
export declare function getProfilerStatistics(): ProfilerStatistics

/**
 * Compute Gröbner basis for a system of polynomials
 *
 * A Gröbner basis is a special generating set for a polynomial ideal that
 * has useful computational properties, analogous to row echelon form for matrices.
 *
 * # Arguments
 *
 * * `polynomials` - Array of polynomial expressions
 * * `variables` - Array of variable names
 * * `order` - Monomial ordering: "lex" (lexicographic), "grlex" (graded lex), or "grevlex" (graded reverse lex)
 *
 * # Examples
 *
 * ```javascript
 * const x = JsExpression.symbol("x");
 * const y = JsExpression.symbol("y");
 * const p1 = x.pow(JsExpression.integer(2)).add(y.pow(JsExpression.integer(2))).subtract(JsExpression.integer(1));
 * const p2 = x.subtract(y);
 * const basis = groebnerBasis([p1, p2], ["x", "y"], "lex");
 * // Returns Gröbner basis for the ideal generated by p1 and p2
 * ```
 */
export declare function groebnerBasis(polynomials: Array<Expression>, variables: Array<string>, order: string): Array<Expression>

/** Initialize global performance optimizer */
export declare function initPerformanceOptimizer(config: PerformanceConfig): void

/** Integrate linear partial fraction using Heaviside's method

For simple pole (power=1): Uses cover-up method
For repeated pole (power>1): Uses Heaviside's method with derivatives

# Mathematical Basis

For `P(x)/Q(x)` with `Q(x) = (x-r)^n · R(x)`, we want:
```text
P(x)/Q(x) = A₁/(x-r) + A₂/(x-r)² + ... + Aₙ/(x-r)ⁿ + (other terms)
```

Heaviside's method: Define `g(x) = (x-r)ⁿ · P(x)/Q(x) = P(x)/R(x)`
Then: `Aₖ = (1/(n-k)!) · [d^(n-k)/dx^(n-k) g(x)]|ₓ₌ᵣ`

# Integration Formulas

- `∫A/(x-r) dx = A·ln|x-r| + C`
- `∫A/(x-r)ⁿ dx = -A/((n-1)(x-r)^(n-1)) + C` for `n > 1`

# Arguments

 * `numerator` - Numerator polynomial `P(x)`
 * `denominator` - Full denominator `Q(x)`
 * `root` - The root `r` of the linear factor
 * `power` - Multiplicity `n` of the root
 * `var` - Integration variable

# Returns

Integrated expression or `None` if integration fails

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::linear::integrate_linear_factor;
use mathhook_core::simplify::Simplify;

let x = symbol!(x);

let numerator = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-2),
]),
Expression::integer(2),
);
let root = Expression::integer(2);

let result = integrate_linear_factor(&numerator, &denominator, &root, 2, &x);
assert!(result.is_some());
``` */
export declare function integrateLinearFactor(numerator: Expression, denominator: Expression, root: Expression, power: number, var: symbol): Expression | null

/** Integrate rational function `P(x)/Q(x)` via partial fractions

# Arguments

 * `expr` - Rational expression to integrate
 * `var` - Integration variable

# Returns

Integrated expression or `None` if not a rational function or unsupported

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::integrate_rational;

let x = symbol!(x);
let rational = Expression::mul(vec![
Expression::integer(1),
Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-1),
]),
Expression::integer(-1),
),
]);

let result = integrate_rational(&rational, &x);
assert!(result.is_some());
``` */
export declare function integrateRational(expr: Expression, var: symbol): Expression | null

/** Integrate a rational function P(x)/Q(x)

Implements Hermite reduction algorithm for complete rational function integration.

# Arguments

 * `numerator` - Polynomial P(x)
 * `denominator` - Polynomial Q(x) (must be non-zero)
 * `var` - Variable of integration

# Algorithm

1. If deg(P) ≥ deg(Q): Perform polynomial long division
- P/Q = quotient + remainder/Q
- Integrate quotient using power rule
2. Apply Hermite reduction to remainder/Q:
- Compute D = gcd(Q, Q') where Q' is derivative
- Use extended GCD to extract logarithmic terms
- Separate into algebraic + logarithmic parts
3. Return complete integral

# Examples

```rust
use mathhook_core::calculus::integrals::risch::rational::integrate_rational;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let num = expr!((x^2) + 1);
let den = expr!(x - 1);
let result = integrate_rational(&num, &den, &x);
```

# Returns

Returns `RationalIntegral` containing:
- `polynomial_part`: Result of integrating quotient
- `logarithmic_terms`: List of (coefficient, argument) for ln terms
- `remaining`: Any unintegrated rational part (None if complete) */
export declare function integrateRationalWithNumeratorDenominatorVar(numerator: Expression, denominator: Expression, var: symbol): RationalIntegral

/** Integrate repeated irreducible quadratic using Ostrogradsky's reduction

For `∫(Ax+B)/(x²+px+q)^m dx` where `m > 1`, uses Ostrogradsky's formula:
```text
∫f/D^m dx = g/D^(m-1) + ∫h/D dx
```

# Mathematical Method (Ostrogradsky's Reduction)

1. Set up reduction formula with unknown linear polynomial `g = ax+b`
2. Use identity: `f = g'·D - (m-1)·g·D' + h·D^(m-1)`
3. Expand and collect coefficients to solve for `a`, `b`, `h`
4. Integrate remainder `h/D` using simple quadratic formula

# Current Implementation

Handles `m=2` case (most common). For higher powers, returns `None`.
Can be generalized using recursive Ostrogradsky reduction.

# Arguments

 * `numerator` - Numerator expression (linear in `x`)
 * `denominator` - Full denominator (for reference)
 * `p` - Linear coefficient in `x²+px+q`
 * `q` - Constant term in `x²+px+q`
 * `power` - Exponent `m` (currently only `m=2` supported)
 * `var` - Integration variable

# Returns

Integrated expression or `None` if unsupported power

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::integrate_repeated_quadratic;

let x = symbol!(x);
let numerator = Expression::integer(1);
let p = Expression::integer(0);
let q = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
q.clone(),
]),
Expression::integer(2),
);

let result = integrate_repeated_quadratic(&numerator, &denominator, &p, &q, 2, &x);
assert!(result.is_some());
```

# References

- Stewart, Calculus (8th ed), Section 7.4
- Bronstein, "Symbolic Integration I" (reduction formulas) */
export declare function integrateRepeatedQuadratic(numerator: Expression, denominator: Expression, p: Expression, q: Expression, power: number, var: symbol): Expression | null

/** Integrate simple irreducible quadratic `(Bx+C)/(x²+px+q)`

# Mathematical Method

For `x²+px+q` with discriminant `Δ = p²-4q < 0` (irreducible):

1. Complete the square: `x²+px+q = (x+p/2)² + a²` where `a² = q - p²/4`
2. Split integral: `∫(Bx+C)/(x²+px+q) dx = B∫x/(x²+px+q) dx + C∫1/(x²+px+q) dx`
3. Logarithmic part: `∫x/(x²+px+q) dx = (1/2)ln|x²+px+q| - (p/2)∫1/(x²+px+q) dx`
4. Arctangent part: `∫1/(x²+px+q) dx = (1/a)arctan((x+p/2)/a)`

# Current Implementation

Simplified version assumes constant numerator (B=0, C=1).

# Arguments

 * `_numerator` - Numerator (currently unused, assumes 1)
 * `_denominator` - Full denominator (for reference)
 * `p` - Linear coefficient in `x²+px+q`
 * `q` - Constant term in `x²+px+q`
 * `var` - Integration variable

# Returns

Integrated expression or `None` if quadratic is not irreducible

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::integrate_simple_quadratic;

let x = symbol!(x);
let numerator = Expression::integer(1);
let p = Expression::integer(0);
let q = Expression::integer(1);
let denominator = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
q.clone(),
]);

let result = integrate_simple_quadratic(&numerator, &denominator, &p, &q, &x);
assert!(result.is_some());
``` */
export declare function integrateSimpleQuadratic(numerator: Expression, denominator: Expression, p: Expression, q: Expression, var: symbol): Expression | null

/** Main integration strategy dispatcher

Tries strategies in order from fast to slow, returning first success.

# Recursion Depth Limit

Returns symbolic integral if depth >= MAX_DEPTH (10) to prevent infinite recursion. */
export declare function integrateWithStrategy(expr: Expression, var: symbol, depth: number): Expression

/** Check if GPU acceleration is available */
export declare function isGpuAvailable(): boolean

/** Check if expression is just the variable

Returns true if the expression is exactly the given symbol variable.

# Arguments

 * `expr` - The expression to check
 * `var` - The variable symbol to compare against

# Examples

```rust
use mathhook_core::calculus::integrals::risch::helpers::is_just_variable;
use mathhook_core::{Expression, symbol};

let x = symbol!(x);
let expr = Expression::symbol(x.clone());
assert!(is_just_variable(&expr, &x));
``` */
export declare function isJustVariable(expr: Expression, var: symbol): boolean

/** Check if expression is the constant 1

# Arguments

 * `expr` - The expression to check

# Examples

```rust
use mathhook_core::calculus::integrals::risch::helpers::is_one;
use mathhook_core::Expression;

let one = Expression::integer(1);
assert!(is_one(&one));

let two = Expression::integer(2);
assert!(!is_one(&two));
``` */
export declare function isOne(expr: Expression): boolean

/** Check if expression is a polynomial in the given variable

Polynomial: only var, constants, +, *, and non-negative integer powers. */
export declare function isPolynomial(expr: Expression, var: symbol): boolean

/** Check if expression is a polynomial in the given variable

# Arguments

 * `expr` - The expression to check
 * `var` - The variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::is_polynomial;

let x = symbol!(x);
let poly = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::symbol(x.clone()),
Expression::integer(1),
]);

assert!(is_polynomial(&poly, &x));

let non_poly = Expression::function("sin", vec![Expression::symbol(x.clone())]);
assert!(!is_polynomial(&non_poly, &x));
``` */
export declare function isPolynomialWithExprVar(expr: Expression, var: symbol): boolean

export declare function isprime(x: ExpressionOrNumber): Expression

/** Check if expression is a rational function

A rational function is P(x)/Q(x) where P and Q are polynomials.
This excludes transcendental functions like exp, ln, sin, cos. */
export declare function isRationalFunction(expr: Expression): boolean

/** Check if expression is a rational function `P(x)/Q(x)`

# Arguments

 * `expr` - Expression to check
 * `var` - Variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::is_rational_function;

let x = symbol!(x);
let rational = Expression::mul(vec![
Expression::symbol(x.clone()),
Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(1),
]),
Expression::integer(-1),
),
]);

assert!(is_rational_function(&rational, &x));
``` */
export declare function isRationalFunctionWithExprVar(expr: Expression, var: symbol): boolean

/** Lanczos approximation for Gamma function (for numerical evaluation)

Provides accurate numerical evaluation using the Lanczos approximation
with 14-digit precision. This is used for non-special values.

# Input Validation

- NaN or infinity inputs return NaN
- Non-positive integers (poles) return infinity

# Examples

```rust
use mathhook_core::functions::special::lanczos_gamma;

let result = lanczos_gamma(5.0);
assert!((result - 24.0).abs() < 1e-10);

let half = lanczos_gamma(0.5);
let sqrt_pi = std::f64::consts::PI.sqrt();
assert!((half - sqrt_pi).abs() < 1e-14);
``` */
export declare function lanczosGamma(z: number): number

export declare function lcm(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

export declare function ln(x: ExpressionOrNumber): Expression

export declare function log10(x: ExpressionOrNumber): Expression

/** Check if operation size meets parallel threshold (for binding-specific use) */
export declare function meetsParallelThreshold(operationSize: number): boolean

/** Applies the method of characteristics to a first-order quasi-linear PDE

# Arguments

 * `pde` - The first-order PDE to solve: a(x,y,u)·∂u/∂x + b(x,y,u)·∂u/∂y = c(x,y,u)

# Returns

Returns `CharacteristicSolution` containing:
- Characteristic equations (dx/ds, dy/ds, du/ds)
- General solution in implicit form
- Extracted coefficients

# Examples

```ignore
use mathhook_core::calculus::pde::method_of_characteristics::method_of_characteristics;
use mathhook_core::calculus::pde::types::Pde;
use mathhook_core::{symbol, expr};

// Transport equation: ∂u/∂t + c·∂u/∂x = 0
let u = symbol!(u);
let t = symbol!(t);
let x = symbol!(x);
let equation = expr!(u);
let pde = Pde::new(equation, u, vec![t, x]);

let result = method_of_characteristics(&pde);
assert!(result.is_ok());
```

# Errors

Returns error if:
- PDE is not first-order
- Not quasi-linear form
- Coefficients are singular
- ODE solver fails */
export declare function methodOfCharacteristics(pde: Pde): CharacteristicSolution

export declare function modulo(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

/**
 * Parse a mathematical expression from a string
 *
 * Supports multiple input formats with auto-detection:
 * - **Standard notation**: `x^2 + 2*x + 1`
 * - **LaTeX notation**: `\frac{x^2}{2} + \sin(x)`
 * - **Wolfram notation**: `Sin[x] + Cos[y]`
 * - **Implicit multiplication**: `2x`, `(a)(b)`, `2(x+1)`
 * - **Functions**: sin, cos, tan, exp, log, sqrt, and all special functions
 * - **Greek letters**: alpha, beta, gamma, theta, pi, etc.
 * - **Constants**: pi, e, i (imaginary unit)
 *
 * # Arguments
 * * `expression` - Mathematical expression string in any supported format
 *
 * # Returns
 * Parsed Expression object ready for manipulation
 *
 * # Errors
 * Returns error if the expression cannot be parsed
 *
 * # Examples
 * ```javascript
 * const { parse } = require('mathhook');
 *
 * // Basic arithmetic
 * const expr1 = parse('x^2 + 2*x + 1');
 *
 * // Implicit multiplication
 * const expr2 = parse('2x + 3y');  // Same as '2*x + 3*y'
 *
 * // Functions
 * const expr3 = parse('sin(x) + cos(y)');
 *
 * // LaTeX (auto-detected)
 * const expr4 = parse('\\frac{x^2}{2}');
 *
 * // Wolfram notation (auto-detected)
 * const expr5 = parse('Sin[x] + Cos[y]');
 *
 * // Greek letters
 * const expr6 = parse('alpha + beta');
 *
 * // Complex expressions
 * const expr7 = parse('sin(2*pi*x) + exp(-x^2/2)');
 * ```
 */
export declare function parse(expression: string): Expression

/** Convert PascalCase function names to snake_case

This provides a flexible, generic way to convert Wolfram function names
(like "BesselJ", "ArcSin") to consistent snake_case format.

# Examples

```rust
use mathhook_core::parser::constants::pascal_to_snake_case;

assert_eq!(pascal_to_snake_case("Sin"), "sin");
assert_eq!(pascal_to_snake_case("BesselJ"), "bessel_j");
assert_eq!(pascal_to_snake_case("ArcSin"), "arc_sin");
assert_eq!(pascal_to_snake_case("DiracDelta"), "dirac_delta");
``` */
export declare function pascalToSnakeCase(name: string): string

export declare function polygamma(x: ExpressionOrNumber, y: ExpressionOrNumber): Expression

/** Get polynomial degree with respect to a variable

# Arguments

 * `expr` - The polynomial expression
 * `var` - The variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::polynomial_degree;

let x = symbol!(x);
let cubic = Expression::pow(Expression::symbol(x.clone()), Expression::integer(3));
assert_eq!(polynomial_degree(&cubic, &x), 3);

let linear = Expression::symbol(x.clone());
assert_eq!(polynomial_degree(&linear, &x), 1);

let constant = Expression::integer(5);
assert_eq!(polynomial_degree(&constant, &x), 0);
``` */
export declare function polynomialDegree(expr: Expression, var: symbol): number

/** Unified polynomial division with automatic type routing

Returns (quotient, remainder) such that:
`dividend = divisor * quotient + remainder`

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_div;

let x = symbol!(x);
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let (quot, rem) = polynomial_div(&dividend, &divisor, &x);
``` */
export declare function polynomialDiv(dividend: Expression, divisor: Expression, var: symbol): [Expression, Expression]

/** Polynomial long division

Returns (quotient, remainder) such that:
`dividend = divisor * quotient + remainder`
and `degree(remainder) < degree(divisor)`

Uses IntPoly fast-path for univariate integer polynomials (primary path).

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by (must be non-zero)
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.
Returns `MathError::NotImplemented` for complex symbolic polynomial division.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_div;

let x = symbol!(x);
// (x^2 + 3x + 2) / (x + 1) = (x + 2) with remainder 0
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let (quot, rem) = polynomial_div(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
```

# Returns

Returns `(quotient, remainder)` tuple where both are expressions */
export declare function polynomialDivWithDividendDivisorVar(dividend: Expression, divisor: Expression, var: symbol): [Expression, Expression]

/** Evaluate polynomial at integer value for main variable

Substitutes var = value and simplifies to get a polynomial in remaining variables. */
export declare function polynomialEvaluateAt(poly: Expression, var: symbol, value: number): Expression

/** Polynomial GCD - routes to best algorithm automatically

Uses fast-path optimization to avoid expensive classification for simple cases.

# Arguments

 * `p1` - First expression
 * `p2` - Second expression

# Returns

GCD of the two expressions

# Examples

```rust
use mathhook_core::algebra::gcd::polynomial_gcd;
use mathhook_core::core::Expression;

let a = Expression::integer(12);
let b = Expression::integer(18);
let gcd = polynomial_gcd(&a, &b).unwrap();
assert_eq!(gcd, Expression::integer(6));
``` */
export declare function polynomialGcd(p1: Expression, p2: Expression): Expression

/** Unified polynomial GCD with automatic type routing

Analyzes coefficient types and routes to optimal implementation:
- All integers → IntPoly GCD (fastest)
- Any rationals → RationalPoly GCD (field operations)
- Symbolic → fallback to Euclidean algorithm

# Arguments
 * `a` - First polynomial
 * `b` - Second polynomial
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_gcd;

let x = symbol!(x);
let p1 = expr!((x^2) - 1);
let p2 = expr!(x - 1);
let gcd = polynomial_gcd(&p1, &p2, &x);
``` */
export declare function polynomialGcdWithABVar(a: Expression, b: Expression, var: symbol): Expression

/** Interpolate polynomial from integer using symmetric representation

Recovers polynomial coefficients from integer h using base x.
Uses symmetric modular representation: if coeff > x/2, use coeff - x. */
export declare function polynomialInterpolate(h: Expression, x: number, var: symbol): Expression

/** Unified polynomial quotient with automatic type routing

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_quo;

let x = symbol!(x);
let dividend = expr!((x^2) - 1);
let divisor = expr!(x - 1);
let quot = polynomial_quo(&dividend, &divisor, &x);
``` */
export declare function polynomialQuo(dividend: Expression, divisor: Expression, var: symbol): Expression

/** Polynomial quotient (division without remainder)

Returns only the quotient part of polynomial division

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_quo;

let x = symbol!(x);
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let quot = polynomial_quo(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
``` */
export declare function polynomialQuoWithDividendDivisorVar(dividend: Expression, divisor: Expression, var: symbol): Expression

/** Unified polynomial remainder with automatic type routing

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_rem;

let x = symbol!(x);
let dividend = expr!((x^2) + 1);
let divisor = expr!(x - 1);
let rem = polynomial_rem(&dividend, &divisor, &x);
``` */
export declare function polynomialRem(dividend: Expression, divisor: Expression, var: symbol): Expression

/** Polynomial remainder

Returns only the remainder part of polynomial division

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_rem;

let x = symbol!(x);
let dividend = expr!((x^2) + 1);
let divisor = expr!(x - 1);
let rem = polynomial_rem(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
``` */
export declare function polynomialRemWithDividendDivisorVar(dividend: Expression, divisor: Expression, var: symbol): Expression

/** Predict and precompute based on current expression */
export declare function predictAndPrecompute(currentExpr: Expression): void

/** Resolve special function name for indexed functions

# Examples

```rust
use mathhook_core::parser::constants::resolve_special_function;

assert_eq!(resolve_special_function("J"), Some("bessel_j"));
assert_eq!(resolve_special_function("P"), Some("legendre_p"));
assert_eq!(resolve_special_function("Unknown"), None);
``` */
export declare function resolveSpecialFunction(name: string): string | null

/** Resolve standard function name (for simple functions like sin(x))

# Examples

```rust
use mathhook_core::parser::constants::resolve_standard_function;

assert_eq!(resolve_standard_function("sin"), Some("sin"));
assert_eq!(resolve_standard_function("asin"), Some("arcsin"));
assert_eq!(resolve_standard_function("unknown"), None);
``` */
export declare function resolveStandardFunction(name: string): string | null

/** Efficient function name lookup with fallback

# Examples

```rust
use mathhook_core::parser::constants::resolve_wolfram_function;

assert_eq!(resolve_wolfram_function("Sin"), Some("sin"));
assert_eq!(resolve_wolfram_function("UnknownFunction"), None);
``` */
export declare function resolveWolframFunction(name: string): string | null

/** Find polynomial roots

# Mathematical Definition

roots(p(x)) = {x : p(x) = 0}

# Arguments

 * `poly` - Polynomial expression
 * `var` - Variable to solve for

# Returns

Set of roots or symbolic expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::roots;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let poly = expr!((x ^ 2) - 1);
let r = roots(&poly, &x);
``` */
export declare function roots(poly: Expression, var: symbol): Expression

/**
 * Find polynomial roots with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to solve for
 *
 * # Returns
 *
 * Set of roots or symbolic expression
 *
 * # Examples
 *
 * ```javascript
 * const { roots, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^2 - 1');
 * const r = roots(poly, 'x');  // Returns roots of quadratic
 * ```
 */
export declare function roots(poly: Expression, variable: string): Expression

export declare function round(x: ExpressionOrNumber): Expression

/** Force save persistent cache to disk */
export declare function savePersistentCache(): void

/** Set global configuration for a specific binding context

Convenience method for binding crates:

```ignore
// In mathhook-node/src/lib.rs
use mathhook_core::core::performance::config::set_binding_config;
use mathhook_core::core::performance::strategy::BindingContext;

fn init_mathhook_node() {
  set_binding_config(BindingContext::NodeJs);
}
``` */
export declare function setBindingConfig(context: BindingContext): void

/** Set the global performance configuration

This is typically called once by binding crates during initialization:

```ignore
// In mathhook-python/src/lib.rs
use mathhook_core::core::performance::config::set_global_config;
use mathhook_core::core::performance::strategy::{PerformanceConfig, BindingContext};

#[pymodule]
fn mathhook_python(_py: Python, m: &PyModule) -> PyResult<()> {
  // Set Python-optimized configuration globally
  let config = PerformanceConfig::for_binding(BindingContext::Python);
  set_global_config(config);
  Ok(())
}
``` */
export declare function setGlobalConfig(config: PerformanceConfig): void

/** Smart SIMD decision: use SIMD only when beneficial */
export declare function shouldUseSimd(operationSize: number): boolean

export declare function sign(x: ExpressionOrNumber): Expression

/** Simplify absolute value expressions

Applies mathematical simplification rules for absolute value.

# Simplification Rules

- |0| = 0
- |-x| = |x|
- |x²| = x² (squares are always non-negative)
- |a*b| = |a|*|b|
- |a/b| = |a|/|b|
- ||x|| = |x|

# Arguments

 * `arg` - The argument to the absolute value function

# Returns

Simplified expression

# Examples

```
use mathhook_core::core::Expression;
use mathhook_core::functions::elementary::abs::simplify_abs;

let zero = Expression::integer(0);
assert_eq!(simplify_abs(&zero), Expression::integer(0));

let neg_five = Expression::integer(-5);
assert_eq!(simplify_abs(&neg_five), Expression::integer(5));

let squared = Expression::pow(Expression::symbol("x"), Expression::integer(2));
assert_eq!(simplify_abs(&squared), squared);
``` */
export declare function simplifyAbs(arg: Expression): Expression

/** Simplify square root expressions

Applies mathematical simplification rules for square root.

# Simplification Rules

- sqrt(0) = 0
- sqrt(1) = 1
- sqrt(4) = 2, sqrt(9) = 3, etc. (perfect squares)
- sqrt(x²) = |x|
- sqrt(x⁴) = x² (even powers)
- sqrt(a*b) = sqrt(a)*sqrt(b) (when a, b ≥ 0)
- sqrt(a²*b) = a*sqrt(b) (factor perfect squares)
- sqrt(1/4) = 1/2 (rational perfect squares)

# Arguments

 * `arg` - The argument to the square root function

# Returns

Simplified expression

# Examples

```
use mathhook_core::core::Expression;
use mathhook_core::functions::elementary::sqrt::simplify_sqrt;

let zero = Expression::integer(0);
assert_eq!(simplify_sqrt(&zero), Expression::integer(0));

let four = Expression::integer(4);
assert_eq!(simplify_sqrt(&four), Expression::integer(2));

let squared = Expression::pow(Expression::symbol("x"), Expression::integer(2));
assert_eq!(
simplify_sqrt(&squared),
Expression::function("abs", vec![Expression::symbol("x")])
);
``` */
export declare function simplifySqrt(arg: Expression): Expression

export declare function sin(x: ExpressionOrNumber): Expression

export declare function sinh(x: ExpressionOrNumber): Expression

/** Solve Sturm-Liouville eigenvalue problem with boundary conditions

Solves: X''(x) + λX(x) = 0 on [a, b] with given BCs

# Arguments

 * `bc_left` - Boundary condition at left endpoint
 * `bc_right` - Boundary condition at right endpoint
 * `num_modes` - Number of eigenvalue/eigenfunction pairs to compute

# Returns

Eigenvalues and eigenfunctions, or error if BCs are incompatible

# Examples

```rust
use mathhook_core::calculus::pde::common::eigenvalue_problem::solve_sturm_liouville;
use mathhook_core::calculus::pde::types::BoundaryCondition;
use mathhook_core::{symbol, expr};

let x = symbol!(x);
let bc_left = BoundaryCondition::dirichlet_at(x.clone(), expr!(0), expr!(0));
let bc_right = BoundaryCondition::dirichlet_at(x.clone(), expr!(pi), expr!(0));

let result = solve_sturm_liouville(&bc_left, &bc_right, 5);
assert!(result.is_ok());
let solution = result.unwrap();
assert_eq!(solution.eigenvalues.len(), 5);
``` */
export declare function solveSturmLiouville(bcLeft: BoundaryCondition, bcRight: BoundaryCondition, numModes: number): EigenvalueSolution

/**
 * Square root function
 *
 * Uses Expression::pow(expr, 1/2) internally to match SymPy's representation.
 *
 * # Arguments
 * * `x` - Expression or number to evaluate
 *
 * # Examples
 * ```javascript
 * const { sqrt, symbol } = require('mathhook');
 * const x = symbol('x');
 * const expr = sqrt(x);  // √x (represented as x^(1/2))
 * const num = sqrt(4);   // √4
 * ```
 */
export declare function sqrt(x: ExpressionOrNumber): Expression

/** Store a result in the global persistent cache */
export declare function storePersistentCachedResult(expressionHash: number, simplified: Expression): void

/** Submit a task for background computation */
export declare function submitBackgroundTask(expression: Expression, priority: ComputePriority, likelihood: number): number

/** Substitute a value for a variable in an expression

# Arguments

 * `expr` - The expression
 * `var` - The variable to substitute
 * `value` - The value to substitute

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::substitute_variable;
use mathhook_core::simplify::Simplify;

let x = symbol!(x);
let expr = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::integer(1),
]);

let result = substitute_variable(&expr, &x, &Expression::integer(3));
assert_eq!(result.simplify(), Expression::integer(10));
``` */
export declare function substituteVariable(expr: Expression, var: symbol, value: Expression): Expression

/**
 * Create a single symbol
 *
 * Creates a symbolic variable for use in mathematical expressions.
 * This is the primary way to create variables in MathHook.
 *
 * # Arguments
 *
 * * `name` - Name of the symbol (e.g., "x", "y", "theta")
 *
 * # Returns
 *
 * A JsExpression representing the symbol
 *
 * # Example
 *
 * ```javascript
 * const { symbol } = require('mathhook-node');
 *
 * // Create a single symbol
 * const x = symbol('x');
 * const y = symbol('y');
 *
 * // Use in expressions
 * const expr = x.pow(2).add(y);
 * console.log(expr.toSimple());  // "x^2 + y"
 *
 * // Greek letters
 * const theta = symbol('θ');
 * const alpha = symbol('alpha');
 * ```
 */
export declare function symbol(name: string): Expression

/**
 * Create multiple symbols at once from a string specification
 *
 * Supports three input formats:
 * - Space-separated: `"x y z"` → [x, y, z]
 * - Comma-separated: `"a, b, c"` or `"a,b,c"` → [a, b, c]
 * - Range syntax: `"x0:3"` → [x0, x1, x2]
 *
 * # Arguments
 *
 * * `names` - String containing symbol names in one of the supported formats
 *
 * # Returns
 *
 * Array of JsExpression symbols
 *
 * # Examples
 *
 * ```javascript
 * // Space-separated
 * const [x, y, z] = symbols('x y z');
 *
 * // Comma-separated
 * const [a, b, c] = symbols('a, b, c');
 *
 * // Range syntax
 * const [x0, x1, x2] = symbols('x0:3');
 *
 * // Use in expressions
 * const expr = x.add(y).multiply(z);
 * ```
 */
export declare function symbols(names: string): Array<Expression>

export declare function tan(x: ExpressionOrNumber): Expression

export declare function tanh(x: ExpressionOrNumber): Expression

/** Try integration by parts using the LIATE heuristic

Applies the product rule in reverse for expressions like x*exp(x). */
export declare function tryByParts(expr: Expression, var: symbol, depth: number): Expression | null

/** Try to extract quadratic coefficients from x² + px + q

Returns Some((p, q)) if expression matches x² + px + q pattern where the
coefficient of x² is exactly 1.

# Arguments

 * `expr` - The expression to analyze
 * `var` - The variable to match against

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::try_extract_quadratic;

let x = symbol!(x);

let quadratic = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
Expression::integer(1),
]);

let result = try_extract_quadratic(&quadratic, &x);
assert!(result.is_some());
let (p, q) = result.unwrap();
assert_eq!(p, Expression::integer(2));
assert_eq!(q, Expression::integer(1));
``` */
export declare function tryExtractQuadratic(expr: Expression, var: symbol): [Expression, Expression] | null

/** Try function registry integration using known antiderivatives

Uses the function intelligence registry for elementary functions. */
export declare function tryRegistryIntegration(expr: Expression, var: symbol): Expression | null

/** Main Risch integration entry point

Attempts to integrate using the Risch algorithm. Returns Some(result)
if successful, or None if the integral is proven non-elementary or
cannot be determined by the basic Risch implementation.

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Examples

```rust
use mathhook_core::calculus::integrals::risch::try_risch_integration;
use mathhook_core::Expression;
use mathhook_core::symbol;

let x = symbol!(x);
let integrand = Expression::function("exp", vec![Expression::symbol(x.clone())]);

let result = try_risch_integration(&integrand, &x);
assert!(result.is_some());
``` */
export declare function tryRischIntegration(expr: Expression, var: symbol): Expression | null

/** Try to integrate using u-substitution

Automatically detects composite function patterns and applies substitution.

# Arguments

 * `expr` - The integrand expression
 * `var` - The variable of integration
 * `depth` - Current recursion depth (prevents infinite recursion)

# Returns

Some(result) if substitution succeeds, None if no suitable substitution found

# Examples

```rust
use mathhook_core::calculus::integrals::substitution::try_substitution;
use mathhook_core::symbol;
use mathhook_core::core::Expression;

let x = symbol!(x);
// ∫2x*sin(x²) dx
let integrand = Expression::mul(vec![
Expression::integer(2),
Expression::symbol(x.clone()),
Expression::function("sin", vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))
])
]);

let result = try_substitution(&integrand, &x, 0);
assert!(result.is_some());
``` */
export declare function trySubstitution(expr: Expression, var: symbol, depth: number): Expression | null

/** Try to integrate expression using table lookup

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Returns

Some(integrated_expression) if pattern matches, None otherwise

# Examples

```rust
use mathhook_core::calculus::integrals::table::try_table_lookup;
use mathhook_core::{Expression, symbol};

let x = symbol!(x);
let expr = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let result = try_table_lookup(&expr, &x);
assert!(result.is_some());
``` */
export declare function tryTableLookup(expr: Expression, var: symbol): Expression | null

/** Try to integrate trigonometric expressions

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Returns

Some(result) if pattern matches, None otherwise

# Examples

```rust
use mathhook_core::calculus::integrals::trigonometric::try_trigonometric_integration;
use mathhook_core::symbol;
use mathhook_core::core::Expression;

let x = symbol!(x);
// ∫sin³(x) dx
let integrand = Expression::pow(
Expression::function("sin", vec![Expression::symbol(x.clone())]),
Expression::integer(3)
);
let result = try_trigonometric_integration(&integrand, &x);
assert!(result.is_some());
``` */
export declare function tryTrigonometricIntegration(expr: Expression, var: symbol): Expression | null

/** Univariate polynomial GCD with IntPoly fast-path

Uses IntPoly for integer coefficient polynomials, falls back to Expression::gcd().

# Arguments

 * `p1` - First univariate polynomial
 * `p2` - Second univariate polynomial
 * `var` - The variable of the polynomials

# Returns

GCD of the two polynomials */
export declare function univariateGcd(p1: Expression, p2: Expression, var: symbol): Expression

/** Univariate polynomial GCD with cofactors

Returns (gcd, cofactor_p1, cofactor_p2) using IntPoly fast-path.

# Arguments

 * `p1` - First univariate polynomial
 * `p2` - Second univariate polynomial
 * `var` - The variable of the polynomials

# Returns

Tuple of (gcd, cofactor_p1, cofactor_p2) */
export declare function univariateGcdModular(p1: Expression, p2: Expression, var: symbol): [Expression, Expression, Expression]

export declare function zeta(x: ExpressionOrNumber): Expression

/** Numerical evaluation of Riemann zeta function

Uses different algorithms depending on the value of s:
- Euler-Maclaurin acceleration for Re(s) > 1.5 (50 terms for 14-digit accuracy)
- Functional equation for Re(s) < 0
- Dirichlet eta relation for 0 < Re(s) < 1.5

# Mathematical Algorithm

For Re(s) > 1.5, uses Euler-Maclaurin acceleration:
ζ(s) = Σ(n=1 to N) 1/n^s + integral correction + Bernoulli corrections

For Re(s) < 0, uses the functional equation:
ζ(s) = 2^s π^(s-1) sin(πs/2) Γ(1-s) ζ(1-s) */
export declare function zetaNumerical(s: number): number
