/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Evaluation context for controlling evaluation behavior
 *
 * Controls how `evaluateWithContext()` behaves. Provides variable substitutions,
 * numerical evaluation control, and simplification options.
 *
 * # Examples
 *
 * ```typescript
 * import { EvalContext, Expression } from 'mathhook';
 *
 * // Symbolic evaluation (no numerical conversion)
 * const ctx = EvalContext.symbolic();
 * const result = expr.evaluateWithContext(ctx);
 *
 * // Numerical evaluation with substitutions
 * const ctx = EvalContext.numeric({ x: Expression.integer(3) });
 * const result = expr.evaluateWithContext(ctx);
 *
 * // Custom configuration
 * const ctx = new EvalContext({
 *   variables: { x: Expression.integer(5) },
 *   numeric: true,
 *   precision: 128,
 *   simplifyFirst: true
 * });
 * ```
 */
export declare class EvalContext {
  /**
   * Create a new evaluation context
   *
   * # Arguments
   *
   * * `options` - Configuration options for evaluation
   *   - `numeric` - Whether to perform numerical evaluation (default: true)
   *   - `precision` - Number of bits of precision for numerical operations (default: 53 for f64)
   *   - `simplifyFirst` - Whether to simplify before evaluation (default: true)
   *
   * # Examples
   *
   * ```typescript
   * import { EvalContext, Expression } from 'mathhook';
   *
   * // Default: numerical evaluation with simplification
   * const ctx = new EvalContext({});
   *
   * // Custom precision
   * const ctx = new EvalContext({ precision: 128 });
   *
   * // Symbolic mode (no numerical conversion)
   * const ctx = new EvalContext({ numeric: false });
   * ```
   */
  constructor(options?: EvalContextOptions | undefined | null)
  /**
   * Create context for symbolic evaluation (no numerical conversion)
   *
   * Returns a context that performs variable substitution but keeps expressions
   * in symbolic form. No numerical evaluation is performed.
   *
   * # Returns
   *
   * Context with:
   * - No variable substitutions
   * - Symbolic mode (numeric = false)
   * - Default precision (53 bits)
   * - No pre-simplification
   *
   * # Examples
   *
   * ```typescript
   * import { EvalContext, Expression, Symbol } from 'mathhook';
   *
   * const x = new Symbol('x');
   * const expr = x.pow(Expression.integer(2)).add(Expression.integer(1));
   *
   * const ctx = EvalContext.symbolic();
   * const result = expr.evaluateWithContext(ctx);
   * // Result is still symbolic: x^2 + 1
   * ```
   */
  static symbolic(): EvalContext
  /**
   * Create context for numerical evaluation with substitutions
   *
   * Returns a context that substitutes variables and converts to numerical form.
   * Simplification is enabled by default for numerical stability.
   *
   * # Arguments
   *
   * * `variables` - Array of [name, expression] pairs for variable substitution
   *
   * # Returns
   *
   * Context with:
   * - Provided variable substitutions
   * - Numerical mode (numeric = true)
   * - Default precision (53 bits for f64)
   * - Pre-simplification enabled (simplifyFirst = true)
   *
   * # Examples
   *
   * ```typescript
   * import { EvalContext, Expression, Symbol } from 'mathhook';
   *
   * const x = new Symbol('x');
   * const expr = x.pow(Expression.integer(2)).add(Expression.integer(1));
   *
   * // Evaluate at x = 3
   * const ctx = EvalContext.numeric([["x", Expression.integer(3)]]);
   * const result = expr.evaluateWithContext(ctx);
   * // Result: 10 (numerical)
   * ```
   */
  static numeric(variables: Array<[string, JsExpression]>): EvalContext
  /**
   * Set precision for numerical operations
   *
   * # Arguments
   *
   * * `precision` - Number of bits of precision (53 for f64, higher for future arbitrary precision)
   *
   * # Returns
   *
   * Self with updated precision (for method chaining)
   *
   * # Examples
   *
   * ```typescript
   * const ctx = EvalContext.symbolic().withPrecision(128);
   * ```
   */
  withPrecision(precision: number): EvalContext
  /**
   * Set simplification behavior
   *
   * # Arguments
   *
   * * `simplifyFirst` - Whether to simplify before evaluation
   *
   * # Returns
   *
   * Self with updated simplification setting (for method chaining)
   *
   * # Examples
   *
   * ```typescript
   * const ctx = new EvalContext({}).withSimplifyFirst(false);
   * ```
   */
  withSimplifyFirst(simplifyFirst: boolean): EvalContext
}

/** JavaScript wrapper for Expression */
export declare class JsExpression {
  /**
   * Create a new expression from an integer
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.integer(42);
   * ```
   */
  static integer(value: number): JsExpression
  /**
   * Create a new expression from a symbol
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const alpha = JsExpression.symbol("α");
   * ```
   */
  static symbol(name: string): JsExpression
  /**
   * Add two expressions with auto-conversion from numbers
   *
   * Accepts either another expression or a number (automatically converted).
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const result1 = x.add(JsExpression.integer(2));  // Expression
   * const result2 = x.add(2);                         // Number auto-converted
   * ```
   */
  add(other: JsExpression | number): JsExpression
  /**
   * Multiply two expressions with auto-conversion from numbers
   *
   * Accepts either another expression or a number (automatically converted).
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const result1 = x.multiply(JsExpression.integer(3));  // Expression
   * const result2 = x.multiply(3);                         // Number auto-converted
   * ```
   */
  multiply(other: JsExpression | number): JsExpression
  /**
   * Raise expression to a power with auto-conversion from numbers
   *
   * Accepts either another expression or a number (automatically converted).
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const result1 = x.pow(JsExpression.integer(2));  // Expression
   * const result2 = x.pow(2);                         // Number auto-converted
   * ```
   */
  pow(exponent: JsExpression | number): JsExpression
  /**
   * Simplify the expression
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.integer(2).add(JsExpression.integer(3));
   * const simplified = expr.simplify();
   * ```
   */
  simplify(): JsExpression
  /**
   * Parse a mathematical expression from string with automatic language detection
   *
   * The parser automatically detects the mathematical language (LaTeX, Wolfram, or simple notation)
   * and parses accordingly.
   *
   * # Examples
   *
   * ```javascript
   * const expr1 = JsExpression.parse("2*x + sin(y)");        // Simple notation
   * const expr2 = JsExpression.parse("\\frac{x^2}{2}");      // LaTeX auto-detected
   * const expr3 = JsExpression.parse("Sin[x] + Cos[y]");     // Wolfram auto-detected
   * ```
   */
  static parse(input: string): JsExpression
  /**
   * Convert expression to LaTeX format
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.symbol("x").pow(JsExpression.integer(2));
   * const latex = expr.toLatex();  // Returns "x^{2}"
   * ```
   */
  toLatex(): string
  /**
   * Convert expression to simple mathematical notation
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.symbol("x").pow(JsExpression.integer(2));
   * const simple = expr.toSimple();  // Returns "x^2"
   * ```
   */
  toSimple(): string
  /**
   * Convert expression to Wolfram Language format
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.function("sin", [JsExpression.symbol("x")]);
   * const wolfram = expr.toWolfram();  // Returns "Sin[x]"
   * ```
   */
  toWolfram(): string
  /**
   * Create a function expression
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const sinX = JsExpression.function("sin", [x]);
   * ```
   */
  static function(name: string, args: Array<JsExpression>): JsExpression
  /**
   * Create an equation (equality relation)
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const five = JsExpression.integer(5);
   * const equation = JsExpression.equation(x, five);
   * ```
   */
  static equation(left: JsExpression, right: JsExpression): JsExpression
  /**
   * Compute the derivative with respect to a variable
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2));
   * const derivative = expr.derivative("x");
   * ```
   */
  derivative(variable: string): JsExpression
  /**
   * Compute derivative with flexible variable input (alias for derivative)
   *
   * This method accepts either a symbol expression or a string variable name.
   * It's an alias for `derivative()` with more flexible input.
   *
   * # Arguments
   *
   * * `variable` - Either a JsExpression symbol or a string variable name
   *
   * # Examples
   *
   * ```javascript
   * const { symbol } = require('mathhook-node');
   *
   * const x = symbol('x');
   * const expr = x.pow(2).add(x.multiply(2)).add(1);
   *
   * // Using string (like derivative)
   * const d1 = expr.diff('x');
   *
   * // Using expression
   * const d2 = expr.diff(x);
   *
   * // Both produce the same result: 2*x + 2
   * ```
   */
  diff(variable: JsExpression | string): JsExpression
  /**
   * Compute nth derivative
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(3));
   * const secondDerivative = expr.nthDerivative("x", 2);
   * ```
   */
  nthDerivative(variable: string, order: number): JsExpression
  /**
   * Check if expression is differentiable
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2));
   * const canDiff = expr.isDifferentiable();
   * ```
   */
  isDifferentiable(): boolean
  /**
   * Compute indefinite integral
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2));
   * const integral = expr.integrate("x");
   * ```
   */
  integrate(variable: string): JsExpression
  /**
   * Compute definite integral
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x;
   * const lower = JsExpression.integer(0);
   * const upper = JsExpression.integer(1);
   * const result = expr.integrateDefinite("x", lower, upper);
   * ```
   */
  integrateDefinite(variable: string, lower: JsExpression, upper: JsExpression): JsExpression
  /**
   * Expand the expression
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.add(JsExpression.integer(1)).pow(JsExpression.integer(2));
   * const expanded = expr.expand();
   * ```
   */
  expand(): JsExpression
  /**
   * Factor the expression
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2)).add(x.multiply(JsExpression.integer(2)));
   * const factored = expr.factor();
   * ```
   */
  factor(): JsExpression
  /**
   * Collect terms with respect to a variable
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.add(x).add(JsExpression.integer(1));
   * const collected = expr.collect("x");
   * ```
   */
  collect(variable: string): JsExpression
  /**
   * Substitute variables with expressions
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const y = JsExpression.symbol("y");
   * const expr = x.add(y);
   * const result = expr.substitute({x: JsExpression.integer(2), y: JsExpression.integer(3)});
   * ```
   */
  substitute(substitutions: Record<string, JsExpression>): JsExpression
  /**
   * Evaluate the expression
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.integer(2).add(JsExpression.integer(3));
   * const result = expr.evaluate();
   * ```
   */
  evaluate(): JsExpression
  /**
   * Evaluate expression with context (substitution + computation)
   *
   * Provides full control over evaluation behavior including variable substitution,
   * numerical conversion, precision, and simplification.
   *
   * # Arguments
   *
   * * `context` - EvalContext controlling evaluation behavior
   *
   * # Returns
   *
   * Evaluated expression (numerical or symbolic based on context settings)
   *
   * # Throws
   *
   * Error if evaluation encounters domain errors (sqrt of negative, etc.)
   *
   * # Examples
   *
   * ```typescript
   * import { Expression, Symbol, EvalContext } from 'mathhook';
   *
   * const x = new Symbol('x');
   * const expr = x.pow(Expression.integer(2)).add(Expression.integer(1));
   *
   * // Evaluate at x = 3 (numerical)
   * const ctx = EvalContext.numeric({ x: Expression.integer(3) });
   * const result = expr.evaluateWithContext(ctx);
   * // result == Expression.integer(10)
   *
   * // Symbolic evaluation (no numerical conversion)
   * const ctxSymbolic = EvalContext.symbolic();
   * const resultSymbolic = expr.evaluateWithContext(ctxSymbolic);
   * // Result stays symbolic: x^2 + 1
   *
   * // Custom precision
   * const ctxPrecise = EvalContext.numeric({ x: Expression.float(3.14159) })
   *   .withPrecision(128);
   * const resultPrecise = expr.evaluateWithContext(ctxPrecise);
   * ```
   */
  evaluateWithContext(context: EvalContext): JsExpression
  /**
   * Create a rational number
   *
   * # Examples
   *
   * ```javascript
   * const half = JsExpression.rational(1, 2);
   * ```
   */
  static rational(numerator: number, denominator: number): JsExpression
  /**
   * Create a floating point number
   *
   * # Examples
   *
   * ```javascript
   * const pi = JsExpression.float(3.14159);
   * ```
   */
  static float(value: number): JsExpression
  /**
   * Create a complex number
   *
   * # Examples
   *
   * ```javascript
   * const z = JsExpression.complex(JsExpression.integer(3), JsExpression.integer(4));
   * ```
   */
  static complex(real: JsExpression, imag: JsExpression): JsExpression
  /**
   * Create the constant π
   *
   * # Examples
   *
   * ```javascript
   * const pi = JsExpression.pi();
   * ```
   */
  static pi(): JsExpression
  /**
   * Create Euler's number e
   *
   * # Examples
   *
   * ```javascript
   * const e = JsExpression.e();
   * ```
   */
  static e(): JsExpression
  /**
   * Create the imaginary unit i
   *
   * # Examples
   *
   * ```javascript
   * const i = JsExpression.i();
   * ```
   */
  static i(): JsExpression
  /**
   * Create the golden ratio φ
   *
   * # Examples
   *
   * ```javascript
   * const phi = JsExpression.goldenRatio();
   * ```
   */
  static goldenRatio(): JsExpression
  /**
   * Create Euler's gamma constant
   *
   * # Examples
   *
   * ```javascript
   * const gamma = JsExpression.eulerGamma();
   * ```
   */
  static eulerGamma(): JsExpression
  /**
   * Subtract two expressions with auto-conversion from numbers
   *
   * Accepts either another expression or a number (automatically converted).
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const result1 = x.subtract(JsExpression.symbol("y"));  // Expression
   * const result2 = x.subtract(3);                          // Number auto-converted
   * ```
   */
  subtract(other: JsExpression | number): JsExpression
  /**
   * Divide two expressions with auto-conversion from numbers
   *
   * Accepts either another expression or a number (automatically converted).
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const result1 = x.divide(JsExpression.symbol("y"));  // Expression
   * const result2 = x.divide(2);                          // Number auto-converted
   * ```
   */
  divide(other: JsExpression | number): JsExpression
  /**
   * Negate the expression
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const negX = x.negate();
   * ```
   */
  negate(): JsExpression
  /**
   * Get step-by-step explanation of simplification
   *
   * # Examples
   *
   * ```javascript
   * const expr = JsExpression.integer(2).add(JsExpression.integer(3));
   * const explanation = expr.explainSimplification();
   * ```
   */
  explainSimplification(): JsStepByStepExplanation
  /**
   * Get step-by-step explanation of derivative
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2));
   * const explanation = expr.derivativeWithSteps("x");
   * ```
   */
  derivativeWithSteps(variable: string): JsStepByStepExplanation
  /**
   * Compute limit of expression as variable approaches a value
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.divide(x);
   * const lim = expr.limit("x", JsExpression.integer(0));
   * ```
   */
  limit(variable: string, value: JsExpression): JsExpression
  /**
   * Compute limit as variable approaches infinity
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.divide(x.pow(JsExpression.integer(2)));
   * const lim = expr.limitInfinity("x");
   * ```
   */
  limitInfinity(variable: string): JsExpression
  /**
   * Compute Taylor/Maclaurin series expansion
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const sinx = JsExpression.function("sin", [x]);
   * const series = sinx.series("x", JsExpression.integer(0), 5);
   * ```
   */
  series(variable: string, point: JsExpression, order: number): JsExpression
  /**
   * Compute partial derivative with respect to multiple variables
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const y = JsExpression.symbol("y");
   * const expr = x.multiply(y);
   * const partial = expr.partialDerivative(["x", "y"]);
   * ```
   */
  partialDerivative(variables: Array<string>): JsExpression
  /**
   * Create a matrix from rows
   *
   * # Examples
   *
   * ```javascript
   * const a = JsExpression.integer(1);
   * const b = JsExpression.integer(2);
   * const c = JsExpression.integer(3);
   * const d = JsExpression.integer(4);
   * const m = JsExpression.matrix([[a, b], [c, d]]);
   * ```
   */
  static matrix(rows: Array<Array<JsExpression>>): JsExpression
  /**
   * Create an identity matrix
   *
   * # Examples
   *
   * ```javascript
   * const identity = JsExpression.identityMatrix(3);
   * ```
   */
  static identityMatrix(size: number): JsExpression
  /**
   * Create a zero matrix
   *
   * # Examples
   *
   * ```javascript
   * const zeros = JsExpression.zeroMatrix(2, 3);
   * ```
   */
  static zeroMatrix(rows: number, cols: number): JsExpression
  /**
   * Compute matrix determinant
   *
   * # Examples
   *
   * ```javascript
   * const m = JsExpression.identityMatrix(2);
   * const det = m.determinant();
   * ```
   */
  determinant(): JsExpression
  /**
   * Compute matrix inverse
   *
   * # Examples
   *
   * ```javascript
   * const m = JsExpression.identityMatrix(2);
   * const inv = m.inverse();
   * ```
   */
  inverse(): JsExpression
  /**
   * Compute matrix transpose
   *
   * # Examples
   *
   * ```javascript
   * const a = JsExpression.integer(1);
   * const b = JsExpression.integer(2);
   * const m = JsExpression.matrix([[a, b]]);
   * const t = m.transpose();
   * ```
   */
  transpose(): JsExpression
  /**
   * Perform LU decomposition with partial pivoting
   *
   * Decomposes matrix A into PA = LU where:
   * - P is a permutation matrix (optional, only when pivoting is needed)
   * - L is lower triangular with 1s on diagonal
   * - U is upper triangular
   *
   * # Examples
   *
   * ```javascript
   * const matrix = JsExpression.matrix([[2, 1, 1], [4, 3, 3], [8, 7, 9]]);
   * const lu = matrix.luDecomposition();
   * // lu.l = Lower triangular matrix
   * // lu.u = Upper triangular matrix
   * // lu.p = Permutation matrix (if pivoting was needed)
   * ```
   */
  luDecomposition(): LUDecompositionResult
  /**
   * Perform QR decomposition using Gram-Schmidt process
   *
   * Decomposes matrix A into A = QR where:
   * - Q is orthogonal (Q^T * Q = I)
   * - R is upper triangular
   *
   * # Examples
   *
   * ```javascript
   * const matrix = JsExpression.matrix([[1, 1, 0], [1, 0, 1], [0, 1, 1]]);
   * const qr = matrix.qrDecomposition();
   * // qr.q = Orthogonal matrix
   * // qr.r = Upper triangular matrix
   * ```
   */
  qrDecomposition(): QRDecompositionResult
  /**
   * Perform SVD (Singular Value Decomposition)
   *
   * Decomposes matrix A into A = UΣV^T where:
   * - U contains left singular vectors (orthogonal)
   * - Σ contains singular values (diagonal, non-negative)
   * - V^T contains right singular vectors (orthogonal)
   *
   * # Examples
   *
   * ```javascript
   * const matrix = JsExpression.matrix([[1, 2], [3, 4], [5, 6]]);
   * const svd = matrix.svdDecomposition();
   * // svd.u = Left singular vectors
   * // svd.sigma = Singular values (diagonal matrix)
   * // svd.vt = Right singular vectors (transposed)
   * ```
   */
  svdDecomposition(): SVDDecompositionResult
  /**
   * Perform Cholesky decomposition for positive definite matrices
   *
   * Decomposes symmetric positive definite matrix A into A = LL^T where:
   * - L is lower triangular with positive diagonal elements
   *
   * # Examples
   *
   * ```javascript
   * const matrix = JsExpression.matrix([[4, 2, 1], [2, 3, 0], [1, 0, 2]]);
   * const cholesky = matrix.choleskyDecomposition();
   * // Returns lower triangular matrix L such that A = L * L^T
   * ```
   */
  choleskyDecomposition(): JsExpression
  /**
   * String representation
   *
   * Returns a human-readable string representation of the expression
   * using standard mathematical notation.
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const expr = x.pow(JsExpression.integer(2));
   * console.log(expr.toString()); // "x^2"
   * ```
   */
  toString(): string
  /**
   * Compute resultant of two polynomials for elimination
   *
   * The resultant is a polynomial in the coefficients that vanishes if and only if
   * the two input polynomials have a common root.
   *
   * # Arguments
   *
   * * `p1` - First polynomial
   * * `p2` - Second polynomial
   * * `variable` - Variable to eliminate
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const p1 = x.pow(JsExpression.integer(2)).subtract(JsExpression.integer(1));
   * const p2 = x.subtract(JsExpression.integer(1));
   * const res = JsExpression.resultant(p1, p2, "x");
   * // Returns 0 (polynomials share root x=1)
   * ```
   */
  static resultant(p1: JsExpression, p2: JsExpression, variable: string): JsExpression
  /**
   * Compute discriminant of a polynomial
   *
   * The discriminant is a polynomial expression of the coefficients that
   * is zero if and only if the polynomial has a repeated root.
   *
   * # Arguments
   *
   * * `poly` - Polynomial expression
   * * `variable` - Main variable
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const poly = x.pow(JsExpression.integer(2)).add(x.multiply(JsExpression.integer(2))).add(JsExpression.integer(1));
   * const disc = JsExpression.discriminant(poly, "x");
   * // Returns 0 for (x+1)² which has repeated root
   * ```
   */
  static discriminant(poly: JsExpression, variable: string): JsExpression
  /**
   * Get polynomial degree with respect to a variable
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const poly = x.pow(JsExpression.integer(3)).add(x);
   * const degree = poly.polynomialDegree("x");
   * // Returns 3
   * ```
   */
  polynomialDegree(variable: string): number | null
  /**
   * Get leading coefficient of polynomial
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const poly = JsExpression.integer(2).multiply(x.pow(JsExpression.integer(2))).add(x);
   * const lc = poly.polynomialLeadingCoefficient("x");
   * // Returns 2
   * ```
   */
  polynomialLeadingCoefficient(variable: string): JsExpression
  /**
   * Get content (GCD of coefficients) of polynomial
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const poly = JsExpression.integer(6).multiply(x.pow(JsExpression.integer(2))).add(JsExpression.integer(9).multiply(x));
   * const content = poly.polynomialContent();
   * // Returns 3 (GCD of 6 and 9)
   * ```
   */
  polynomialContent(): JsExpression
  /**
   * Get primitive part of polynomial (polynomial / content)
   *
   * # Examples
   *
   * ```javascript
   * const x = JsExpression.symbol("x");
   * const poly = JsExpression.integer(6).multiply(x.pow(JsExpression.integer(2))).add(JsExpression.integer(9).multiply(x));
   * const primitive = poly.polynomialPrimitivePart();
   * // Returns 2x² + 3x (original / 3)
   * ```
   */
  polynomialPrimitivePart(): JsExpression
}

/** JavaScript wrapper for MathSolver */
export declare class JsMathSolver {
  /**
   * Create a new solver
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsMathSolver();
   * ```
   */
  constructor()
  /**
   * Solve an equation and return structured result
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsMathSolver();
   * const x = JsExpression.symbol("x");
   * const five = JsExpression.integer(5);
   * const equation = JsExpression.equation(x, five);
   * const result = solver.solve(equation, "x");
   * // result = { resultType: "single", solutions: ["5"], count: 1, metadata: "Single solution found" }
   * ```
   */
  solve(equation: JsExpression, variable: string): JsSolverResult
}

/** PDE Solver for Partial Differential Equations */
export declare class JsPdeSolver {
  /**
   * Create a new PDE solver
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * ```
   */
  constructor()
  /**
   * Solve the heat equation ∂u/∂t = α∇²u
   *
   * For 1D heat equation with Dirichlet boundary conditions and initial temperature distribution.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `spatial_var` - Spatial variable (e.g., "x")
   * * `temporal_var` - Time variable (e.g., "t")
   * * `alpha` - Thermal diffusivity coefficient
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const alpha = JsExpression.integer(1);
   * const solution = solver.solveHeatEquation("u", "x", "t", alpha);
   * // Returns heat equation solution with Fourier series
   * ```
   */
  solveHeatEquation(dependentVar: string, spatialVar: string, temporalVar: string, alpha: JsExpression): PdeSolution
  /**
   * Solve the wave equation ∂²u/∂t² = c²∇²u
   *
   * For 1D wave equation with Dirichlet boundary conditions and initial displacement/velocity.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `spatial_var` - Spatial variable (e.g., "x")
   * * `temporal_var` - Time variable (e.g., "t")
   * * `wave_speed` - Wave propagation speed c
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const c = JsExpression.integer(1);
   * const solution = solver.solveWaveEquation("u", "x", "t", c);
   * // Returns wave equation solution with Fourier series
   * ```
   */
  solveWaveEquation(dependentVar: string, spatialVar: string, temporalVar: string, waveSpeed: JsExpression): PdeSolution
  /**
   * Solve the Laplace equation ∇²u = 0
   *
   * For 2D Laplace equation on rectangular domain with Dirichlet boundary conditions.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `x_var` - First spatial variable (e.g., "x")
   * * `y_var` - Second spatial variable (e.g., "y")
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const solution = solver.solveLaplaceEquation("u", "x", "y");
   * // Returns Laplace equation solution with Fourier series
   * ```
   */
  solveLaplaceEquation(dependentVar: string, xVar: string, yVar: string): PdeSolution
}
export type JsPDESolver = JsPdeSolver

/** LU Decomposition result */
export declare class LuDecompositionResult {
  /** Get lower triangular matrix L */
  get l(): JsExpression
  /** Get upper triangular matrix U */
  get u(): JsExpression
  /** Get permutation matrix P (if pivoting was needed) */
  get p(): JsExpression | null
}
export type LUDecompositionResult = LuDecompositionResult

/** QR Decomposition result */
export declare class QrDecompositionResult {
  /** Get orthogonal matrix Q */
  get q(): JsExpression
  /** Get upper triangular matrix R */
  get r(): JsExpression
}
export type QRDecompositionResult = QrDecompositionResult

/** SVD Decomposition result */
export declare class SvdDecompositionResult {
  /** Get left singular vectors U */
  get u(): JsExpression
  /** Get singular values (diagonal matrix Σ) */
  get sigma(): JsExpression
  /** Get right singular vectors V^T */
  get vt(): JsExpression
}
export type SVDDecompositionResult = SvdDecompositionResult

export declare function abs(x: JsExpression | number): JsExpression

export declare function acos(x: JsExpression | number): JsExpression

export declare function asin(x: JsExpression | number): JsExpression

export declare function atan(x: JsExpression | number): JsExpression

export declare function besselJ(x: JsExpression | number, y: JsExpression | number): JsExpression

export declare function besselY(x: JsExpression | number, y: JsExpression | number): JsExpression

export declare function beta(x: JsExpression | number, y: JsExpression | number): JsExpression

export declare function ceil(x: JsExpression | number): JsExpression

export declare function cos(x: JsExpression | number): JsExpression

export declare function cosh(x: JsExpression | number): JsExpression

export declare function cosMacroGenerated(x: JsExpression | number): JsExpression

/**
 * Get polynomial degree with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to check degree for
 *
 * # Returns
 *
 * Degree as integer expression or symbolic
 *
 * # Examples
 *
 * ```javascript
 * const { degree, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^3 + 2*x^2 + x + 1');
 * const deg = degree(poly, 'x');  // Returns 3
 * ```
 */
export declare function degree(poly: JsExpression, variable: string): JsExpression

export declare function digamma(x: JsExpression | number): JsExpression

export declare function erf(x: JsExpression | number): JsExpression

export declare function erfc(x: JsExpression | number): JsExpression

/** Options for creating an EvalContext */
export interface EvalContextOptions {
  /** Whether to perform numerical evaluation (default: true) */
  numeric?: boolean
  /** Number of bits of precision for numerical operations (default: 53 for f64) */
  precision?: number
  /** Whether to simplify before evaluation (default: true) */
  simplifyFirst?: boolean
}

export declare function exp(x: JsExpression | number): JsExpression

export declare function factorial(x: JsExpression | number): JsExpression

export declare function floor(x: JsExpression | number): JsExpression

export declare function gamma(x: JsExpression | number): JsExpression

export declare function gcd(x: JsExpression | number, y: JsExpression | number): JsExpression

/**
 * Compute Gröbner basis for a system of polynomials
 *
 * A Gröbner basis is a special generating set for a polynomial ideal that
 * has useful computational properties, analogous to row echelon form for matrices.
 *
 * # Arguments
 *
 * * `polynomials` - Array of polynomial expressions
 * * `variables` - Array of variable names
 * * `order` - Monomial ordering: "lex" (lexicographic), "grlex" (graded lex), or "grevlex" (graded reverse lex)
 *
 * # Examples
 *
 * ```javascript
 * const x = JsExpression.symbol("x");
 * const y = JsExpression.symbol("y");
 * const p1 = x.pow(JsExpression.integer(2)).add(y.pow(JsExpression.integer(2))).subtract(JsExpression.integer(1));
 * const p2 = x.subtract(y);
 * const basis = groebnerBasis([p1, p2], ["x", "y"], "lex");
 * // Returns Gröbner basis for the ideal generated by p1 and p2
 * ```
 */
export declare function groebnerBasis(polynomials: Array<JsExpression>, variables: Array<string>, order: string): Array<JsExpression>

export declare function isprime(x: JsExpression | number): JsExpression

/** Solver result wrapper for JavaScript */
export interface JsSolverResult {
  /** Type of result: "single", "multiple", "no_solution", "infinite_solutions" */
  resultType: string
  /** Solution expressions as strings (empty for no_solution/infinite_solutions) */
  solutions: Array<string>
  /** Number of solutions found */
  count: number
  /** Optional metadata about the solution */
  metadata?: string
}

/** Step in explanation */
export interface JsStep {
  title: string
  description: string
  before: string
  after: string
}

/** Step-by-step explanation */
export interface JsStepByStepExplanation {
  steps: Array<JsStep>
}

export declare function lcm(x: JsExpression | number, y: JsExpression | number): JsExpression

export declare function ln(x: JsExpression | number): JsExpression

export declare function log10(x: JsExpression | number): JsExpression

export declare function modulo(x: JsExpression | number, y: JsExpression | number): JsExpression

/**
 * Parse a mathematical expression from a string
 *
 * Supports multiple input formats with auto-detection:
 * - **Standard notation**: `x^2 + 2*x + 1`
 * - **LaTeX notation**: `\frac{x^2}{2} + \sin(x)`
 * - **Wolfram notation**: `Sin[x] + Cos[y]`
 * - **Implicit multiplication**: `2x`, `(a)(b)`, `2(x+1)`
 * - **Functions**: sin, cos, tan, exp, log, sqrt, and all special functions
 * - **Greek letters**: alpha, beta, gamma, theta, pi, etc.
 * - **Constants**: pi, e, i (imaginary unit)
 *
 * # Arguments
 * * `expression` - Mathematical expression string in any supported format
 *
 * # Returns
 * Parsed Expression object ready for manipulation
 *
 * # Errors
 * Returns error if the expression cannot be parsed
 *
 * # Examples
 * ```javascript
 * const { parse } = require('mathhook');
 *
 * // Basic arithmetic
 * const expr1 = parse('x^2 + 2*x + 1');
 *
 * // Implicit multiplication
 * const expr2 = parse('2x + 3y');  // Same as '2*x + 3*y'
 *
 * // Functions
 * const expr3 = parse('sin(x) + cos(y)');
 *
 * // LaTeX (auto-detected)
 * const expr4 = parse('\\frac{x^2}{2}');
 *
 * // Wolfram notation (auto-detected)
 * const expr5 = parse('Sin[x] + Cos[y]');
 *
 * // Greek letters
 * const expr6 = parse('alpha + beta');
 *
 * // Complex expressions
 * const expr7 = parse('sin(2*pi*x) + exp(-x^2/2)');
 * ```
 */
export declare function parse(expression: string): JsExpression

/** PDE Solution result */
export interface PdeSolution {
  /** Solution expression */
  solution: string
  /** Method used for solving */
  method: string
  /** Eigenvalues (for separation of variables) */
  eigenvalues?: Array<string>
  /** Fourier coefficients */
  coefficients?: Array<string>
}

export declare function polygamma(x: JsExpression | number, y: JsExpression | number): JsExpression

/**
 * Find polynomial roots with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to solve for
 *
 * # Returns
 *
 * Set of roots or symbolic expression
 *
 * # Examples
 *
 * ```javascript
 * const { roots, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^2 - 1');
 * const r = roots(poly, 'x');  // Returns roots of quadratic
 * ```
 */
export declare function roots(poly: JsExpression, variable: string): JsExpression

export declare function round(x: JsExpression | number): JsExpression

export declare function sign(x: JsExpression | number): JsExpression

export declare function sin(x: JsExpression | number): JsExpression

export declare function sinh(x: JsExpression | number): JsExpression

export declare function sinMacroGenerated(x: JsExpression | number): JsExpression

/**
 * Square root function
 *
 * Uses Expression::pow(expr, 1/2) internally to match SymPy's representation.
 *
 * # Arguments
 * * `x` - Expression or number to evaluate
 *
 * # Examples
 * ```javascript
 * const { sqrt, symbol } = require('mathhook');
 * const x = symbol('x');
 * const expr = sqrt(x);  // √x (represented as x^(1/2))
 * const value = sqrt(4);  // Evaluates to 2
 * ```
 */
export declare function sqrt(x: JsExpression | number): JsExpression

/**
 * Create a single symbol
 *
 * Creates a symbolic variable for use in mathematical expressions.
 * This is the primary way to create variables in MathHook.
 *
 * # Arguments
 *
 * * `name` - Name of the symbol (e.g., "x", "y", "theta")
 *
 * # Returns
 *
 * A JsExpression representing the symbol
 *
 * # Examples
 *
 * ```javascript
 * const { symbol } = require('mathhook-node');
 *
 * // Create a single symbol
 * const x = symbol('x');
 * const y = symbol('y');
 *
 * // Use in expressions
 * const expr = x.pow(2).add(y);
 * console.log(expr.toSimple());  // "x^2 + y"
 *
 * // Greek letters
 * const theta = symbol('θ');
 * const alpha = symbol('alpha');
 * ```
 */
export declare function symbol(name: string): JsExpression

/**
 * Create multiple symbols at once from a string specification
 *
 * Supports three input formats:
 * - Space-separated: `"x y z"` → [x, y, z]
 * - Comma-separated: `"a, b, c"` or `"a,b,c"` → [a, b, c]
 * - Range syntax: `"x0:3"` → [x0, x1, x2]
 *
 * # Arguments
 *
 * * `names` - String containing symbol names in one of the supported formats
 *
 * # Returns
 *
 * Array of JsExpression symbols
 *
 * # Examples
 *
 * ```javascript
 * // Space-separated
 * const [x, y, z] = symbols('x y z');
 *
 * // Comma-separated
 * const [a, b, c] = symbols('a, b, c');
 *
 * // Range syntax
 * const [x0, x1, x2] = symbols('x0:3');
 *
 * // Use in expressions
 * const expr = x.add(y).multiply(z);
 * ```
 */
export declare function symbols(names: string): Array<JsExpression>

export declare function tan(x: JsExpression | number): JsExpression

export declare function tanh(x: JsExpression | number): JsExpression

export declare function tanMacroGenerated(x: JsExpression | number): JsExpression

export declare function zeta(x: JsExpression | number): JsExpression
