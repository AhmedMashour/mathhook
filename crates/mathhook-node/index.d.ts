/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class JsAbsoluteValueIntelligence {
  constructor()
  /** Get absolute value function properties

  # Examples

  ```
  use mathhook_core::functions::elementary::abs::AbsoluteValueIntelligence;

  let intelligence = AbsoluteValueIntelligence::new();
  let props = intelligence.get_properties();
  assert!(props.contains_key("abs"));
  ``` */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is absolute value

  # Arguments

   * `name` - The function name to check

  # Examples

  ```
  use mathhook_core::functions::elementary::abs::AbsoluteValueIntelligence;

  let intelligence = AbsoluteValueIntelligence::new();
  assert!(intelligence.has_function("abs"));
  assert!(!intelligence.has_function("sin"));
  ``` */
  hasFunction(name: string): boolean
}

export declare class JsAbsSimplificationStrategy {
  name(): string
}

export declare class JsAccuracyVerifier {
  constructor()
  /** Get verified constant by name */
  getVerifiedConstant(name: string): JsVerifiedConstant | null
  /** Verify mathematical accuracy of a function evaluation

  Returns true if the evaluation meets research-grade accuracy standards */
  verifyAccuracy(functionClass: string, computed: number, expected: number): boolean
  /** Get verified relationship by name */
  getVerifiedRelationship(name: string): JsVerifiedRelationship | null
  /** Generate accuracy report for all verified constants and relationships */
  generateAccuracyReport(): string
}

export declare class JsAdaptiveConfig {
  constructor()
  cloneValue(): JsAdaptiveConfig
}

export declare class JsAdaptiveSimpson {
  constructor()
}

export declare class JsAdaptiveThresholds {
  constructor()
  cloneValue(): JsAdaptiveThresholds
}

export declare class JsAntiderivativeRule {
  cloneValue(): JsAntiderivativeRule
}

export declare class JsAntiderivativeRuleType {

}

export declare class JsBackgroundCompute {
  constructor()
  /** Clear all tasks and results */
  clear(): void
  /** Submit a task for background computation */
  submitTask(expression: JsExpression, priority: JsComputePriority, likelihood: number): number
  /** Predict and precompute likely next expressions based on current expression */
  predictAndPrecompute(currentExpr: JsExpression): void
  /** Get statistics about background computation */
  getStatistics(): JsBackgroundComputeStatistics
  /** Get a precomputed result if available */
  getResult(taskId: number): JsComputeResult | null
  /** Get result by expression hash (if we've computed this expression before) */
  getResultByExpression(expr: JsExpression): JsComputeResult | null
  /** Submit common expressions for precomputation */
  precomputeCommonExpressions(): void
  /** Stop the background worker */
  stopWorker(): void
}

export declare class JsBackgroundComputeStatistics {
  cloneValue(): JsBackgroundComputeStatistics
}

export declare class JsBernoulliOdeSolver {
  /** Detect if ODE is in Bernoulli form

  Checks if equation matches dy/dx + p(x)y = q(x)y^n

  # Arguments

   * `equation` - The ODE equation
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  Optional (p, q, n) if equation is Bernoulli form */
  detectForm(equation: JsExpression, dependent: symbol, independent: symbol): [JsExpression, JsExpression, JsExpression] | null
}
export type JsBernoulliODESolver = JsBernoulliOdeSolver

export declare class JsBindingContext {
  equals(other: JsBindingContext): boolean
  cloneValue(): JsBindingContext
}

export declare class JsBisectionMethod {
  /** Create a new bisection method with initial bracket

  # Arguments

   * `a` - Lower bound of bracket
   * `b` - Upper bound of bracket

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::BisectionMethod;

  let method = BisectionMethod::new(0.0, 2.0);
  ``` */
  constructor(a: number, b: number)
}

export declare class JsBoundaryCondition {
  /** Creates a Robin boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::robin_at(
  x,
  expr!(0),
  expr!(1),
  expr!(2),
  expr!(10)
  );
  ``` */
  static robinAt(variable: symbol, location: JsExpression, alpha: JsExpression, beta: JsExpression, value: JsExpression): JsBoundaryCondition
  /** Create a Dirichlet boundary condition */
  static dirichlet(value: JsExpression, location: JsBoundaryLocation): JsBoundaryCondition
  /** Create a Robin boundary condition */
  static robin(coeffU: JsExpression, coeffDu: JsExpression, value: JsExpression, location: JsBoundaryLocation): JsBoundaryCondition
  /** Create a Neumann boundary condition */
  static neumann(derivative: JsExpression, location: JsBoundaryLocation): JsBoundaryCondition
  /** Creates a Dirichlet boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::dirichlet_at(x, expr!(0), expr!(100));
  ``` */
  static dirichletAt(variable: symbol, location: JsExpression, value: JsExpression): JsBoundaryCondition
  /** Creates a Neumann boundary condition at a specific point.

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::BoundaryCondition;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let bc = BoundaryCondition::neumann_at(x, expr!(0), expr!(50));
  ``` */
  static neumannAt(variable: symbol, location: JsExpression, value: JsExpression): JsBoundaryCondition
  equals(other: JsBoundaryCondition): boolean
  cloneValue(): JsBoundaryCondition
}

export declare class JsBoundaryLocation {
  equals(other: JsBoundaryLocation): boolean
  cloneValue(): JsBoundaryLocation
}

export declare class JsCacheStatistics {
  constructor()
  cloneValue(): JsCacheStatistics
}

export declare class JsCacheStats {
  cloneValue(): JsCacheStats
}

export declare class JsCharacteristicPolynomial {
  /** Converts polynomial to expression form

  Returns: c₀ + c₁λ + c₂λ² + ... + cₙλⁿ

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],
  lambda.clone()
  );

  let expr = poly.to_expression();
  // Represents: 6 - 5λ + λ²
  ``` */
  toExpression(): JsExpression
  /** Returns the degree of the polynomial

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(2), expr!(3)],
  lambda
  );
  assert_eq!(poly.degree(), 2);
  ``` */
  degree(): number
  /** Multiplies two characteristic polynomials

  # Arguments

   * `poly1` - First polynomial
   * `poly2` - Second polynomial

  # Returns

  Product of the two polynomials

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);

  let poly1 = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(1)],  // 1 + λ
  lambda.clone()
  );
  let poly2 = CharacteristicPolynomial::new(
  vec![expr!(2), expr!(1)],  // 2 + λ
  lambda.clone()
  );

  let product = poly1.multiply(&poly2);  // 2 + 3λ + λ²
  assert_eq!(product.degree(), 2);
  ``` */
  multiply(other: JsCharacteristicPolynomial): JsCharacteristicPolynomial
  /** Formats polynomial as human-readable string

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],
  lambda
  );

  let formatted = poly.format();
  // Output: "6 + (-5)·λ + λ²"
  ``` */
  format(): string
  /** Creates new characteristic polynomial

  # Arguments

   * `coefficients` - Polynomial coefficients [c₀, c₁, ..., cₙ]
   * `variable` - Variable symbol (typically λ)

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],  // λ² - 5λ + 6
  lambda
  );
  ``` */
  constructor(coefficients: Array<JsExpression>, variable: symbol)
  /** Evaluates polynomial at given value

  Uses Horner's method for efficient evaluation.

  # Arguments

   * `value` - Value to substitute for variable

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::CharacteristicPolynomial;

  let lambda = symbol!(lambda);
  let poly = CharacteristicPolynomial::new(
  vec![expr!(6), expr!(-5), expr!(1)],  // λ² - 5λ + 6
  lambda
  );

  let result = poly.evaluate(&expr!(2));  // 2² - 5(2) + 6 = 0
  assert_eq!(result, expr!(0));
  ``` */
  evaluate(value: JsExpression): JsExpression
  /** Adds two characteristic polynomials

  Note: This is polynomial addition, not matrix addition.
  Both polynomials must use the same variable.

  # Arguments

   * `poly1` - First polynomial
   * `poly2` - Second polynomial

  # Returns

  Sum of the two polynomials

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::matrices::eigenvalues::characteristic::{CharacteristicPolynomial, CharacteristicPolynomialBuilder};

  let lambda = symbol!(lambda);
  let builder = CharacteristicPolynomialBuilder;

  let poly1 = CharacteristicPolynomial::new(
  vec![expr!(1), expr!(2)],  // 1 + 2λ
  lambda.clone()
  );
  let poly2 = CharacteristicPolynomial::new(
  vec![expr!(3), expr!(4)],  // 3 + 4λ
  lambda.clone()
  );

  let sum = builder.add(&poly1, &poly2);  // 4 + 6λ
  assert_eq!(sum.coefficients.len(), 2);
  ``` */
  add(other: JsCharacteristicPolynomial): JsCharacteristicPolynomial
  cloneValue(): JsCharacteristicPolynomial
}

export declare class JsCharacteristicsError {
  equals(other: JsCharacteristicsError): boolean
  cloneValue(): JsCharacteristicsError
}

export declare class JsCharacteristicSolution {
  equals(other: JsCharacteristicSolution): boolean
  cloneValue(): JsCharacteristicSolution
}

export declare class JsChebyshevIntelligence {
  constructor()
  /** Get all Chebyshev polynomial properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is a Chebyshev polynomial */
  hasFunction(name: string): boolean
}

export declare class JsChebyshevT {
  static evaluate(n: number, x: number): number
  static recurrenceCoefficients(n: number): [number, number, number]
  static polynomial(n: number, var: symbol): JsExpression
}

export declare class JsChebyshevU {
  static recurrenceCoefficients(n: number): [number, number, number]
  static evaluate(n: number, x: number): number
  static polynomial(n: number, var: symbol): JsExpression
}

export declare class JsCholeskyDecomposition {
  equals(other: JsCholeskyDecomposition): boolean
  cloneValue(): JsCholeskyDecomposition
}

export declare class JsCommutativity {
  /** Can factors be sorted during canonicalization?

  Returns true only if commutativity is guaranteed. */
  canSort(): boolean
  equals(other: JsCommutativity): boolean
  cloneValue(): JsCommutativity
}

export declare class JsCompatibilityInfo {
  cloneValue(): JsCompatibilityInfo
}

export declare class JsComplexEigenDecomposition {
  equals(other: JsComplexEigenDecomposition): boolean
  cloneValue(): JsComplexEigenDecomposition
}

export declare class JsComplexEigenvalue {
  equals(other: JsComplexEigenvalue): boolean
  cloneValue(): JsComplexEigenvalue
}

export declare class JsComplexityEstimate {
  cloneValue(): JsComplexityEstimate
}

export declare class JsComputePriority {
  equals(other: JsComputePriority): boolean
  cloneValue(): JsComputePriority
}

export declare class JsComputeResult {
  cloneValue(): JsComputeResult
}

export declare class JsComputeTask {
  cloneValue(): JsComputeTask
}

export declare class JsConfigInfo {
  cloneValue(): JsConfigInfo
}

export declare class JsConstantCoeffSecondOrderSolver {
  constructor()
  cloneValue(): JsConstantCoeffSecondOrderSolver
}

export declare class JsConstantOfIntegration {
  equals(other: JsConstantOfIntegration): boolean
  cloneValue(): JsConstantOfIntegration
}

export declare class JsConvergenceResult {
  equals(other: JsConvergenceResult): boolean
  cloneValue(): JsConvergenceResult
}

export declare class JsCosSimplificationStrategy {
  name(): string
}

export declare class JsDefaultValidator {
  validatePerformance(name: string, benchmarkSize: number): JsValidationResult
}

export declare class JsDerivativeRule {
  cloneValue(): JsDerivativeRule
}

export declare class JsDerivativeRuleType {

}

export declare class JsDifferentialEquation {
  cloneValue(): JsDifferentialEquation
}

export declare class JsDifferentialExtension {
  equals(other: JsDifferentialExtension): boolean
  cloneValue(): JsDifferentialExtension
}

export declare class JsDomain {
  equals(other: JsDomain): boolean
  cloneValue(): JsDomain
}

export declare class JsEducationalMessageGenerator {
  /** Generate error explanation */
  static errorExplanation(category: JsMessageCategory, errorType: number, context: Record<string, string>): JsStep | null
  /** Generate linear equation explanation */
  static linearEquationSteps(equation: string, variable: string, solution: string): Array<JsStep>
  /** Generate quadratic equation explanation */
  static quadraticEquationSteps(equation: string, variable: string, a: string, b: string, c: string, solutions: string): Array<JsStep>
  /** Generate mathematical insight */
  static mathematicalInsight(variant: number, variable: string): JsStep | null
}

export declare class JsEducationalOdeSolver {
  constructor()
  canSolve(equation: JsExpression): boolean
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
}
export type JsEducationalODESolver = JsEducationalOdeSolver

export declare class JsEducationalPdeSolver {
  constructor()
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  canSolve(equation: JsExpression): boolean
}
export type JsEducationalPDESolver = JsEducationalPdeSolver

export declare class JsEigenDecomposition {
  equals(other: JsEigenDecomposition): boolean
  cloneValue(): JsEigenDecomposition
}

export declare class JsEigenvalueSolution {
  equals(other: JsEigenvalueSolution): boolean
  cloneValue(): JsEigenvalueSolution
}

export declare class JsElementaryIntelligence {
  constructor()
  /** Check if function is elementary */
  isElementaryFunction(name: string): boolean
  /** Get all elementary function properties

  Returns a HashMap of all elementary functions and their properties
  for integration with the universal registry. */
  getAllProperties(): Record<string, JsFunctionProperties>
}

export declare class JsElementaryProperties {
  cloneValue(): JsElementaryProperties
}

export declare class JsEquationAnalyzer {
  /** Analyze equation and determine type for solver dispatch */
  static analyze(equation: JsExpression, variable: symbol): JsEquationType
}

export declare class JsEquationType {
  equals(other: JsEquationType): boolean
  cloneValue(): JsEquationType
}

export declare class JsEvalContext {
  constructor()
  /** Control whether to simplify symbolically before numerical evaluation

  Consumes self and returns a new context with the specified simplification flag.

  # Arguments

   * `simplify` - Whether to call `simplify()` before `eval_numeric()`

  # Returns

  New context with updated simplification setting

  # Examples

  ```rust
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  // Disable simplification for performance
  let ctx = EvalContext::symbolic().with_simplify(false);
  assert!(!ctx.simplify_first);

  // Enable simplification for numerical stability
  let ctx = EvalContext::symbolic().with_simplify(true);
  assert!(ctx.simplify_first);
  ``` */
  withSimplify(simplify: boolean): JsEvalContext
  /** Create context for symbolic evaluation (no numerical conversion)

  Returns a context that performs variable substitution but keeps expressions
  in symbolic form. No numerical evaluation is performed.

  # Returns

  Context with:
  - No variable substitutions
  - Symbolic mode (numeric = false)
  - Default precision (53 bits)
  - No pre-simplification

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  let x = symbol!(x);
  let e = expr!((x ^ 2) + (2*x) + 1);

  let ctx = EvalContext::symbolic();
  let result = e.evaluate_with_context(&ctx).unwrap();
  // Result is still symbolic: x^2 + 2*x + 1
  ``` */
  static symbolic(): JsEvalContext
  /** Create context for numerical evaluation with substitutions

  Returns a context that substitutes variables and converts to numerical form.
  Simplification is enabled by default for numerical stability.

  # Arguments

   * `variables` - Map from symbol name to replacement expression

  # Returns

  Context with:
  - Provided variable substitutions
  - Numerical mode (numeric = true)
  - Default precision (53 bits for f64)
  - Pre-simplification enabled (simplify_first = true)

  # Examples

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;
  use std::collections::HashMap;

  let x = symbol!(x);
  let e = expr!((x ^ 2) + (2*x) + 1);

  let mut vars = HashMap::new();
  vars.insert("x".to_string(), expr!(3));

  let ctx = EvalContext::numeric(vars);
  let result = e.evaluate_with_context(&ctx).unwrap();
  // Result is numerical: 16 (= 3^2 + 2*3 + 1)
  ``` */
  static numeric(variables: Record<string, JsExpression>): JsEvalContext
  /** Set precision for numerical operations (bits)

  Consumes self and returns a new context with the specified precision.

  # Arguments

   * `precision` - Number of bits of precision (53 for f64, 128+ for arbitrary precision)

  # Returns

  New context with updated precision

  # Examples

  ```rust
  use mathhook_core::core::expression::eval_numeric::EvalContext;

  let ctx = EvalContext::symbolic().with_precision(128);
  assert_eq!(ctx.precision, 128);
  ``` */
  withPrecision(precision: number): JsEvalContext
  cloneValue(): JsEvalContext
}

export declare class JsEvaluationMethod {
  equals(other: JsEvaluationMethod): boolean
  cloneValue(): JsEvaluationMethod
}

export declare class JsEvaluationResult {
  cloneValue(): JsEvaluationResult
}

export declare class JsEvaluationStrategy {
  equals(other: JsEvaluationStrategy): boolean
  cloneValue(): JsEvaluationStrategy
}

export declare class JsExactOdeSolver {
  /** Find integrating factor for non-exact ODE

  Attempts to find integrating factor μ(x) or μ(y) to make ODE exact.

  # Arguments

   * `m` - Coefficient of dx
   * `n` - Coefficient of dy
   * `x` - Independent variable
   * `y` - Dependent variable

  # Returns

  Integrating factor if found */
  findIntegratingFactor(m: JsExpression, n: JsExpression, x: symbol, y: symbol): JsExpression | null
  /** Check if ODE is exact

  # Arguments

   * `m` - Coefficient of dx: M(x,y)
   * `n` - Coefficient of dy: N(x,y)
   * `x` - Independent variable
   * `y` - Dependent variable

  # Returns

  True if ∂M/∂y = ∂N/∂x

  # Examples

  ```rust
  use mathhook_core::calculus::ode::first_order::exact::ExactODESolver;
  use mathhook_core::{symbol, expr};

  let x = symbol!(x);
  let y = symbol!(y);

  // 2xy dx + x^2 dy = 0 is exact
  let m = expr!((2 * x) * y);
  let n = expr!(x ^ 2);

  let solver = ExactODESolver;
  assert!(solver.is_exact(&m, &n, &x, &y));
  ``` */
  isExact(m: JsExpression, n: JsExpression, x: symbol, y: symbol): boolean
}
export type JsExactODESolver = JsExactOdeSolver

export declare class JsExponentialIntelligence {
  constructor()
  /** Get all exponential function properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is exponential */
  hasFunction(name: string): boolean
}

export declare class JsExpression {
  contourIntegral(variable: symbol): JsExpression
  /** Create a division expression (symbolic, always succeeds)

  This constructor is for symbolic division where the denominator may be unknown
  or symbolic. It converts division to multiplication by the reciprocal: `a / b` → `a * b^(-1)`

  For numerical evaluation contexts where you need to detect division by zero,
  use `div_checked()` instead.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  // Symbolic division (denominator is unknown)
  let x = symbol!(x);
  let expr = Expression::div(Expression::integer(1), Expression::symbol(x));
  // Produces: 1 * x^(-1)

  // Constant division (still symbolic context)
  let expr = Expression::div(Expression::integer(3), Expression::integer(4));
  // Produces: 3 * 4^(-1), which simplifies to 3/4
  ``` */
  static div(numerator: JsExpression, denominator: JsExpression): JsExpression
  /** Create a complex number expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::complex(
  Expression::integer(3),
  Expression::integer(4),
  );
  ``` */
  static complex(real: JsExpression, imag: JsExpression): JsExpression
  /** Expand binomial expressions: (a + b)^n using binomial theorem

  For commutative terms, uses binomial theorem: C(n,k) * a^k * b^(n-k)
  For noncommutative terms, uses direct multiplication to preserve order */
  expandBinomial(a: JsExpression, b: JsExpression, n: number): JsExpression
  classify(): JsExpressionClass
  /** Detect if an expression is algebraically equivalent to zero */
  isAlgebraicZero(): boolean
  explainPolyGcd(other: JsExpression): JsStepByStepExplanation
  /** Create a power expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Applying power identities: `x^0` → `1`, `x^1` → `x`, `1^x` → `1`
  - Evaluating constant powers: `2^3` → `8`
  - Converting negative exponents to rationals: `x^(-1)` → `1/x`
  - Flattening nested powers: `(x^a)^b` → `x^(a*b)`
  - Handling special cases: `0^n` → `0` for positive n

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Power identities
  let x = expr!(x);
  let expression = Expression::pow(x.clone(), Expression::integer(1));
  assert_eq!(expression, x);

  let expression = Expression::pow(x.clone(), Expression::integer(0));
  assert_eq!(expression, Expression::integer(1));

  // Constant evaluation
  let expression = expr!(2 ^ 3);
  assert_eq!(expression, Expression::integer(8));

  // Nested power flattening
  let expression = Expression::pow(
  Expression::pow(x.clone(), Expression::integer(2)),
  Expression::integer(3),
  );
  // Produces x^6 in canonical form
  ``` */
  static pow(base: JsExpression, exponent: JsExpression): JsExpression
  /** Fast path: solve as polynomial equation with steps (skip classification) */
  solvePolynomialWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  explainPolyDivision(divisor: JsExpression, var: symbol): JsStepByStepExplanation
  findPoles(variable: symbol): Array<JsExpression>
  /** Check if this expression represents a mathematical function

  Returns true for expressions like sin(x), cos(x), etc.
  Now integrated with Universal Function Intelligence System */
  isFunction(): boolean
  /** Create factorial expression */
  static factorial(arg: JsExpression): JsExpression
  evalNumeric(precision: number): JsExpression
  /** Count occurrences of a variable in the expression

  Recursively counts how many times a specific variable symbol appears
  in the expression tree. This is useful for:
  - Determining if an expression is polynomial in a variable
  - Analyzing variable dependencies
  - Checking if a variable appears in an equation

  # Arguments

   * `variable` - The symbol to count occurrences of

  # Returns

  The number of times the variable appears in the expression

  # Examples

  Basic counting in simple expressions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let expr = Expression::mul(vec![
  Expression::integer(2),
  Expression::symbol(x.clone()),
  ]);
  assert_eq!(expr.count_variable_occurrences(&x), 1);
  ```

  Counting multiple occurrences:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // x^2 + 2*x + 1 has 2 occurrences of x (in x^2 and in 2*x)
  let expr = Expression::Add(Box::new(vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(1),
  ]));
  assert_eq!(expr.count_variable_occurrences(&x), 2);
  ```

  Counting in power expressions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // x^x has 2 occurrences (base and exponent)
  let expr = Expression::pow(
  Expression::symbol(x.clone()),
  Expression::symbol(x.clone())
  );
  assert_eq!(expr.count_variable_occurrences(&x), 2);
  ```

  Counting in functions:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // sin(x)
  let expr = Expression::function("sin", vec![Expression::symbol(x.clone())]);
  assert_eq!(expr.count_variable_occurrences(&x), 1);

  // f(x, x, 2) has 2 occurrences
  let expr2 = Expression::function("f", vec![
  Expression::symbol(x.clone()),
  Expression::symbol(x.clone()),
  Expression::integer(2),
  ]);
  assert_eq!(expr2.count_variable_occurrences(&x), 2);
  ```

  Zero occurrences when variable is not present:
  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let y = symbol!(y);
  let expr = Expression::symbol(y.clone());
  assert_eq!(expr.count_variable_occurrences(&x), 0);
  ``` */
  countVariableOccurrences(variable: symbol): number
  matrixDeterminant(): JsExpression
  simplifyMatrix(): JsExpression
  /** Create an identity matrix expression

  # Examples

  ```rust
  use mathhook_core::Expression;
  use mathhook_core::matrices::operations::MatrixOperations;

  let identity = Expression::identity_matrix(3);
  assert!(identity.is_identity_matrix());
  ``` */
  static identityMatrix(size: number): JsExpression
  complexSubtract(other: JsExpression): JsExpression
  /** Fast path: solve as linear equation (skip classification)

  Directly solves equations of the form `ax + b = 0` without running
  equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing the solution x = -b/a */
  solveLinear(variable: symbol): JsSolverResult
  /** Create an Euler-Mascheroni constant (gamma) expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let gamma = Expression::euler_gamma();
  ``` */
  static eulerGamma(): JsExpression
  toPolarForm(): [JsExpression, JsExpression]
  /** Find all variables in expression

  Returns a vector of all unique Symbol nodes found in the expression tree.
  This is used by GCD algorithms to detect univariate polynomials. */
  findVariables(): Array<symbol>
  limitAtInfinity(variable: symbol): JsExpression
  polynomialContent(): JsExpression
  /** Compute the argument (phase angle) of a complex number

  Returns the angle θ = atan2(im, re) in radians, in the range (-π, π].
  This is the principal value of the argument.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(1), expr!(1));
  let angle = z.arg();
  ``` */
  arg(): JsExpression
  /** Create a scalar matrix expression (c*I)

  # Examples

  ```rust
  use mathhook_core::Expression;

  let scalar = Expression::scalar_matrix(3, Expression::integer(5));
  // Creates 5*I (5 times the 3x3 identity matrix)
  ``` */
  static scalarMatrix(size: number, scalarValue: JsExpression): JsExpression
  toWolframWithDepth(context: JsWolframContext, depth: number): string
  matrixTranspose(): JsExpression
  /** Polynomial division using optimized algorithms */
  polynomialDivide(divisor: JsExpression): [JsExpression, JsExpression]
  polynomialVariables(): Array<symbol>
  limit(variable: symbol, point: JsExpression): JsExpression
  /** Create a limit expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::limit(
  expr!(x),
  symbol!(x),
  Expression::integer(0),
  );
  ``` */
  static limitWithExpressionVariablePoint(expression: JsExpression, variable: symbol, point: JsExpression): JsExpression
  /** Fast path: solve as quadratic equation (skip classification)

  Directly solves equations of the form `ax^2 + bx + c = 0` using the
  quadratic formula without running equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing solutions from the quadratic formula */
  solveQuadratic(variable: symbol): JsSolverResult
  isPureImaginary(): boolean
  primitivePart(): JsExpression
  /** Combine like terms in the expression */
  combineLikeTerms(): JsExpression
  /** Create a complex number from polar form

  Converts polar coordinates (magnitude, angle) to rectangular form (a + bi).
  The angle should be in radians.

  # Arguments

   * `magnitude` - The magnitude (r) of the complex number
   * `angle` - The angle (θ) in radians

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let magnitude = expr!(5);
  let angle = Expression::pi();
  let z = Expression::from_polar(magnitude, angle);
  ``` */
  static fromPolar(magnitude: JsExpression, angle: JsExpression): JsExpression
  /** Create an e constant expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let e = Expression::e();
  ``` */
  static e(): JsExpression
  explainFiniteSum(variable: symbol, start: JsExpression, end: JsExpression): JsStepByStepExplanation
  /** Fast path: solve as ODE with steps (skip classification) */
  solveOdeWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Factor out the GCD from an expression

  Currently a stub that returns the original expression.
  Will be implemented to extract common factors.

  # Examples

  ```rust
  use mathhook_core::{expr, Expression};

  let expr = Expression::add(vec![
  expr!(6*x),
  expr!(9),
  ]);
  let factored = expr.factor_gcd();
  ``` */
  factorGcd(): JsExpression
  /** Factor out GCD from expression */
  factorGcdAll(): JsExpression
  /** Format expression with specific language/format

  # Examples
  ```rust
  use mathhook_core::core::Expression;
  use mathhook_core::formatter::MathLanguage;
  use mathhook_core::expr;

  let x_expr = expr!(x);
  let latex = x_expr.format_as(MathLanguage::LaTeX).unwrap();
  let simple = x_expr.format_as(MathLanguage::Simple).unwrap();
  let wolfram = x_expr.format_as(MathLanguage::Wolfram).unwrap();
  ``` */
  formatAs(language: JsMathLanguage): string
  /** Simplify trigonometric expressions */
  simplifyTrigonometric(): JsExpression
  complexDivide(other: JsExpression): JsExpression
  /** Negate an expression */
  negate(): JsExpression
  /** Check if expression is a valid mathematical expression */
  isValidExpression(): boolean
  matrixScalarMultiply(scalar: JsExpression): JsExpression
  /** Create an imaginary unit expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let i = Expression::i();
  ``` */
  static i(): JsExpression
  matrixTrace(): JsExpression
  /** Multiply rational expressions: (a/b) * (c/d) = (ac)/(bd) */
  multiplyRationals(other: JsExpression): JsExpression
  /** Create a multiplication expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Flattening nested multiplications: `(a * b) * c` → `a * b * c`
  - Removing identity elements: `x * 1` → `x`
  - Handling zero: `x * 0` → `0`
  - Sorting factors in canonical order: `y * x` → `x * y`
  - Evaluating constant subexpressions: `2 * 3` → `6`
  - Converting division to multiplication: `a / b` → `a * b^(-1)`

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Constant folding
  let expression = Expression::mul(vec![
  Expression::integer(2),
  Expression::integer(3),
  ]);
  assert_eq!(expression, Expression::integer(6));

  // Identity element removal
  let x = expr!(x);
  let expr = Expression::mul(vec![x.clone(), Expression::integer(1)]);
  assert_eq!(expr, x);

  // Zero handling
  let expression = Expression::mul(vec![x.clone(), Expression::integer(0)]);
  assert_eq!(expression, Expression::integer(0));

  // Commutativity (canonical ordering)
  let y = expr!(y);
  let expr1 = Expression::mul(vec![x.clone(), y.clone()]);
  let expr2 = Expression::mul(vec![y.clone(), x.clone()]);
  assert_eq!(expr1, expr2); // Both produce x * y in canonical order
  ``` */
  static mul(factors: Array<JsExpression>): JsExpression
  /** Get the symbol if this is a simple symbol expression */
  asSymbol(): symbol | null
  isIntpolyCompatible(): boolean
  integrate(variable: symbol, depth: number): JsExpression
  polyQuo(divisor: JsExpression, var: symbol): JsExpression
  complexArgument(): JsExpression
  /** Get function intelligence properties if available

  Seamless integration between core expressions and function intelligence */
  getFunctionIntelligence(): JsFunctionProperties | null
  /** Fast path: solve as quadratic equation with steps (skip classification) */
  solveQuadraticWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  powerSeriesCoefficients(variable: symbol, point: JsExpression, order: number): Array<JsExpression>
  /** Create a function expression

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let expression = Expression::function("sin", vec![expr!(x)]);
  ``` */
  static function(name: string, args: Array<JsExpression>): JsExpression
  /** Separate variables and constants */
  separateConstants(): [JsExpression, JsExpression]
  /** Factor out the GCD from an expression */
  factorOutGcd(): JsExpression
  polyRem(divisor: JsExpression, var: symbol): JsExpression
  matrixMultiply(other: JsExpression): JsExpression
  polynomialResultant(other: JsExpression, var: symbol): JsExpression
  /** Polynomial remainder */
  polynomialRemainder(divisor: JsExpression): JsExpression
  polynomialLeadingCoefficient(var: symbol): JsExpression
  limitAtNegativeInfinity(variable: symbol): JsExpression
  /** Solve equation for a variable with auto-detection

  Solves the equation `self = 0` for the given variable.
  Automatically detects equation type (linear, quadratic, ODE, etc.) and
  routes to the appropriate solver. For performance-critical code where
  you already know the equation type, use the fast path methods instead:
  - `solve_linear()`
  - `solve_quadratic()`
  - `solve_polynomial()`
  - `solve_ode()`
  - `solve_pde()`
  - `solve_system()`

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing solutions or error information

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};
  use mathhook_core::algebra::solvers::SolverResult;

  let x = symbol!(x);
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  let result = equation.solve(&x);
  match result {
    SolverResult::Single(solution) => {
      assert_eq!(solution, Expression::integer(3));
    }
    _ => panic!("Expected single solution"),
  }
  ``` */
  solve(variable: symbol): JsSolverResult
  /** Compute GCD and cofactors

  Returns a tuple of (gcd, cofactor_a, cofactor_b) where:
  - gcd is the greatest common divisor
  - cofactor_a = a / gcd
  - cofactor_b = b / gcd

  # Arguments

   * `other` - The expression to compute cofactors with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let (gcd, cofactor_a, cofactor_b) = a.cofactors(&b);
  assert_eq!(gcd, expr!(4));
  assert_eq!(cofactor_a, expr!(3));
  assert_eq!(cofactor_b, expr!(2));
  ``` */
  cofactors(other: JsExpression): [JsExpression, JsExpression, JsExpression]
  /** Compute GCD and cofactors: returns (gcd, a/gcd, b/gcd) */
  cofactorsWithOther(other: JsExpression): [JsExpression, JsExpression, JsExpression]
  nthDerivative(variable: symbol, order: number): JsExpression
  /** Create a diagonal matrix expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let diag = Expression::diagonal_matrix(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  ``` */
  static diagonalMatrix(diagonalElements: Array<JsExpression>): JsExpression
  /** Extract rational coefficient as string parts (FFI-friendly, no BigRational)

  Returns (numerator, denominator, remainder) where numerator/denominator
  is the rational coefficient and remainder is the non-rational part. */
  extractRationalParts(): [string, string, JsExpression]
  isImaginary(): boolean
  /** Check if the expression is one (robust version with simplification)

  This method simplifies the expression first before checking if it equals one.
  It correctly detects one for expressions like:
  - Literal ones: `1`, `1.0`, `2/2`
  - Symbolic ones: `x / x`, `x^0`, `cos(0)`
  - Simplified ones: `(x + 1) / (x + 1)`

  # Performance Note

  This method calls `simplify()`, which may be expensive for complex expressions.
  For performance-critical code where you only need to check literal ones,
  use `is_one_fast()` instead.

  # Examples

  ```rust
  use mathhook_core::simplify::Simplify;
  use mathhook_core::Expression;

  // Literal one
  assert!(Expression::integer(1).is_one());

  // Symbolic one after simplification
  let expr = Expression::pow(Expression::integer(5), Expression::integer(0));
  assert!(expr.is_one());
  ``` */
  isOne(): boolean
  /** Evaluate method calls on expressions

  This handles method calls like matrix.det(), matrix.trace(), etc.
  by calling the appropriate methods on the underlying objects. */
  evaluateMethodCall(): JsExpression
  /** Get matrix dimensions for any matrix type

  Returns (rows, columns) for all matrix types.

  # Examples

  ```rust
  use mathhook_core::Expression;

  let matrix = Expression::matrix(vec![
  vec![Expression::integer(1), Expression::integer(2)],
  vec![Expression::integer(3), Expression::integer(4)]
  ]);
  assert_eq!(matrix.matrix_dimensions(), Some((2, 2)));

  let identity = Expression::identity_matrix(3);
  assert_eq!(identity.matrix_dimensions(), Some((3, 3)));
  ``` */
  matrixDimensions(): [number, number] | null
  /** Simplify logarithmic expressions */
  simplifyLogarithms(): JsExpression
  /** Create a relation expression

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};
  use mathhook_core::core::expression::RelationType;

  let relation = Expression::relation(
  expr!(x),
  expr!(5),
  RelationType::Greater,
  );
  ``` */
  static relation(left: JsExpression, right: JsExpression, relationType: JsRelationType): JsExpression
  /** Create a golden ratio (phi) expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let phi = Expression::golden_ratio();
  ``` */
  static goldenRatio(): JsExpression
  /** Solve equation with step-by-step educational explanation

  Solves the equation `self = 0` for the given variable and generates
  an educational explanation showing each solving step. Use this when you need
  to teach or explain the solving process. For performance-critical code where
  you only need the answer, use `solve()` instead.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  A tuple of (solver result, step-by-step explanation)

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  let (result, explanation) = equation.solve_with_steps(&x);
  // The explanation contains educational content showing how to solve the equation
  ``` */
  solveWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  solveWithStepsWithVar(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  definiteIntegrate(variable: symbol, lower: JsExpression, upper: JsExpression): JsExpression
  /** Convert to rational form (numerator/denominator) */
  toRationalForm(): [JsExpression, JsExpression]
  subs(old: JsExpression, new: JsExpression): JsExpression
  /** Compute transpose of matrix expression

  For symbolic matrix expressions, this implements proper order reversal
  according to the mathematical rule: (AB)^T = B^T A^T

  # Mathematical Rules

  - For products: (AB)^T = B^T A^T (order reverses)
  - For sums: (A+B)^T = A^T + B^T (distributes)
  - For scalars: scalar^T = scalar (no change)
  - For matrix symbols: A^T creates transpose function

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let a = symbol!(A; matrix);
  let b = symbol!(B; matrix);

  let product = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);

  let transposed = product.transpose();
  ``` */
  transpose(): JsExpression
  quoPolynomial(divisor: JsExpression, var: symbol): JsExpression
  /** Expand the expression by distributing multiplication over addition */
  expand(): JsExpression
  /** Create a product expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::product(
  expr!(i),
  symbol!(i),
  Expression::integer(1),
  Expression::integer(10),
  );
  ``` */
  static product(expression: JsExpression, variable: symbol, start: JsExpression, end: JsExpression): JsExpression
  /** Convert to polar form (magnitude, angle)

  Returns (r, θ) where z = r·e^(iθ). The angle is in radians,
  in the range (-π, π].

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let (magnitude, angle) = z.to_polar();
  ``` */
  toPolar(): [JsExpression, JsExpression]
  polynomialGcd(other: JsExpression): JsExpression
  /** Simplify complex rational expressions */
  simplifyComplexRational(): JsExpression
  finiteSum(variable: symbol, start: JsExpression, end: JsExpression): JsExpression
  /** Check if this expression is a negative number

  Returns true if the expression is a negative integer, rational, or float.
  Returns false for symbolic expressions (even if they might evaluate to negative).

  # Examples

  ```rust
  use mathhook_core::Expression;

  assert!(Expression::integer(-5).is_negative_number());
  assert!(Expression::rational(-1, 2).is_negative_number());
  assert!(!Expression::integer(5).is_negative_number());
  assert!(!Expression::symbol("x").is_negative_number()); // Symbolic, not a number
  ``` */
  isNegativeNumber(): boolean
  /** Simplify factorial expressions */
  simplifyFactorial(): JsExpression
  /** High-level evaluation with context

  This is the PRIMARY user-facing evaluation method following SymPy's two-level architecture.
  It handles:
  1. Variable substitution
  2. Optional symbolic simplification
  3. Optional numerical evaluation

  This mirrors SymPy's `evalf(subs={...}, ...)` high-level API.

  # Arguments

   * `context` - Evaluation context (variables, numeric mode, precision, etc.)

  # Returns

  Evaluated expression

  # Errors

  Returns `MathError` for domain violations, undefined operations, etc.

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};
  use mathhook_core::core::expression::eval_numeric::EvalContext;
  use std::collections::HashMap;

  // Symbolic evaluation (no substitution)
  let x = symbol!(x);
  let f = expr!(x ^ 2);
  let result = f.evaluate_with_context(&EvalContext::symbolic()).unwrap();
  assert_eq!(result, expr!(x ^ 2)); // Unchanged

  // Numerical evaluation with substitution
  let mut vars = HashMap::new();
  vars.insert("x".to_string(), expr!(3));
  let ctx = EvalContext::numeric(vars);
  let result = f.evaluate_with_context(&ctx).unwrap();
  assert_eq!(result, expr!(9));
  ``` */
  evaluateWithContext(context: JsEvalContext): JsExpression
  polynomialPrimitivePart(): JsExpression
  /** Compute the complex conjugate

  Returns the complex conjugate (a + bi → a - bi). For non-complex
  expressions, returns the expression itself.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let conjugate = z.conjugate();
  if let Expression::Complex(data) = conjugate {
    assert_eq!(data.real, expr!(3));
    assert_eq!(data.imag, expr!(-4));
  }
  ``` */
  conjugate(): JsExpression
  polynomialDiscriminant(var: symbol): JsExpression
  /** Check if the expression is zero (robust version with simplification)

  This method simplifies the expression first before checking if it equals zero.
  It correctly detects zero for expressions like:
  - Literal zeros: `0`, `0.0`, `0/1`
  - Symbolic zeros: `x - x`, `0 * y`, `sin(0)`
  - Simplified zeros: `(x + 1) - (x + 1)`

  # Performance Note

  This method calls `simplify()`, which may be expensive for complex expressions.
  For performance-critical code where you only need to check literal zeros,
  use `is_zero_fast()` instead.

  # Examples

  ```rust
  use mathhook_core::simplify::Simplify;
  use mathhook_core::Expression;

  // Literal zero
  assert!(Expression::integer(0).is_zero());

  // Symbolic zero after simplification
  let expr = Expression::mul(vec![Expression::integer(0), Expression::integer(5)]);
  assert!(expr.is_zero());
  ``` */
  isZero(): boolean
  /** Factor common elements */
  factorCommon(): JsExpression
  isDiagonal(): boolean
  maclaurinSeries(variable: symbol, order: number): JsExpression
  /** Create a commutator: [A, B] = AB - BA

  The commutator measures the failure of two operators to commute.
  It is zero for commutative operators and nonzero for noncommutative.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let A = Expression::symbol(symbol!(A; matrix));
  let B = Expression::symbol(symbol!(B; matrix));
  let comm = Expression::commutator(A.clone(), B.clone());
  // Represents: AB - BA
  ```

  # Mathematical Properties

  - [A, B] = -[B, A] (antisymmetry)
  - [A, A] = 0 (self-commutator is zero)
  - Jacobi identity: [A, [B, C]] + [B, [C, A]] + [C, [A, B]] = 0

  # Quantum Mechanics Example

  ```rust
  use mathhook_core::{Expression, symbol};

  let x = Expression::symbol(symbol!(x; operator));
  let p = Expression::symbol(symbol!(p; operator));
  let comm = Expression::commutator(x, p);
  // In quantum mechanics: [x, p] = ih (canonical commutation relation)
  ``` */
  static commutator(a: JsExpression, b: JsExpression): JsExpression
  /** Convert evaluated expression to f64

  First evaluates the expression, then attempts to convert the result to f64.
  Returns error if the result is non-numerical (symbolic).

  # Returns

  f64 value if expression evaluates to a number

  # Errors

  Returns `MathError::NonNumericalResult` if evaluation produces symbolic expression

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};

  // Numerical expression
  let e = expr!(2 + 3);
  assert_eq!(e.evaluate_to_f64().unwrap(), 5.0);

  // Symbolic expression fails
  let x = symbol!(x);
  assert!(x.evaluate_to_f64().is_err());
  ``` */
  evaluateToF64(): number
  /** Extract the imaginary part of a complex number

  Returns the imaginary component of a complex expression. For non-complex
  expressions, returns zero.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let imag_part = z.imag();
  assert_eq!(imag_part, expr!(4));
  ``` */
  imag(): JsExpression
  /** Check if expression is any kind of matrix */
  isMatrix(): boolean
  /** Create an addition expression in canonical form

  This constructor automatically produces a canonical form expression by:
  - Flattening nested additions: `(a + b) + c` → `a + b + c`
  - Removing identity elements: `x + 0` → `x`
  - Combining like terms: `2x + 3x` → `5x`
  - Sorting terms in canonical order: `y + x` → `x + y`
  - Evaluating constant subexpressions: `2 + 3` → `5`

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  // Constant folding
  let expression = Expression::add(vec![
  Expression::integer(1),
  Expression::integer(2),
  ]);
  assert_eq!(expression, Expression::integer(3));

  // Identity element removal
  let x = expr!(x);
  let expression = Expression::add(vec![x.clone(), Expression::integer(0)]);
  assert_eq!(expression, x);

  // Commutativity (canonical ordering)
  let y = expr!(y);
  let expr1 = Expression::add(vec![x.clone(), y.clone()]);
  let expr2 = Expression::add(vec![y.clone(), x.clone()]);
  assert_eq!(expr1, expr2); // Both produce x + y in canonical order
  ``` */
  static add(terms: Array<JsExpression>): JsExpression
  /** Create a complex number from polar form

  Converts polar coordinates (magnitude, angle) to rectangular form (a + bi).

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let magnitude = expr!(5);
  let angle = Expression::pi();
  let z = Expression::from_polar_form(magnitude, angle);
  ``` */
  static fromPolarForm(magnitude: JsExpression, angle: JsExpression): JsExpression
  /** Create an infinity expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let inf = Expression::infinity();
  ``` */
  static infinity(): JsExpression
  /** Generate step-by-step explanation for expansion */
  explainExpansion(): JsStepByStepExplanation
  derivativeWithSteps(variable: symbol, order: number): JsStepByStepExplanation
  /** Create an integral expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::integral(
  expr!(x),
  symbol!(x),
  );
  ``` */
  static integral(integrand: JsExpression, variable: symbol): JsExpression
  matrixInverse(): JsExpression
  /** Fast path: solve matrix equation with steps (skip classification) */
  solveMatrixEquationWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  isReal(): boolean
  /** Compute commutativity of this expression

  Commutativity is inferred from the symbols and operations:
  - Numbers, constants: Commutative
  - Symbols: Depends on symbol type (Scalar → Commutative, Matrix/Operator/Quaternion → Noncommutative)
  - Mul: Noncommutative if ANY factor is noncommutative
  - Add, Pow, Function: Depends on subexpressions

  # Examples

  Basic scalar symbols (commutative):
  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::expression::Expression;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  let y = Symbol::scalar("y");
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::symbol(y.clone()),
  ]);
  assert_eq!(expr.commutativity(), Commutativity::Commutative);
  ```

  Matrix symbols (noncommutative):
  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::expression::Expression;
  use mathhook_core::core::commutativity::Commutativity;

  let a = Symbol::matrix("A");
  let b = Symbol::matrix("B");
  let expr = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);
  assert_eq!(expr.commutativity(), Commutativity::Noncommutative);
  ``` */
  commutativity(): JsCommutativity
  /** Compute inverse of matrix expression

  For symbolic matrix expressions, this implements proper order reversal
  according to the mathematical rule: (AB)^(-1) = B^(-1) A^(-1)

  # Mathematical Rules

  - For products: (AB)^(-1) = B^(-1) A^(-1) (order reverses)
  - For matrix symbols: A^(-1) creates inverse function
  - For identity: I^(-1) = I
  - For scalars: a^(-1) = 1/a (reciprocal)

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let a = symbol!(A; matrix);
  let b = symbol!(B; matrix);

  let product = Expression::mul(vec![
  Expression::symbol(a.clone()),
  Expression::symbol(b.clone()),
  ]);

  let inverse = product.inverse();
  ``` */
  inverse(): JsExpression
  /** Evaluate expression with domain checking

  Computes numerical values from expressions while validating mathematical
  domain constraints. Returns `Result<Expression, MathError>` to handle
  domain violations gracefully.

  # Evaluation vs Simplification

   **Use `evaluate()` when:** You need numerical results with domain validation
   **Use `simplify()` when:** You need algebraic reduction without domain checking
   **Use `evaluate_with_context()` when:** You need variable substitution + computation

  # Domain Constraints Checked

  - `sqrt(x)`: Requires x >= 0 in real domain
  - `log(x)`: Requires x > 0 (pole at 0)
  - `tan(x)`: Has poles at π/2 + nπ
  - `arcsin(x)`, `arccos(x)`: Require |x| <= 1 in real domain
  - `csc(x)`, `sec(x)`, `cot(x)`: Have poles where sin/cos/tan = 0
  - Division by zero: Checked in `x/y` and `x^(-n)` for n > 0

  # Returns

  - `Ok(Expression)`: Evaluated result (numerical or symbolic if can't evaluate)
  - `Err(MathError::DomainError)`: Domain constraint violated
  - `Err(MathError::DivisionByZero)`: Division by zero detected

  # Examples

  ## Successful Evaluation

  ```rust
  use mathhook_core::{Expression, MathError};

  // Constants evaluate to numbers
  let sum = Expression::add(vec![Expression::integer(2), Expression::integer(3)]);
  assert_eq!(sum.evaluate().unwrap(), Expression::integer(5));

  let product = Expression::mul(vec![Expression::integer(2), Expression::integer(3), Expression::integer(4)]);
  assert_eq!(product.evaluate().unwrap(), Expression::integer(24));

  // Special values
  let sin_zero = Expression::function("sin".to_string(), vec![Expression::integer(0)]);
  assert_eq!(sin_zero.evaluate().unwrap(), Expression::integer(0));
  ```

  ## Domain Errors

  ```rust,ignore
  use mathhook_core::{expr, Expression, MathError};

  // sqrt requires non-negative input
  let sqrt_neg = Expression::function("sqrt".to_string(), vec![Expression::integer(-1)]);
  assert!(matches!(
  sqrt_neg.evaluate(),
  Err(MathError::Pole { .. })
  ));

  // log has pole at 0
  assert!(matches!(
  expr!(log(0)).evaluate(),
  Err(MathError::Pole { .. })
  ));

  // Division by zero
  assert!(matches!(
  expr!(1 / 0).evaluate(),
  Err(MathError::DivisionByZero)
  ));
  ```

  ## Symbolic Results (No Variables to Substitute)

  ```rust
  use mathhook_core::{expr, symbol};
  use mathhook_core::simplify::Simplify;

  let x = symbol!(x);

  // Can't evaluate without variable value - returns simplified symbolic
  let result = expr!(x + 1).evaluate().unwrap();
  assert_eq!(result, expr!(x + 1).simplify());

  // For variable substitution, use evaluate_with_context() instead
  ```

  ## Handling Errors

  ```rust
  use mathhook_core::{Expression, MathError};

  let sqrt_neg = Expression::function("sqrt".to_string(), vec![Expression::integer(-1)]);
  match sqrt_neg.evaluate() {
    Ok(result) => println!("Result: {}", result),
    Err(MathError::DomainError { operation, value, reason }) => {
      eprintln!("Domain error in {}: {} ({})", operation, value, reason);
    }
    Err(e) => eprintln!("Other error: {:?}", e),
  }
  ``` */
  evaluate(): JsExpression
  /** Generate step-by-step explanation for factorization */
  explainFactorization(): JsStepByStepExplanation
  leadingCoefficient(var: symbol): JsExpression
  /** Fast path: solve as ordinary differential equation (skip classification)

  Directly solves ODEs using the cached ODE solver registry without running
  equation type classification. Supports separable, linear, and homogeneous
  first-order ODE types.

  Uses a static cached registry for optimal performance on repeated calls.

  # Arguments

   * `dependent` - The dependent variable (e.g., y)
   * `independent` - The independent variable (e.g., x)

  # Returns

  The solver result containing the ODE solution */
  solveOde(dependent: symbol, independent: symbol): JsSolverResult
  laurentSeries(variable: symbol, point: JsExpression, order: number): JsExpression
  /** Create an interval expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let interval = Expression::interval(
  Expression::integer(0),
  Expression::integer(10),
  true,
  false,
  );
  ``` */
  static interval(start: JsExpression, end: JsExpression, startInclusive: boolean, endInclusive: boolean): JsExpression
  /** Fast literal zero check without simplification

  This is a performance-optimized version that only checks if the expression
  is literally `Number(0)`. It does NOT simplify the expression first.

  Use this in performance-critical loops where you know the expression
  is already in simplified form, or where you specifically want to check
  for literal zeros only.

  # Examples

  ```rust
  use mathhook_core::Expression;

  // Detects literal zero
  assert!(Expression::integer(0).is_zero_fast());

  // Mul constructor auto-simplifies, so this IS detected
  let expr = Expression::mul(vec![Expression::integer(0), Expression::integer(5)]);
  assert!(expr.is_zero_fast()); // Simplified to 0 by constructor

  // Example of what is_zero_fast() does NOT detect (without simplification):
  // If we had a raw unsimplified Mul expression, is_zero_fast() wouldn't detect it
  ``` */
  isZeroFast(): boolean
  /** Create a set expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let set = Expression::set(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3),
  ]);
  ``` */
  static set(elements: Array<JsExpression>): JsExpression
  /** Create an anticommutator: {A, B} = AB + BA

  The anticommutator is the symmetric combination of two operators.

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol};

  let A = Expression::symbol(symbol!(A; matrix));
  let B = Expression::symbol(symbol!(B; matrix));
  let anticomm = Expression::anticommutator(A.clone(), B.clone());
  // Represents: AB + BA
  ```

  # Mathematical Properties

  - {A, B} = {B, A} (symmetry)
  - {A, A} = 2A^2 (self-anticommutator)

  # Physics Example

  ```rust
  use mathhook_core::{Expression, symbol};

  let sigma_x = Expression::symbol(symbol!(sigma_x; operator));
  let sigma_y = Expression::symbol(symbol!(sigma_y; operator));
  let anticomm = Expression::anticommutator(sigma_x, sigma_y);
  // For Pauli matrices: {sigma_x, sigma_y} = 0
  ``` */
  static anticommutator(a: JsExpression, b: JsExpression): JsExpression
  limitDirected(variable: symbol, point: JsExpression, direction: JsLimitDirection): JsExpression
  explainInfiniteSum(variable: symbol, start: JsExpression): JsStepByStepExplanation
  /** Collect and combine all like terms */
  collectTerms(): JsExpression
  /** Create a float expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::float(3.14159);
  ``` */
  static float(value: number): JsExpression
  /** Detect common patterns that equal zero */
  detectZeroPatterns(): boolean
  explainPolyFactorization(var: symbol): JsStepByStepExplanation
  /** Create a definite integral expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::definite_integral(
  expr!(x),
  symbol!(x),
  Expression::integer(0),
  Expression::integer(1),
  );
  ``` */
  static definiteIntegral(integrand: JsExpression, variable: symbol, start: JsExpression, end: JsExpression): JsExpression
  taylorSeries(variable: symbol, point: JsExpression, order: number): JsExpression
  /** Create a negative infinity expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let neg_inf = Expression::negative_infinity();
  ``` */
  static negativeInfinity(): JsExpression
  polynomialLcm(other: JsExpression): JsExpression
  /** Simplify rational expressions by canceling common factors */
  simplifyRational(): JsExpression
  /** Create an undefined expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let undef = Expression::undefined();
  ``` */
  static undefined(): JsExpression
  divPolynomial(divisor: JsExpression, var: symbol): [JsExpression, JsExpression]
  derivative(variable: symbol): JsExpression
  /** Create a derivative expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::derivative(
  Expression::pow(expr!(x), Expression::integer(2)),
  symbol!(x),
  1,
  );
  ``` */
  static derivativeWithExpressionVariableOrder(expression: JsExpression, variable: symbol, order: number): JsExpression
  isDifferentiable(variable: symbol): boolean
  /** Fast path: solve as linear equation with steps (skip classification) */
  solveLinearWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  isPolynomial(): boolean
  containsVariable(symbol: symbol): boolean
  polynomialCofactors(other: JsExpression): [JsExpression, JsExpression, JsExpression]
  /** Check if this expression is a positive number

  Returns true if the expression is a positive integer, rational, or float.
  Returns false for symbolic expressions (even if they might evaluate to positive).

  # Examples

  ```rust
  use mathhook_core::Expression;

  assert!(Expression::integer(5).is_positive_number());
  assert!(Expression::rational(1, 2).is_positive_number());
  assert!(!Expression::integer(-5).is_positive_number());
  assert!(!Expression::symbol("x").is_positive_number()); // Symbolic, not a number
  ``` */
  isPositiveNumber(): boolean
  matrixPower(exponent: JsExpression): JsExpression
  content(): JsExpression
  matrixAdd(other: JsExpression): JsExpression
  /** Try to simplify expression to zero if it's algebraically zero */
  simplifyToZero(): JsExpression | null
  polyDiv(divisor: JsExpression, var: symbol): [JsExpression, JsExpression]
  /** Create a zero matrix expression

  # Examples

  ```rust
  use mathhook_core::matrices::operations::MatrixOperations;
  use mathhook_core::Expression;

  let zero = Expression::zero_matrix(2, 3);
  assert!(zero.is_zero_matrix());
  ``` */
  static zeroMatrix(rows: number, cols: number): JsExpression
  /** Check if this expression is a specific symbol

  Convenience method for pattern matching against a specific symbol.
  More readable than inline matches! pattern in complex conditions.

  # Arguments

   * `symbol` - The symbol to check against

  # Returns

  True if this expression is exactly the given symbol

  # Examples

  ```
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let y = symbol!(y);
  let expr = Expression::symbol(x.clone());

  assert!(expr.is_symbol_matching(&x));
  assert!(!expr.is_symbol_matching(&y));
  ``` */
  isSymbolMatching(symbol: symbol): boolean
  isZeroMatrix(): boolean
  matrixSubtract(other: JsExpression): JsExpression
  isIdentityMatrix(): boolean
  /** Create natural logarithm expression */
  static ln(arg: JsExpression): JsExpression
  /** Create a pi constant expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let pi = Expression::pi();
  ``` */
  static pi(): JsExpression
  /** Convert to LaTeX representation for solvers (avoid conflict) */
  solverToLatex(): string
  infiniteSum(variable: symbol, start: JsExpression): JsExpression
  isDivisibleBy(divisor: JsExpression, var: symbol): boolean
  /** Factor difference of squares: a^2 - b^2 = (a + b)(a - b) */
  factorDifferenceOfSquares(a: JsExpression, b: JsExpression): JsExpression
  /** Create a square root expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let sqrt_2 = Expression::sqrt(Expression::integer(2));
  ``` */
  static sqrt(arg: JsExpression): JsExpression
  degree(var: symbol): number | null
  remPolynomial(divisor: JsExpression, var: symbol): JsExpression
  /** Factor the expression by extracting common factors */
  factor(): JsExpression
  complexAdd(other: JsExpression): JsExpression
  /** Create a sum expression

  # Examples

  ```rust
  use mathhook_core::{Expression, symbol, expr};

  let expr = Expression::sum(
  expr!(i),
  symbol!(i),
  Expression::integer(1),
  Expression::integer(10),
  );
  ``` */
  static sum(expression: JsExpression, variable: symbol, start: JsExpression, end: JsExpression): JsExpression
  residue(variable: symbol, pole: JsExpression): JsExpression
  /** Compute the least common multiple of two expressions

  For integer expressions, computes the mathematical LCM.
  For other expressions, returns the first expression.

  # Arguments

   * `other` - The expression to compute LCM with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let lcm = a.lcm(&b);
  assert_eq!(lcm, expr!(24));
  ```

  ```rust
  use mathhook_core::expr;

  // LCM with zero is zero
  let a = expr!(0);
  let b = expr!(15);
  let lcm = a.lcm(&b);
  assert_eq!(lcm, expr!(0));
  ``` */
  lcm(other: JsExpression): JsExpression
  /** Least Common Multiple */
  lcmWithOther(other: JsExpression): JsExpression
  simplify(): JsExpression
  flattenAddTerms(): Array<JsExpression>
  /** Fast path: solve as polynomial equation (skip classification)

  Directly solves polynomial equations of degree 3+ (cubic, quartic, etc.)
  without running equation type classification.

  # Arguments

   * `variable` - The variable to solve for

  # Returns

  The solver result containing polynomial roots */
  solvePolynomial(variable: symbol): JsSolverResult
  /** Create a division expression with division-by-zero checking

  This constructor checks if the denominator is zero and returns an error if so.
  Use this in evaluation contexts where division by zero should be detected.

  For symbolic contexts where the denominator is unknown or symbolic, use `div()` instead.

  # Errors

  Returns `MathError::DivisionByZero` if the denominator is exactly zero.

  # Examples

  ```rust
  use mathhook_core::{Expression, MathError};

  // Valid division
  let result = Expression::div_checked(
  Expression::integer(10),
  Expression::integer(2),
  );
  assert!(result.is_ok());

  // Division by zero
  let result = Expression::div_checked(
  Expression::integer(1),
  Expression::integer(0),
  );
  assert!(matches!(result, Err(MathError::DivisionByZero)));
  ``` */
  static divChecked(numerator: JsExpression, denominator: JsExpression): JsExpression
  toSimpleWithDepth(context: JsSimpleContext, depth: number): string
  /** Polynomial degree computation */
  polynomialDegree(var: symbol): number | null
  /** Fast literal one check without simplification

  This is a performance-optimized version that only checks if the expression
  is literally `Number(1)`. It does NOT simplify the expression first.

  Use this in performance-critical loops where you know the expression
  is already in simplified form, or where you specifically want to check
  for literal ones only.

  # Examples

  ```rust
  use mathhook_core::Expression;

  // Detects literal one
  assert!(Expression::integer(1).is_one_fast());

  // Pow constructor auto-simplifies, so x^0 = 1 IS detected
  let expr = Expression::pow(Expression::integer(5), Expression::integer(0));
  assert!(expr.is_one_fast()); // Simplified to 1 by constructor

  // is_one_fast() checks ONLY for literal Number(1)
  // It does not simplify complex expressions first
  ``` */
  isOneFast(): boolean
  complexModulus(): JsExpression
  /** Check if expression is just the variable itself */
  isSimpleVariable(var: symbol): boolean
  /** Create a rational number expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::rational(3, 4); // 3/4
  let expr = Expression::rational(-1, 2); // -1/2
  ``` */
  static rational(numerator: number, denominator: number): JsExpression
  /** Compute the greatest common divisor of two expressions

  For integer expressions, computes the mathematical GCD.
  For polynomial expressions with integer coefficients, uses fast IntPoly algorithm.
  For other expressions, returns 1.

  # Arguments

   * `other` - The expression to compute GCD with

  # Examples

  ```rust
  use mathhook_core::expr;

  let a = expr!(12);
  let b = expr!(8);
  let gcd = a.gcd(&b);
  assert_eq!(gcd, expr!(4));
  ```

  ```rust
  use mathhook_core::expr;

  // GCD of zero with any number is that number
  let a = expr!(0);
  let b = expr!(15);
  let gcd = a.gcd(&b);
  assert_eq!(gcd, expr!(15));
  ``` */
  gcd(other: JsExpression): JsExpression
  /** GCD using IntPoly fast-path (primary path)

  Converts to IntPoly at API boundary, performs pure numeric GCD,
  converts result back. NO Expression tree walking in fast path. */
  gcdWithOther(other: JsExpression): JsExpression
  /** Fast path: solve matrix/noncommutative equation (skip classification)

  Directly solves equations involving matrices, operators, or quaternions
  where multiplication order matters.

  Handles:
  - Left multiplication: A*X = B (solution: X = A^(-1)*B)
  - Right multiplication: X*A = B (solution: X = B*A^(-1))

  # Arguments

   * `variable` - The matrix/operator variable to solve for

  # Returns

  The solver result containing the matrix equation solution */
  solveMatrixEquation(variable: symbol): JsSolverResult
  totalDegree(): number | null
  finiteProduct(variable: symbol, start: JsExpression, end: JsExpression): JsExpression
  /** Create an integer expression

  # Examples

  ```rust
  use mathhook_core::Expression;

  let expr = Expression::integer(42);
  ``` */
  static integer(value: number): JsExpression
  /** Create an equation (equality relation)

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let expr = Expression::equation(
  expr!(x),
  expr!(5),
  );
  ``` */
  static equation(left: JsExpression, right: JsExpression): JsExpression
  /** Simplify complex expressions by removing zero parts

  Converts complex numbers to their simplest form by removing zero
  real or imaginary components.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};
  use mathhook_core::simplify::Simplify;

  let z = Expression::complex(expr!(3), expr!(0));
  let simplified = z.simplify();
  ``` */
  static simplifyComplex(expr: JsExpression): JsExpression
  /** Perform advanced simplification including special functions */
  advancedSimplify(): JsExpression
  /** Create a constant expression

  # Examples

  ```rust
  use mathhook_core::{Expression, core::MathConstant};

  let expr = Expression::constant(MathConstant::Pi);
  ``` */
  static constant(constant: JsMathConstant): JsExpression
  /** Substitute variables with expressions

  Recursively replaces all occurrences of symbols with provided expressions.

  # Arguments

   * `substitutions` - Map from symbol name to replacement expression

  # Returns

  New expression with substitutions applied

  # Examples

  ```rust,ignore
  use mathhook_core::{expr, symbol};
  use std::collections::HashMap;

  let x = symbol!(x);
  let y = symbol!(y);
  let e = expr!(x + y);

  let mut subs = HashMap::new();
  subs.insert("x".to_string(), expr!(3));
  subs.insert("y".to_string(), expr!(4));

  let result = e.substitute(&subs);
  assert_eq!(result, expr!(3 + 4));
  ``` */
  substitute(substitutions: Record<string, JsExpression>): JsExpression
  /** Add rational expressions: a/b + c/d = (ad + bc)/(bd) */
  addRationals(other: JsExpression): JsExpression
  /** Advanced zero detection for specific algebraic patterns */
  detectAdvancedZeroPatterns(): boolean
  /** Generate educational explanation for function expressions

  Perfect integration with the educational system */
  explainFunction(): Array<JsStep>
  /** Generate step-by-step explanation for simplification */
  explainSimplification(): JsStepByStepExplanation
  toLatexWithDepth(context: JsLaTeXContext, depth: number): string
  /** Substitute and simplify in one step

  Convenience method that applies substitutions and then simplifies the result.

  # Arguments

   * `substitutions` - Map from symbol name to replacement expression

  # Returns

  New simplified expression with substitutions applied */
  substituteAndSimplify(substitutions: Record<string, JsExpression>): JsExpression
  /** Rationalize denominators (remove radicals from denominators) */
  rationalize(): JsExpression
  complexMultiply(other: JsExpression): JsExpression
  /** Collect terms with respect to a specific variable */
  collect(var: symbol): JsExpression
  /** Fast path: solve as PDE with steps (skip classification) */
  solvePdeWithSteps(variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  infiniteProduct(variable: symbol, start: JsExpression): JsExpression
  complexConjugate(): JsExpression
  /** Simplify other special functions */
  simplifySpecialFunctions(): JsExpression
  explainSolvingSteps(variable: symbol): JsStepByStepExplanation
  /** Format expression using default LaTeX formatting

  This is the most convenient way to format expressions when you don't need
  specific formatting options. Always uses LaTeX format.

  # Examples
  ```rust
  use mathhook_core::core::Expression;
  use mathhook_core::{expr};

  let x_expr = expr!(x);
  let formatted = x_expr.format().unwrap();
  // Returns LaTeX formatted string
  ``` */
  format(): string
  /** Check if an expression is constant (contains no variables) */
  isConstant(): boolean
  /** Extract the real part of a complex number

  Returns the real component of a complex expression. For non-complex
  expressions, returns the expression itself.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let real_part = z.real();
  assert_eq!(real_part, expr!(3));
  ``` */
  real(): JsExpression
  /** Compute the absolute value (modulus) of a complex number

  Returns |z| = √(re² + im²). For complex numbers, this is the magnitude.
  For real numbers, this is the absolute value.

  # Examples

  ```rust
  use mathhook_core::{Expression, expr};

  let z = Expression::complex(expr!(3), expr!(4));
  let magnitude = z.abs();
  ``` */
  abs(): JsExpression
  equals(other: JsExpression): boolean
  cloneValue(): JsExpression
}

export declare class JsExpressionClass {
  equals(other: JsExpressionClass): boolean
  cloneValue(): JsExpressionClass
}

export declare class JsExpSimplificationStrategy {
  name(): string
}

export declare class JsExtensionError {
  cloneValue(): JsExtensionError
}

export declare class JsExtensionRegistry {
  constructor()
  /** Get all properties from all registered extensions

  This method uses caching to avoid recomputing properties on every call.
  The cache is automatically invalidated when new extensions are registered. */
  getAllProperties(): Record<string, JsFunctionProperties>
  /** Check if any registered extension provides a function */
  hasFunction(name: string): boolean
  /** Get list of all registered extension families */
  registeredFamilies(): Array<string>
}

export declare class JsFactorialSimplificationStrategy {
  name(): string
}

export declare class JsFiniteFieldError {
  equals(other: JsFiniteFieldError): boolean
  cloneValue(): JsFiniteFieldError
}

export declare class JsFormattingError {
  equals(other: JsFormattingError): boolean
  cloneValue(): JsFormattingError
}

export declare class JsFunctionEducator {
  constructor()
}

export declare class JsFunctionFamily {
  equals(other: JsFunctionFamily): boolean
  cloneValue(): JsFunctionFamily
}

export declare class JsFunctionProperties {
  /** Get function family for quick classification */
  family(): JsFunctionFamily
  /** Check if function has derivative rule

  Hot path method for performance-critical operations */
  hasDerivative(): boolean
  /** Get derivative expression using registry rules

  Computes the derivative of f(arg) with respect to arg using the
  registered derivative rule. The chain rule (multiplying by d(arg)/dx)
  must be applied separately.

  # Arguments

   * `arg` - The argument expression to the function

  # Returns

  Returns the derivative expression, or None if no derivative rule exists

  # Examples

  ```
  use mathhook_core::functions::intelligence::get_universal_registry;
  use mathhook_core::{expr, symbol};

  let registry = get_universal_registry();
  let x = symbol!(x);

  if let Some(props) = registry.get_properties("sin") {
    let derivative = props.get_derivative_expression(&x.into());
  }
  ``` */
  getDerivativeExpression(arg: JsExpression): JsExpression | null
  /** Get Wolfram Language function name

  Used for Wolfram formatting without hardcoded function name matching.
  Returns the Wolfram name if registered, otherwise None.

  # Examples

  ```
  use mathhook_core::functions::intelligence::get_universal_registry;

  let registry = get_universal_registry();
  if let Some(props) = registry.get_properties("sin") {
    assert_eq!(props.wolfram_name(), Some("Sin"));
  }
  if let Some(props) = registry.get_properties("ln") {
    assert_eq!(props.wolfram_name(), Some("Log"));
  }
  ``` */
  wolframName(): string | null
  /** Check if function has antiderivative rule

  Hot path method for performance-critical operations */
  hasAntiderivative(): boolean
  /** Get special value count for caching optimization */
  specialValueCount(): number
  cloneValue(): JsFunctionProperties
}

export declare class JsGammaSimplificationStrategy {
  name(): string
}

export declare class JsGaussianQuadrature {
  /** Create a new Gaussian quadrature integrator

  # Arguments

   * `order` - Number of quadrature points (2, 3, 4, or 5)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::numerical::GaussianQuadrature;

  let integrator = GaussianQuadrature::new(5);
  ``` */
  constructor(order: number)
}

export declare class JsGeneratingFunction {
  cloneValue(): JsGeneratingFunction
}

export declare class JsGeneratingFunctionType {
  cloneValue(): JsGeneratingFunctionType
}

export declare class JsGenericTrigSimplificationStrategy {
  name(): string
  constructor(functionName: string)
}

export declare class JsGpuAccelerator {
  constructor()
  /** Update GPU thresholds based on performance measurements */
  updateThresholds(thresholds: JsGpuThresholds): void
  /** Check if GPU acceleration should be used for an operation */
  shouldUseGpu(operation: JsGpuOperation, size: number): boolean
  /** Get GPU capabilities */
  getCapabilities(): JsGpuCapabilities | null
}

export declare class JsGpuBackend {
  equals(other: JsGpuBackend): boolean
  cloneValue(): JsGpuBackend
}

export declare class JsGpuCapabilities {
  cloneValue(): JsGpuCapabilities
}

export declare class JsGpuOperation {
  equals(other: JsGpuOperation): boolean
  cloneValue(): JsGpuOperation
}

export declare class JsGpuStatistics {
  constructor()
  cloneValue(): JsGpuStatistics
}

export declare class JsGpuThresholds {
  constructor()
  cloneValue(): JsGpuThresholds
}

export declare class JsGroebnerBasis {
  /** Reduce the Gröbner basis to minimal form

  A reduced Gröbner basis has:
  1. Leading coefficients are 1 (monic)
  2. No monomial of any basis element is divisible by the leading
  term of another basis element */
  reduce(): void
  /** Compute the Gröbner basis using Buchberger's algorithm

  Transforms the initial generators into a Gröbner basis by computing
  S-polynomials and adding non-zero remainders to the basis.

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::groebner::{GroebnerBasis, MonomialOrder};

  let x = symbol!(x);
  let y = symbol!(y);
  let f1 = Expression::add(vec![Expression::pow(x.clone().into(), Expression::integer(2)), Expression::pow(y.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  let f2 = Expression::add(vec![x.clone().into(), Expression::mul(vec![Expression::integer(-1), y.clone().into()])]);
  let mut gb = GroebnerBasis::new(
  vec![f1, f2],
  vec![x, y],
  MonomialOrder::Lex
  );
  gb.compute();
  ``` */
  compute(): void
  /** Test if a polynomial is in the ideal generated by this basis

  # Arguments

   * `poly` - Polynomial to test for membership

  # Returns

  Returns `true` if the polynomial reduces to zero modulo the basis

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::groebner::{GroebnerBasis, MonomialOrder};

  let x = symbol!(x);
  let y = symbol!(y);
  let f1 = expr!(x - y);
  let f2 = Expression::add(vec![Expression::pow(y.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  let mut gb = GroebnerBasis::new(
  vec![f1, f2],
  vec![x.clone(), y.clone()],
  MonomialOrder::Lex
  );
  gb.compute();

  let test = Expression::add(vec![Expression::pow(x.clone().into(), Expression::integer(2)), Expression::integer(-1)]);
  assert!(gb.contains(&test));
  ``` */
  contains(poly: JsExpression): boolean
  /** Get all variables that appear in the basis */
  getVariables(): Array<symbol>
  cloneValue(): JsGroebnerBasis
}

export declare class JsHeatEquationSolver {
  constructor()
  /** Creates solver with custom maximum number of terms */
  static withMaxTerms(maxTerms: number): JsHeatEquationSolver
  canSolve(pdeType: JsPdeType): boolean
  priority(): number
  description(): string
  name(): string
}

export declare class JsHeatSolution {
  equals(other: JsHeatSolution): boolean
  cloneValue(): JsHeatSolution
}

export declare class JsHermite {
  static recurrenceCoefficients(n: number): [number, number, number]
  static evaluate(n: number, x: number): number
  static polynomial(n: number, var: symbol): JsExpression
}

export declare class JsHermiteIntelligence {
  constructor()
  /** Get all Hermite polynomial properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is a Hermite polynomial */
  hasFunction(name: string): boolean
}

export declare class JsHeuristicGcdFailed {
  cloneValue(): JsHeuristicGcdFailed
}
export type JsHeuristicGCDFailed = JsHeuristicGcdFailed

export declare class JsHomogeneousOdeSolver {
  /** Detect if ODE is homogeneous

  Checks if dy/dx can be expressed as function of y/x only.

  # Arguments

   * `equation` - The ODE equation
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  True if equation is homogeneous */
  isHomogeneous(equation: JsExpression, dependent: symbol, independent: symbol): boolean
  /** Extract homogeneous function f(v) from ODE

  Given dy/dx = expression, extract f(v) where v = y/x

  # Arguments

   * `rhs` - Right-hand side of dy/dx = rhs
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Returns

  Function f(v) if successfully extracted */
  extractHomogeneousFunction(rhs: JsExpression, dependent: symbol, independent: symbol): JsExpression | null
}
export type JsHomogeneousODESolver = JsHomogeneousOdeSolver

export declare class JsHyperbolicIntelligence {
  constructor()
  /** Get all hyperbolic function properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is hyperbolic */
  hasFunction(name: string): boolean
}

export declare class JsImplicitMultiplicationProcessor {
  /** Insert implicit multiplication with maximum performance and comprehensive token support */
  static insertImplicitMultiplication(input: string): string
}

export declare class JsInitialCondition {
  /** Create an initial derivative condition */
  static derivative(function: JsExpression): JsInitialCondition
  /** Create an initial value condition */
  static value(function: JsExpression): JsInitialCondition
  equals(other: JsInitialCondition): boolean
  cloneValue(): JsInitialCondition
}

export declare class JsIntegrationByParts {
  /** Try integration by parts with specific u and dv

  ∫ u dv = uv - ∫ v du

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let u = Expression::symbol(x.clone());
  let dv = Expression::function("exp", vec![Expression::symbol(x.clone())]);
  let result = IntegrationByParts::try_by_parts(&u, &dv, x, 0);
  ``` */
  static tryByParts(u: JsExpression, dv: JsExpression, variable: symbol, depth: number): JsExpression | null
  /** Attempt integration by parts on an expression

  Uses LIATE rule to select u and dv:
  - L: Logarithmic functions (ln, log)
  - I: Inverse trigonometric functions (arcsin, arctan, etc.)
  - A: Algebraic functions (polynomials, powers)
  - T: Trigonometric functions (sin, cos, tan)
  - E: Exponential functions (e^x, a^x)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::calculus::integrals::Integration;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // ∫ x·e^x dx
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationByParts::integrate(&expr, x, 0);
  ``` */
  static integrate(expr: JsExpression, variable: symbol, depth: number): JsExpression | null
  /** Apply integration by parts multiple times (for cases like ∫ x²·e^x dx)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  // ∫ x²·e^x dx requires two applications of by parts
  let expr = Expression::mul(vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationByParts::integrate_repeated(&expr, &x, 2);
  ``` */
  static integrateRepeated(expr: JsExpression, variable: symbol, maxIterations: number): JsExpression | null
  /** Integration by parts with strategy context tracking

  Prevents infinite recursion by using strategy context.
  The context is already marked with IntegrationByParts active,
  so recursive calls won't try by_parts again. */
  static integrateWithContext(expr: JsExpression, variable: symbol, context: JsStrategyContext, depth: number): JsExpression | null
  /** Determine if an expression is a good choice for u (LIATE priority)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::by_parts::IntegrationByParts;
  use mathhook_core::{Expression, symbol};

  let x = symbol!(x);
  let expr = Expression::function("ln", vec![Expression::symbol(x.clone())]);
  let is_good = IntegrationByParts::is_good_u_choice(&expr, &x);
  ``` */
  static isGoodUChoice(expr: JsExpression, variable: symbol): boolean
}

export declare class JsIntegrationConfig {
  constructor()
  cloneValue(): JsIntegrationConfig
}

export declare class JsIntegrationExplanation {
  /** Get the integration strategy/technique that was used */
  strategyUsed(): string
  /** Generate explanation for integrating an expression

  Analyzes the integrand and provides step-by-step explanation
  of the integration process, automatically selecting the appropriate
  technique (power rule, substitution, trigonometric, etc.)

  # Arguments

   * `expr` - The integrand to explain
   * `var` - The variable of integration

  # Examples

  ```rust
  use mathhook_core::{symbol, Expression};
  use mathhook_core::calculus::integrals::educational::IntegrationExplanation;

  let x = symbol!(x);
  let expr = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
  let explanation = IntegrationExplanation::generate(&expr, &x);
  assert!(!explanation.steps().is_empty());
  ``` */
  static generate(expr: JsExpression, var: symbol): JsIntegrationExplanation
  /** Get the step-by-step explanation as a vector of strings */
  steps(): Array<string>
}

export declare class JsIntegrationMethods {
  /** Attempt integration by parts

  Uses the IntegrationByParts module to attempt integration by parts.

  # Errors

  Returns `MathError::NotImplemented` if integration by parts cannot be applied
  or if no antiderivative can be found.

  # Examples

  ```rust
  use mathhook_core::Expression;
  use mathhook_core::symbol;
  use mathhook_core::calculus::integrals::IntegrationMethods;

  let x = symbol!(x);
  let expr = Expression::mul(vec![
  Expression::symbol(x.clone()),
  Expression::function("exp", vec![Expression::symbol(x.clone())])
  ]);
  let result = IntegrationMethods::by_parts(&expr, x);
  # Ok::<(), Box<dyn std::error::Error>>(())
  ``` */
  static byParts(expr: JsExpression, variable: symbol): JsExpression
  /** Attempt integration by substitution

  Uses u-substitution to integrate composite functions f(g(x)) where
  the derivative g'(x) appears in the integrand.

  # Errors

  Returns `MathError::NotImplemented` if no suitable substitution can be found.

  # Examples

  ```rust
  use mathhook_core::{Expression, Symbol};
  use mathhook_core::symbol;
  use mathhook_core::calculus::integrals::IntegrationMethods;

  let x = symbol!(x);
  let expr = Expression::function("sin", vec![
  Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))
  ]);
  let result = IntegrationMethods::substitution(&expr, x);
  # Ok::<(), Box<dyn std::error::Error>>(())
  ``` */
  static substitution(expr: JsExpression, variable: symbol): JsExpression
}

export declare class JsIntegrationResult {
  cloneValue(): JsIntegrationResult
}

export declare class JsIntegrationStrategy {
  equals(other: JsIntegrationStrategy): boolean
  cloneValue(): JsIntegrationStrategy
}

export declare class JsIntelligenceConfig {
  constructor()
  cloneValue(): JsIntelligenceConfig
}

export declare class JsIntelligenceReport {
  cloneValue(): JsIntelligenceReport
}

export declare class JsIssueSeverity {
  equals(other: JsIssueSeverity): boolean
  cloneValue(): JsIssueSeverity
}

export declare class JsLaguerre {
  static recurrenceCoefficients(n: number): [number, number, number]
  static evaluate(n: number, x: number): number
  static polynomial(n: number, var: symbol): JsExpression
}

export declare class JsLaguerreIntelligence {
  constructor()
  /** Get all Laguerre polynomial properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is a Laguerre polynomial */
  hasFunction(name: string): boolean
}

export declare class JsLaplaceEquationSolver {
  constructor()
  priority(): number
  name(): string
  description(): string
  static withMaxTerms(maxTerms: number): JsLaplaceEquationSolver
  canSolve(pdeType: JsPdeType): boolean
}

export declare class JsLaplaceSolution {
  equals(other: JsLaplaceSolution): boolean
  cloneValue(): JsLaplaceSolution
}

export declare class JsLaTeXContext {
  constructor()
  cloneValue(): JsLaTeXContext
}

export declare class JsLegendre {
  static polynomial(n: number, var: symbol): JsExpression
  static evaluate(n: number, x: number): number
  static recurrenceCoefficients(n: number): [number, number, number]
}

export declare class JsLegendreIntelligence {
  constructor()
  /** Get all Legendre polynomial properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is a Legendre polynomial */
  hasFunction(name: string): boolean
}

export declare class JsLimitDirection {
  equals(other: JsLimitDirection): boolean
  cloneValue(): JsLimitDirection
}

export declare class JsLimitEducation {

}

export declare class JsLimitMethods {
  /** Substitute variable with point and evaluate */
  static substituteAndEvaluate(expr: JsExpression, variable: symbol, point: JsExpression): JsExpression
  /** Check if expression represents infinity */
  static isInfinite(expr: JsExpression): boolean
  /** Compute rational function limit at infinity

  Handles cases like ln(x)/x where degree-based analysis doesn't work */
  static rationalLimitAtInfinity(numerator: JsExpression, denominator: JsExpression, variable: symbol): JsExpression
  /** Compute trigonometric limits */
  static trigonometricLimit(expr: JsExpression, variable: symbol, point: JsExpression): JsExpression
  /** Apply L'Hôpital's rule for limits at infinity

  For indeterminate forms ∞/∞ as x→∞:
  lim[x→∞] f(x)/g(x) = lim[x→∞] f'(x)/g'(x) */
  static lhopitalRuleAtInfinity(numerator: JsExpression, denominator: JsExpression, variable: symbol): JsExpression
  /** Compute rational function limit */
  static rationalLimit(numerator: JsExpression, denominator: JsExpression, variable: symbol, point: JsExpression): JsExpression
  /** Compute polynomial limit */
  static polynomialLimit(expr: JsExpression, variable: symbol, point: JsExpression): JsExpression
  /** Check for indeterminate forms */
  static isIndeterminateForm(expr: JsExpression, variable: symbol, point: JsExpression): boolean
  /** Apply L'Hôpital's rule for indeterminate forms

  For indeterminate forms 0/0 or ∞/∞:
  lim[x→a] f(x)/g(x) = lim[x→a] f'(x)/g'(x)

  Order is preserved for noncommutative expressions.
  Applies L'Hôpital's rule recursively up to 5 times if needed. */
  static lhopitalRule(numerator: JsExpression, denominator: JsExpression, variable: symbol, point: JsExpression): JsExpression
}

export declare class JsLinearFirstOrderSolver {

}

export declare class JsLinearSolver {
  constructor()
  /** Create solver without step-by-step (for performance) */
  static newFast(): JsLinearSolver
  /** Check if this solver can handle the equation */
  canSolve(equation: JsExpression): boolean
  /** Solve linear equation ax + b = 0

  Fractional solutions are automatically simplified to lowest terms via
  `BigRational::new()`, which reduces fractions using GCD. Integer solutions
  (where numerator is divisible by denominator) are returned as integers.

  # Examples

  ```rust
  use mathhook_core::algebra::solvers::{linear::LinearSolver, EquationSolver, SolverResult};
  use mathhook_core::core::{Expression, Number};
  use mathhook_core::symbol;
  use num_bigint::BigInt;

  let solver = LinearSolver::new_fast();
  let x = symbol!(x);

  // Example: 4x = 6 gives x = 3/2 (simplified from 6/4)
  let equation = Expression::add(vec![
  Expression::mul(vec![Expression::integer(4), Expression::symbol(x.clone())]),
  Expression::integer(-6),
  ]);

  match solver.solve(&equation, &x) {
    SolverResult::Single(solution) => {
      if let Expression::Number(Number::Rational(r)) = solution {
        assert_eq!(r.numer(), &BigInt::from(3));
        assert_eq!(r.denom(), &BigInt::from(2));
      }
    }
    _ => panic!("Expected single solution"),
  }
  ``` */
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  /** Solve with step-by-step explanation */
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  cloneValue(): JsLinearSolver
}

export declare class JsLinearSystemSolver {
  /** Solve linear system dx/dt = Ax

  Uses eigenvalue-eigenvector method. For an n×n system:
  - Compute eigenvalues λ₁, λ₂, ..., λₙ and eigenvectors v₁, v₂, ..., vₙ
  - General solution: x(t) = c₁e^(λ₁t)v₁ + c₂e^(λ₂t)v₂ + ... + cₙe^(λₙt)vₙ

  # Complexity

   * **Time:** O(n³) for eigenvalue decomposition of n×n matrix
   * **Space:** O(n²) for storing eigenvectors and intermediate results

  # Arguments

   * `coefficient_matrix` - The constant coefficient matrix A
   * `independent_var` - The independent variable (typically t)
   * `initial_conditions` - Optional initial state vector x(t₀) = x₀

  # Returns

  Vector of expressions representing the solution [x₁(t), x₂(t), ..., xₙ(t)]

  # Examples

  ```rust
  use mathhook_core::calculus::ode::systems::LinearSystemSolver;
  use mathhook_core::matrices::Matrix;
  use mathhook_core::{symbol, expr};

  let t = symbol!(t);

  // 2×2 system: dx/dt = [1 0; 0 2]x
  let matrix = Matrix::diagonal(vec![expr!(1), expr!(2)]);

  let solver = LinearSystemSolver;
  let solution = solver.solve(&matrix, &t, None);
  ``` */
  solve(coefficientMatrix: JsMatrix, independentVar: symbol, initialConditions?: Array<JsExpression> | undefined | null): Array<JsExpression>
  /** Solve 2×2 linear system dx/dt = Ax

  Specialized solver for 2×2 systems with explicit formulas.

  # Complexity

   * **Time:** O(1) for 2×2 eigenvalue computation (quadratic formula)
   * **Space:** O(1) for storing solution components

  # Arguments

   * `a11`, `a12`, `a21`, `a22` - Matrix coefficients [a11 a12; a21 a22]
   * `independent_var` - The independent variable (typically t)

  # Returns

  Vector [x₁(t), x₂(t)] representing the solution

  # Examples

  ```rust
  use mathhook_core::calculus::ode::systems::LinearSystemSolver;
  use mathhook_core::{symbol, expr};

  let t = symbol!(t);

  // dx/dt = [1 0; 0 2]x
  let solver = LinearSystemSolver;
  let solution = solver.solve_2x2(
  &expr!(1), &expr!(0),
  &expr!(0), &expr!(2),
  &t
  );
  ``` */
  solve2X2(a11: JsExpression, a12: JsExpression, a21: JsExpression, a22: JsExpression, independentVar: symbol): Array<JsExpression>
}

export declare class JsLinearTerm {
  cloneValue(): JsLinearTerm
}

export declare class JsLogarithmicIntelligence {
  constructor()
  /** Get all logarithmic function properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is logarithmic */
  hasFunction(name: string): boolean
}

export declare class JsLogarithmSimplificationStrategy {
  name(): string
}

export declare class JsLuDecomposition {
  equals(other: JsLuDecomposition): boolean
  cloneValue(): JsLuDecomposition
}
export type JsLUDecomposition = JsLuDecomposition

export declare class JsMathConstant {
  /** Get the approximate floating-point value of the constant

  # Examples

  ```rust
  use mathhook_core::MathConstant;

  assert!((MathConstant::Pi.to_f64() - std::f64::consts::PI).abs() < 1e-10);
  assert!((MathConstant::E.to_f64() - std::f64::consts::E).abs() < 1e-10);
  ``` */
  toF64(): number
  equals(other: JsMathConstant): boolean
  cloneValue(): JsMathConstant
}

export declare class JsMathIdentity {
  cloneValue(): JsMathIdentity
}

export declare class JsMathLanguage {
  constructor()
  /** Convert to format string for conditional formatting */
  asStr(): string
  equals(other: JsMathLanguage): boolean
  cloneValue(): JsMathLanguage
}

export declare class JsMathSerializer {
  /** Stringify - convert Expression to serialized format */
  static stringify(expr: JsExpression): string
  /** Stringify compact - compact format */
  static stringifyCompact(expr: JsExpression): string
  /** Parse - convert serialized data to Expression */
  static parse(dataStr: string): JsExpression
}

/** JavaScript wrapper for MathSolver */
export declare class JsMathSolver {
  /**
   * Create a new solver
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsMathSolver();
   * ```
   */
  constructor()
  /**
   * Solve an equation and return structured result
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsMathSolver();
   * const x = JsExpression.symbol("x");
   * const five = JsExpression.integer(5);
   * const equation = JsExpression.equation(x, five);
   * const result = solver.solve(equation, "x");
   * // result = { resultType: "single", solutions: ["5"], count: 1, metadata: "Single solution found" }
   * ```
   */
  solve(equation: JsExpression, variable: string): JsSolverResult
  /**
   * Solve an equation with step-by-step educational explanation
   *
   * Returns both the solution(s) and a step-by-step explanation of the solving process.
   * Use this when you need to show how the equation was solved.
   * For performance-critical code where only the answer is needed, use `solve()` instead.
   *
   * # Arguments
   *
   * * `equation` - The equation expression to solve
   * * `variable` - Name of the variable to solve for
   *
   * # Returns
   *
   * Object containing:
   * - `resultType`: "single", "multiple", "no_solution", or "infinite"
   * - `solutions`: Array of JsExpression solution objects
   * - `steps`: Array of step objects with title, description, before, and after
   *
   * # Examples
   *
   * ```javascript
   * const { JsMathSolver, parse } = require('mathhook-node');
   *
   * const solver = new JsMathSolver();
   * const equation = parse('x^2 - 4');
   * const result = solver.solveWithSteps(equation, 'x');
   *
   * console.log('Result type:', result.resultType);
   * console.log('Solutions:', result.solutions.map(s => s.toSimple()));
   * for (const step of result.steps) {
   *     console.log(`${step.title}: ${step.description}`);
   * }
   * ```
   */
  solveWithSteps(equation: JsExpression, variable: string): JsSolveWithStepsResult
}

export declare class JsMatrix {
  /** Check if this is a square matrix */
  isSquare(): boolean
  /** Perform Cholesky decomposition for positive definite matrices

  Decomposes symmetric positive definite matrix A into A = LL^T where:
  - L is lower triangular with positive diagonal elements

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::from_arrays([
  [4, 2],
  [2, 3]
  ]);

  if let Some(chol) = matrix.cholesky_decomposition() {
    let (l_rows, l_cols) = chol.l.dimensions();
    assert_eq!(l_rows, 2);
    assert_eq!(l_cols, 2);
  }
  ``` */
  choleskyDecomposition(): JsCholeskyDecomposition | null
  choleskyDecompositionAll(): JsCholeskyDecomposition | null
  /** Compute matrix square root using eigendecomposition
  sqrt(A) = P sqrt(D) P^(-1) where sqrt(D) = diag(sqrt(d_1), sqrt(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(4),
  Expression::integer(9)
  ]);
  let sqrt_matrix = matrix.matrix_sqrt_eigen().unwrap();
  let eigenvals = sqrt_matrix.eigenvalues();
  // Eigenvalues are sqrt(4) and sqrt(9) in symbolic form
  assert_eq!(eigenvals.len(), 2);
  assert_eq!(eigenvals[0], Expression::pow(Expression::integer(4), Expression::rational(1, 2)));
  assert_eq!(eigenvals[1], Expression::pow(Expression::integer(9), Expression::rational(1, 2)));
  ``` */
  matrixSqrtEigen(): JsMatrix | null
  /** Compute matrix power using eigendecomposition (A^n = P D^n P^(-1))

  This method is particularly efficient for diagonal and diagonalizable matrices.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(3)
  ]);

  let power = matrix.matrix_power_eigen(3).unwrap();
  let eigenvals = power.eigenvalues();
  assert_eq!(eigenvals[0], Expression::integer(8)); // 2^3
  assert_eq!(eigenvals[1], Expression::integer(27)); // 3^3
  ``` */
  matrixPowerEigen(n: number): JsMatrix | null
  matrixPowerEigenWithN(n: number): JsMatrix | null
  matrixExponential(): JsMatrix | null
  /** Perform Singular Value Decomposition

  Decomposes matrix A into A = UΣV^T where:
  - U contains left singular vectors (orthogonal)
  - Σ contains singular values (diagonal, non-negative)
  - V^T contains right singular vectors (orthogonal)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [1, 2],
  [3, 4]
  ]);

  let svd = matrix.svd_decomposition().unwrap();
  let (u_rows, u_cols) = svd.u.dimensions();
  assert_eq!(u_rows, 2);
  ``` */
  svdDecomposition(): JsSVDDecomposition | null
  svdDecompositionAll(): JsSVDDecomposition | null
  isPositiveDefinite(): boolean
  /** Compute eigenvalues and eigenvectors

  Returns eigenvalues and corresponding eigenvectors for real matrices.
  For matrices with complex eigenvalues, use `complex_eigen_decomposition`.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(3)
  ]);

  let eigen = matrix.eigen_decomposition().unwrap();
  assert_eq!(eigen.eigenvalues.len(), 2);
  assert_eq!(eigen.eigenvalues[0], Expression::integer(2));
  assert_eq!(eigen.eigenvalues[1], Expression::integer(3));
  ``` */
  eigenDecomposition(): JsEigenDecomposition | null
  eigenDecompositionAll(): JsEigenDecomposition | null
  /** Create an identity matrix of given size
  Memory efficient: O(1) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let identity = Matrix::identity(3);
  assert_eq!(identity.dimensions(), (3, 3));
  assert!(identity.is_identity());
  ``` */
  static identity(size: number): JsMatrix
  rank(): number
  multiply(other: JsMatrix): JsMatrix
  /** Try to convert this matrix to a NumericMatrix for fast numeric operations.

  Returns Some(NumericMatrix) if all elements can be converted to f64,
  None otherwise (e.g., if matrix contains symbolic expressions). */
  asNumeric(): JsNumericMatrix | null
  /** Check if this is a diagonal matrix */
  isDiagonal(): boolean
  /** Check if matrix is nilpotent (A^k = 0 for some positive integer k)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let zero_matrix = Matrix::zero(3, 3);
  assert!(zero_matrix.is_nilpotent());

  let identity = Matrix::identity(3);
  assert!(!identity.is_nilpotent());
  ``` */
  isNilpotent(): boolean
  isNilpotentAll(): boolean
  determinantViaEigenvalues(): JsExpression
  /** Get matrix rank using SVD

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  assert_eq!(identity.rank_via_svd(), 3);

  let zero = Matrix::zero(3, 3);
  assert_eq!(zero.rank_via_svd(), 0);
  ``` */
  rankViaSvd(): number
  /** Create a scalar matrix (c*I)
  Memory efficient: O(1) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let scalar = Matrix::scalar(3, Expression::integer(5));
  ``` */
  static scalar(size: number, scalarValue: JsExpression): JsMatrix
  /** Get condition number using SVD

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(2);
  let cond = identity.condition_number_via_svd();
  assert_eq!(cond, Expression::integer(1));
  ``` */
  conditionNumberViaSvd(): JsExpression
  /** Get the trace (sum of diagonal elements) efficiently */
  trace(): JsExpression
  traceAll(): JsExpression
  /** Create a diagonal matrix from diagonal elements
  Memory efficient: O(n) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let diag = Matrix::diagonal(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  assert_eq!(diag.dimensions(), (3, 3));
  assert!(diag.is_diagonal());
  ``` */
  static diagonal(diagonalElements: Array<JsExpression>): JsMatrix
  /** Check if a value is small (simplified convergence test) */
  isSmallValue(value: JsExpression, tolerance: JsExpression): boolean
  matrixSqrt(): JsMatrix | null
  inverse(): JsMatrix
  matrixLogarithm(): JsMatrix | null
  add(other: JsMatrix): JsMatrix
  /** Check if matrix is diagonalizable

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let diagonal = Matrix::diagonal(vec![
  Expression::integer(1),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  assert!(diagonal.is_diagonalizable());

  let identity = Matrix::identity(3);
  assert!(identity.is_diagonalizable());
  ``` */
  isDiagonalizable(): boolean
  isDiagonalizableAll(): boolean
  /** Scalar multiplication */
  scalarMultiply(scalar: JsExpression): JsMatrix
  /** Compute complex eigenvalues and eigenvectors

  Handles matrices that may have complex eigenvalues and eigenvectors.

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [0, -1],
  [1, 0]
  ]);

  // This matrix has complex eigenvalues ±i
  let complex_eigen = matrix.complex_eigen_decomposition();
  // Returns None as complex eigenvalue computation requires specialized algorithms
  assert!(complex_eigen.is_none());
  ``` */
  complexEigenDecomposition(): JsComplexEigenDecomposition | null
  complexEigenDecompositionAll(): JsComplexEigenDecomposition | null
  characteristicPolynomial(): JsCharacteristicPolynomial
  /** Check if this is a zero matrix */
  isZero(): boolean
  /** Compute matrix power for special cases

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  let power = identity.matrix_power_special(5).unwrap();
  assert!(matches!(power, Matrix::Identity(_)));

  let scalar = Matrix::scalar(2, Expression::integer(3));
  let power = scalar.matrix_power_special(2).unwrap();
  // (3I)² = 9I
  ``` */
  matrixPowerSpecial(n: number): JsMatrix | null
  /** Create an upper triangular matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let upper = Matrix::upper_triangular(3, vec![
  Expression::integer(1), Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5),
  Expression::integer(6)
  ]);
  ``` */
  static upperTriangular(size: number, elements: Array<JsExpression>): JsMatrix
  /** Compute only eigenvalues (faster than full decomposition)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::scalar(3, Expression::integer(5));
  let eigenvals = matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 3);
  assert_eq!(eigenvals[0], Expression::integer(5));
  ``` */
  eigenvalues(): Array<JsExpression>
  eigenvaluesAll(): Array<JsExpression>
  conditionNumber(): JsExpression
  /** Get the determinant efficiently (for square matrices)

  # Returns
  Result containing the determinant expression, or MathError for non-square matrices

  # Errors
  Returns DomainError if matrix is not square

  # Algorithm
  - Special matrices (Identity, Zero, Scalar, Diagonal): O(1) or O(n)
  - Small matrices (1x1, 2x2): Direct formulas
  - Numeric matrices: NumericMatrix fast-path with O(n³) LU decomposition
  - Larger symbolic matrices (n≥3): LU decomposition O(n³) */
  determinant(): JsExpression
  /** Compute matrix logarithm using eigendecomposition
  log(A) = P log(D) P^(-1) where log(D) = diag(log(d_1), log(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(2);
  let log_matrix = identity.matrix_logarithm_eigen().unwrap();
  // log(I) has eigenvalues log(1) = 0, so result is diagonal matrix with zeros
  let eigenvals = log_matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 2);
  assert_eq!(eigenvals[0], Expression::function("log", vec![Expression::integer(1)]));
  assert_eq!(eigenvals[1], Expression::function("log", vec![Expression::integer(1)]));
  ``` */
  matrixLogarithmEigen(): JsMatrix | null
  /** Create a symmetric matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let symmetric = Matrix::symmetric(3, vec![
  Expression::integer(1), Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5),
  Expression::integer(6)
  ]);
  ``` */
  static symmetric(size: number, elements: Array<JsExpression>): JsMatrix
  /** Perform QR decomposition using Gram-Schmidt process

  Decomposes matrix A into A = QR where:
  - Q is orthogonal (Q^T * Q = I)
  - R is upper triangular

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [1, 1],
  [0, 1]
  ]);

  let qr = matrix.qr_decomposition().unwrap();
  let (q_rows, q_cols) = qr.q.dimensions();
  assert_eq!(q_rows, 2);
  assert_eq!(q_cols, 2);
  ``` */
  qrDecomposition(): JsQRDecomposition | null
  qrDecompositionAll(): JsQRDecomposition | null
  /** Power iteration method for finding dominant eigenvalue
  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::{Expression, expr};

  let matrix = Matrix::diagonal(vec![expr!(2), expr!(3)]);
  let eigen = matrix.power_iteration_eigenvalues().unwrap();
  // Power iteration returns the dominant (largest) eigenvalue
  // For symbolic computation, the result may be a complex expression
  assert_eq!(eigen.eigenvalues.len(), 1);
  // The eigenvalue exists but may not simplify to integer form symbolically
  assert!(!eigen.eigenvalues[0].is_zero());
  ``` */
  powerIterationEigenvalues(): JsEigenDecomposition | null
  transpose(): JsMatrix
  /** Get matrix dimensions efficiently

  This method provides O(1) dimension lookup for all matrix types. */
  dimensions(): [number, number]
  /** Perform LU decomposition with partial pivoting

  Decomposes matrix A into PA = LU where:
  - P is a permutation matrix
  - L is lower triangular with 1s on diagonal
  - U is upper triangular

  # Examples

  ```
  use mathhook_core::matrices::Matrix;

  let matrix = Matrix::from_arrays([
  [2, 1],
  [4, 3]
  ]);

  let lu = matrix.lu_decomposition().unwrap();
  assert!(lu.p.is_some());
  ``` */
  luDecomposition(): JsLuDecomposition | null
  luDecompositionAll(): JsLuDecomposition | null
  /** Check if this is an identity matrix */
  isIdentity(): boolean
  /** Check if this is symmetric */
  isSymmetric(): boolean
  /** Get element at position (i, j) efficiently

  This method provides optimized element access for each matrix type. */
  getElement(i: number, j: number): JsExpression
  /** Check if matrix is positive definite using Cholesky test

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let identity = Matrix::identity(3);
  assert!(identity.is_positive_definite_cholesky());

  let scalar = Matrix::scalar(2, Expression::integer(5));
  assert!(scalar.is_positive_definite_cholesky());
  ``` */
  isPositiveDefiniteCholesky(): boolean
  /** Create a permutation matrix
  Memory efficient: O(n) storage vs O(n²) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let perm = Matrix::permutation(vec![2, 0, 1]);
  ``` */
  static permutation(permutation: Array<number>): JsMatrix
  /** Compute the minimal polynomial (smallest degree polynomial that annihilates the matrix)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::diagonal(vec![
  Expression::integer(2),
  Expression::integer(2),
  Expression::integer(3)
  ]);
  let min_poly = matrix.minimal_polynomial();
  // For this matrix, minimal polynomial is (λ-2)(λ-3)
  assert!(!min_poly.coefficients.is_empty());
  ``` */
  minimalPolynomial(): JsCharacteristicPolynomial
  /** Convert to the most efficient representation

  This method analyzes the matrix and converts it to the most
  memory-efficient representation possible. */
  optimize(): JsMatrix
  /** Create a zero matrix of given dimensions
  Memory efficient: O(1) storage vs O(n*m) for dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;

  let zero = Matrix::zero(2, 3);
  assert_eq!(zero.dimensions(), (2, 3));
  assert!(zero.is_zero());
  ``` */
  static zero(rows: number, cols: number): JsMatrix
  /** Compute matrix exponential using eigendecomposition
  exp(A) = P exp(D) P^(-1) where exp(D) = diag(exp(d_1), exp(d_2), ...)

  # Examples

  ```
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let matrix = Matrix::zero(2, 2);
  let exp_matrix = matrix.matrix_exponential_eigen().unwrap();
  // exp(0) = 1, so result is diagonal(exp(0), exp(0))
  let eigenvals = exp_matrix.eigenvalues();
  assert_eq!(eigenvals.len(), 2);
  // Eigenvalues are exp(0) in symbolic form
  assert_eq!(eigenvals[0], Expression::function("exp", vec![Expression::integer(0)]));
  ``` */
  matrixExponentialEigen(): JsMatrix | null
  /** Create a lower triangular matrix
  Memory efficient: ~50% storage vs dense matrix

  # Examples

  ```rust
  use mathhook_core::matrices::Matrix;
  use mathhook_core::Expression;

  let lower = Matrix::lower_triangular(3, vec![
  Expression::integer(1),
  Expression::integer(2), Expression::integer(3),
  Expression::integer(4), Expression::integer(5), Expression::integer(6)
  ]);
  ``` */
  static lowerTriangular(size: number, elements: Array<JsExpression>): JsMatrix
  equals(other: JsMatrix): boolean
  cloneValue(): JsMatrix
}

export declare class JsMatrixEquationSolver {
  constructor()
  /** Create solver without step-by-step explanations (for performance)

  # Examples

  ```rust,ignore
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new_fast();
  ``` */
  static newFast(): JsMatrixEquationSolver
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  /** Solve right division: X*A = B → X = B*A^(-1)

  # Arguments

   * `A` - The right coefficient matrix/operator
   * `B` - The right-hand side

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new();
  let A = symbol!(A; matrix);
  let B = symbol!(B; matrix);

  let solution = solver.solve_right_division(&A, &B);
  // solution should be B*A^(-1)
  ``` */
  solveRightDivision(a: JsExpression, b: JsExpression): JsExpression
  canSolve(equation: JsExpression): boolean
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  /** Solve left division: A*X = B → X = A^(-1)*B

  # Arguments

   * `A` - The left coefficient matrix/operator
   * `B` - The right-hand side

  # Examples

  ```rust,ignore
  use mathhook_core::{symbol, expr};
  use mathhook_core::algebra::solvers::matrix_equations::MatrixEquationSolver;

  let solver = MatrixEquationSolver::new();
  let A = symbol!(A; matrix);
  let B = symbol!(B; matrix);

  let solution = solver.solve_left_division(&A, &B);
  // solution should be A^(-1)*B
  ``` */
  solveLeftDivision(a: JsExpression, b: JsExpression): JsExpression
  cloneValue(): JsMatrixEquationSolver
}

export declare class JsMessageCategory {
  equals(other: JsMessageCategory): boolean
  cloneValue(): JsMessageCategory
}

export declare class JsMessageHashSystem {
  /** Get message hash for efficient lookup */
  static hashMessageKey(category: JsMessageCategory, messageType: JsMessageType, variant: number): number
  /** Get message by hash (for performance-critical paths) */
  static getMessageByHash(hash: number): JsMessageTemplate | null
  /** Validate message registry integrity */
  static validateRegistry(): boolean
}

export declare class JsMessageOptimizer {
  /** Get cached message or generate new one */
  static getOptimizedMessage(scenario: string): Array<JsStep> | null
  /** Pre-compute common message combinations for performance */
  static precomputeCommonMessages(): Record<string, Array<JsStep>>
}

export declare class JsMessageTemplate {
  cloneValue(): JsMessageTemplate
}

export declare class JsMessageType {
  equals(other: JsMessageType): boolean
  cloneValue(): JsMessageType
}

export declare class JsNaturalLogSimplificationStrategy {
  name(): string
}

export declare class JsNewtonRaphson {
  /** Create a new Newton-Raphson method with initial guess

  # Arguments

   * `initial_guess` - Starting point for iteration

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::NewtonRaphson;

  let method = NewtonRaphson::new(1.5);
  ``` */
  constructor(initialGuess: number)
}

export declare class JsNumberTheoryIntelligence {
  constructor()
  /** Check if function has number theory intelligence */
  hasIntelligence(name: string): boolean
  /** Get all number theory function properties */
  getAllProperties(): Record<string, JsFunctionProperties>
}

export declare class JsNumericMatrix {
  static canConvert(expr: JsExpression): boolean
  toMatrix(): JsMatrix
  transpose(): JsNumericMatrix
  sub(other: JsNumericMatrix): JsNumericMatrix
  dimensions(): [number, number]
  get(row: number, col: number): number
  isSquare(): boolean
  inverse(): JsNumericMatrix
  scalarMul(scalar: number): JsNumericMatrix
  multiply(other: JsNumericMatrix): JsNumericMatrix
  add(other: JsNumericMatrix): JsNumericMatrix
  negate(): JsNumericMatrix
  set(row: number, col: number, value: number): void
  static tryFromExpression(expr: JsExpression): JsNumericMatrix | null
  static tryFromMatrix(matrix: JsMatrix): JsNumericMatrix | null
  isSymmetric(): boolean
  static canConvertMatrix(matrix: JsMatrix): boolean
  static zeros(rows: number, cols: number): JsNumericMatrix
  determinant(): number
  static fromFlat(rows: number, cols: number, data: Array<number>): JsNumericMatrix
  toExpression(): JsExpression
  static identity(n: number): JsNumericMatrix
  equals(other: JsNumericMatrix): boolean
  cloneValue(): JsNumericMatrix
}

export declare class JsOdeClassifier {
  /** Classify a second-order ODE

  # Arguments

   * `lhs` - Left-hand side expression (usually y'', y', y terms)
   * `rhs` - Right-hand side expression (forcing function)
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Examples

  ```rust
  use mathhook_core::calculus::ode::classifier::{ODEClassifier, ODEType};
  use mathhook_core::{symbol, expr, Expression};

  let x = symbol!(x);
  let y = symbol!(y);

  let ode_type = ODEClassifier::classify_second_order(
  &expr!(y + y),
  &Expression::integer(0),
  &y,
  &x
  );
  assert_eq!(ode_type, ODEType::ConstantCoefficients);
  ``` */
  static classifySecondOrder(lhs: JsExpression, rhs: JsExpression, dependent: symbol, independent: symbol): JsODEType
  /** Classify a first-order ODE

  Attempts to classify the ODE in order of computational efficiency:
  1. Separable (fastest, widest coverage)
  2. Linear first-order (integrating factor method)
  3. Exact (requires exactness condition check)
  4. Bernoulli (transforms to linear)
  5. Homogeneous (substitution method)

  # Arguments

   * `rhs` - Right-hand side of dy/dx = rhs
   * `dependent` - Dependent variable (y)
   * `independent` - Independent variable (x)

  # Examples

  ```rust
  use mathhook_core::calculus::ode::classifier::{ODEClassifier, ODEType};
  use mathhook_core::{symbol, expr, Expression};

  let x = symbol!(x);
  let y = symbol!(y);

  let rhs = expr!(x * y);
  let ode_type = ODEClassifier::classify_first_order(&rhs, &y, &x);
  assert_eq!(ode_type, ODEType::Separable);
  ``` */
  static classifyFirstOrder(rhs: JsExpression, dependent: symbol, independent: symbol): JsODEType
}
export type JsODEClassifier = JsOdeClassifier

export declare class JsOdeExamples {
  /** Example: Simplest separable ODE dy/dx = x

  # Solution

  y = x²/2 + C

  # Common Pitfalls

  - Forgetting the constant of integration
  - Incorrect integration of x (getting x²/2 instead of x²/2) */
  static separableSimple(): JsODEExplanation
  /** Get example by name */
  static getExample(name: string): JsODEExplanation | null
  /** Example: Linear first-order dy/dx + y = x

  # Solution

  y = x - 1 + C·e^(-x)

  # Common Pitfalls

  - Incorrectly computing integrating factor μ(x) = e^(∫P(x)dx)
  - Forgetting to multiply Q(x) by μ(x) before integrating
  - Sign errors in the exponent */
  static linearFirstOrder(): JsODEExplanation
  /** Get list of available example names */
  static exampleNames(): Array<string>
  /** Get all example explanations */
  static allExamples(): Array<JsODEExplanation>
  /** Example: Exponential growth dy/dx = y

  # Solution

  y = C·e^x

  # Common Pitfalls

  - Forgetting absolute value in ln|y| = x + C
  - Incorrect handling of integration constant when exponentiating
  - Not recognizing this as both separable and linear */
  static exponentialGrowth(): JsODEExplanation
  /** Example: Initial value problem dy/dx = x, y(0) = 1

  # Solution

  y = x²/2 + 1

  # Common Pitfalls

  - Forgetting to apply initial condition
  - Incorrectly solving for constant C
  - Not verifying that y(0) = 1 in final solution */
  static initialValueProblem(): JsODEExplanation
  /** Example: Product form dy/dx = xy

  # Solution

  y = C·e^(x²/2)

  # Common Pitfalls

  - Incorrectly integrating x to get x²/2 vs x²
  - Forgetting to include constant in exponential
  - Not simplifying e^(x²/2 + C) to C'·e^(x²/2) */
  static productSeparable(): JsODEExplanation
}
export type JsODEExamples = JsOdeExamples

export declare class JsOdeExplanation {
  /** Get human-readable explanation */
  toHumanReadable(): string
  /** Create a new ODE explanation */
  constructor(solution: JsExpression, steps: Array<JsODESolutionStep>, odeType: string, methodSummary: string)
  /** Get steps for a specific phase */
  stepsByPhase(phase: JsODEPhase): Array<JsODESolutionStep>
  /** Get LaTeX formatted explanation */
  toLatex(): string
  cloneValue(): JsOdeExplanation
}
export type JsODEExplanation = JsOdeExplanation

export declare class JsOdePhase {
  equals(other: JsOdePhase): boolean
  cloneValue(): JsOdePhase
}
export type JsODEPhase = JsOdePhase

export declare class JsOdeSolution {
  equals(other: JsOdeSolution): boolean
  cloneValue(): JsOdeSolution
}
export type JsODESolution = JsOdeSolution

export declare class JsOdeSolutionStep {
  /** Get LaTeX representation with custom formatting */
  toLatexDetailed(): string
  /** Add metadata to the step */
  withMetadata(key: string, value: string): JsOdeSolutionStep
  /** Create a new ODE solution step */
  constructor(stepId: string, phase: JsOdePhase, title: string, description: string, justification: string, before: JsExpression, after: JsExpression)
  cloneValue(): JsOdeSolutionStep
}
export type JsODESolutionStep = JsOdeSolutionStep

export declare class JsOdeSolver {
  constructor()
  /** Create an ODE solver with custom configuration */
  static withConfig(config: JsSolverConfig): JsOdeSolver
  /** Get current solver configuration */
  config(): JsSolverConfig
}
export type JsODESolver = JsOdeSolver

export declare class JsOdeSolverRegistry {
  constructor()
}
export type JsODESolverRegistry = JsOdeSolverRegistry

export declare class JsOdeStepFactory {
  /** Create solution construction step */
  static solutionConstruction(implicit: JsExpression, explicit: JsExpression, method: string): JsOdeSolutionStep
  /** Create separation step for separable ODEs */
  static separation(original: JsExpression, separated: JsExpression, gX: string, hY: string): JsOdeSolutionStep
  /** Create detection step */
  static detection(odeType: string, equation: JsExpression, reason: string): JsOdeSolutionStep
  /** Create integration step */
  static integration(integrand: JsExpression, result: JsExpression, variable: symbol, side: string): JsOdeSolutionStep
  /** Create verification step */
  static verification(solution: JsExpression, originalOde: JsExpression, verificationResult: boolean): JsOdeSolutionStep
}
export type JsODEStepFactory = JsOdeStepFactory

export declare class JsOdeType {
  toString(): string
  equals(other: JsOdeType): boolean
  cloneValue(): JsOdeType
}
export type JsODEType = JsOdeType

export declare class JsOperationContext {
  /** Create context for equation solving */
  static equationSolving(difficultyLevel: number): JsOperationContext
  /** Create context for differentiation */
  static differentiation(difficultyLevel: number): JsOperationContext
  /** Create context for simplification */
  static simplification(difficultyLevel: number): JsOperationContext
  equals(other: JsOperationContext): boolean
  cloneValue(): JsOperationContext
}

export declare class JsParallelStatistics {
  constructor()
  cloneValue(): JsParallelStatistics
}

export declare class JsParseError {
  equals(other: JsParseError): boolean
  cloneValue(): JsParseError
}

export declare class JsParser {
  /** Create parser with implicit multiplication enabled */
  constructor(config: JsParserConfig)
  /** Parse mathematical expression with full integration

  # Examples

  ```rust
  use mathhook_core::parser::Parser;
  use mathhook_core::parser::config::ParserConfig;

  let parser = Parser::new(&ParserConfig::default());

  // These will work with implicit multiplication:
  let expr = parser.parse("2x").unwrap();           // -> 2 * x
  let expr = parser.parse("xy").unwrap();           // -> x * y
  let expr = parser.parse("2(x+1)").unwrap();       // -> 2 * (x + 1)

  // These work normally:
  let expr = parser.parse("x + y").unwrap();        // -> x + y
  let expr = parser.parse("x^2").unwrap();          // -> x^2
  ``` */
  parse(input: string): JsExpression
}

export declare class JsParserConfig {
  constructor()
}

export declare class JsPartialFractionDecomposition {
  cloneValue(): JsPartialFractionDecomposition
}

export declare class JsPatternKey {
  equals(other: JsPatternKey): boolean
  cloneValue(): JsPatternKey
}

export declare class JsPde {
  /** Create a new PDE

  # Arguments

   * `equation` - The PDE expression (should equal zero)
   * `dependent_var` - The dependent variable
   * `independent_vars` - The independent variables

  # Examples

  ```rust
  use mathhook_core::calculus::pde::types::Pde;
  use mathhook_core::{symbol, expr};

  let u = symbol!(u);
  let x = symbol!(x);
  let t = symbol!(t);
  let equation = expr!(u + x + t);
  let pde = Pde::new(equation, u, vec![x, t]);
  ``` */
  constructor(equation: JsExpression, dependentVar: symbol, independentVars: Array<symbol>)
  /** Determine the order of the PDE */
  order(): JsPdeOrder
  /** Determine the linearity classification */
  linearity(): JsPdeLinearity
  equals(other: JsPde): boolean
  cloneValue(): JsPde
}

export declare class JsPdeCoefficients {
  equals(other: JsPdeCoefficients): boolean
  cloneValue(): JsPdeCoefficients
}

export declare class JsPdeLinearity {
  equals(other: JsPdeLinearity): boolean
  cloneValue(): JsPdeLinearity
}

export declare class JsPdeMessageKey {
  equals(other: JsPdeMessageKey): boolean
  cloneValue(): JsPdeMessageKey
}

export declare class JsPdeMessageVariant {

}

export declare class JsPdeOrder {
  equals(other: JsPdeOrder): boolean
  cloneValue(): JsPdeOrder
}

export declare class JsPdeSolution {
  /** Creates a general PDE solution with no specific metadata

  # Arguments

   * `solution` - The general solution expression */
  static general(solution: JsExpression): JsPdeSolution
  /** Creates a heat equation solution

  # Arguments

   * `solution` - The general solution expression
   * `alpha` - Thermal diffusivity coefficient
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static heat(solution: JsExpression, alpha: JsExpression, eigenvalues: Array<JsExpression>, coefficients: Array<JsExpression>): JsPdeSolution
  /** Creates a Laplace equation solution

  # Arguments

   * `solution` - The general solution expression
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static laplace(solution: JsExpression, eigenvalues: Array<JsExpression>, coefficients: Array<JsExpression>): JsPdeSolution
  /** Creates a wave equation solution

  # Arguments

   * `solution` - The general solution expression
   * `c` - Wave speed
   * `eigenvalues` - Eigenvalues from boundary conditions
   * `coefficients` - Fourier coefficients */
  static wave(solution: JsExpression, c: JsExpression, eigenvalues: Array<JsExpression>, coefficients: Array<JsExpression>): JsPdeSolution
  equals(other: JsPdeSolution): boolean
  cloneValue(): JsPdeSolution
}
export type JsPDESolution = JsPdeSolution

/** PDE Solver for Partial Differential Equations */
export declare class JsPdeSolver {
  /**
   * Create a new PDE solver
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * ```
   */
  constructor()
  /**
   * Solve the heat equation ∂u/∂t = α∇²u
   *
   * For 1D heat equation with Dirichlet boundary conditions and initial temperature distribution.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `spatial_var` - Spatial variable (e.g., "x")
   * * `temporal_var` - Time variable (e.g., "t")
   * * `alpha` - Thermal diffusivity coefficient
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const alpha = JsExpression.integer(1);
   * const solution = solver.solveHeatEquation("u", "x", "t", alpha);
   * // Returns heat equation solution with Fourier series
   * ```
   */
  solveHeatEquation(dependentVar: string, spatialVar: string, temporalVar: string, alpha: JsExpression): PdeSolution
  /**
   * Solve the wave equation ∂²u/∂t² = c²∇²u
   *
   * For 1D wave equation with Dirichlet boundary conditions and initial displacement/velocity.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `spatial_var` - Spatial variable (e.g., "x")
   * * `temporal_var` - Time variable (e.g., "t")
   * * `wave_speed` - Wave propagation speed c
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const c = JsExpression.integer(1);
   * const solution = solver.solveWaveEquation("u", "x", "t", c);
   * // Returns wave equation solution with Fourier series
   * ```
   */
  solveWaveEquation(dependentVar: string, spatialVar: string, temporalVar: string, waveSpeed: JsExpression): PdeSolution
  /**
   * Solve the Laplace equation ∇²u = 0
   *
   * For 2D Laplace equation on rectangular domain with Dirichlet boundary conditions.
   *
   * # Arguments
   *
   * * `dependent_var` - Dependent variable (e.g., "u")
   * * `x_var` - First spatial variable (e.g., "x")
   * * `y_var` - Second spatial variable (e.g., "y")
   *
   * # Examples
   *
   * ```javascript
   * const solver = new JsPDESolver();
   * const solution = solver.solveLaplaceEquation("u", "x", "y");
   * // Returns Laplace equation solution with Fourier series
   * ```
   */
  solveLaplaceEquation(dependentVar: string, xVar: string, yVar: string): PdeSolution
}
export type JsPDESolver = JsPdeSolver

export declare class JsPdeSolverRegistry {
  constructor()
  /** Get all registered solver types */
  registeredTypes(): Array<JsPdeType>
  /** Get solver count */
  solverCount(): number
}
export type JsPDESolverRegistry = JsPdeSolverRegistry

export declare class JsPdeType {
  equals(other: JsPdeType): boolean
  cloneValue(): JsPdeType
}

export declare class JsPerformanceConfig {
  constructor()
  /** Factory method to create configuration based on binding context */
  static forBinding(context: JsBindingContext): JsPerformanceConfig
  /** Configuration for WebAssembly bindings (memory-constrained) */
  static wasmOptimized(): JsPerformanceConfig
  /** Configuration optimized for Python bindings (GIL-aware) */
  static pythonOptimized(): JsPerformanceConfig
  /** Configuration for high-performance native usage */
  static nativeOptimized(): JsPerformanceConfig
  /** Configuration optimized for Node.js bindings */
  static nodejsOptimized(): JsPerformanceConfig
  cloneValue(): JsPerformanceConfig
}

export declare class JsPerformanceMeasurement {
  cloneValue(): JsPerformanceMeasurement
}

export declare class JsPerformanceMetrics {
  cloneValue(): JsPerformanceMetrics
}

export declare class JsPerformanceOptimizer {
  /** Check cache for memoized result */
  getCachedSimplify(exprHash: number): JsExpression | null
  /** Cache a simplification result */
  cacheSimplify(exprHash: number, result: JsExpression): void
  /** Determine if SIMD should be used for bulk operations */
  shouldUseSimd(operationSize: number): boolean
  /** Get cache statistics for monitoring */
  cacheStats(): JsCacheStats
  /** Determine if parallel processing should be used */
  shouldUseParallel(operationSize: number): boolean
  constructor(config: JsPerformanceConfig)
}

export declare class JsPersistentCache {
  /** Force save cache to disk */
  forceSave(): void
  /** Get a cached result */
  get(expressionHash: number): JsExpression | null
  /** Clear all cache entries */
  clear(): void
  /** Store a result in the cache */
  put(expressionHash: number, simplified: JsExpression): void
  /** Save cache to disk */
  saveToDisk(): void
}

export declare class JsPersistentCacheConfig {
  constructor()
  cloneValue(): JsPersistentCacheConfig
}

export declare class JsPersistentCacheEntry {
  cloneValue(): JsPersistentCacheEntry
}

export declare class JsPersistentCacheStatistics {
  constructor()
  cloneValue(): JsPersistentCacheStatistics
}

export declare class JsPolynomialArithmetic {
  /** Polynomial composition f(g(x)) */
  static composePolynomials(f: JsExpression, g: JsExpression, var: symbol): JsExpression
  /** Polynomial evaluation using Horner's method */
  static evaluatePolynomial(poly: JsExpression, var: symbol, value: JsExpression): JsExpression
  /** Polynomial addition */
  static addPolynomials(poly1: JsExpression, poly2: JsExpression): JsExpression
  /** Polynomial multiplication using convolution */
  static multiplyPolynomials(poly1: JsExpression, poly2: JsExpression): JsExpression
}

export declare class JsPolynomialFamily {
  equals(other: JsPolynomialFamily): boolean
  cloneValue(): JsPolynomialFamily
}

export declare class JsPolynomialIntelligence {
  constructor()
  /** Check if function is a polynomial */
  isPolynomialFunction(name: string): boolean
  /** Get all polynomial function properties

  Returns a HashMap of all polynomial functions and their properties
  for integration with the universal registry. */
  getAllProperties(): Record<string, JsFunctionProperties>
}

export declare class JsPolynomialProperties {
  cloneValue(): JsPolynomialProperties
}

export declare class JsProfilerStatistics {
  cloneValue(): JsProfilerStatistics
}

export declare class JsQrDecomposition {
  equals(other: JsQrDecomposition): boolean
  cloneValue(): JsQrDecomposition
}
export type JsQRDecomposition = JsQrDecomposition

export declare class JsQuadraticSolver {
  constructor()
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  canSolve(equation: JsExpression): boolean
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  cloneValue(): JsQuadraticSolver
}

export declare class JsQuadraticTerm {
  cloneValue(): JsQuadraticTerm
}

export declare class JsRange {
  cloneValue(): JsRange
}

export declare class JsRationalIntegral {
  equals(other: JsRationalIntegral): boolean
  cloneValue(): JsRationalIntegral
}

export declare class JsRecurrenceRule {
  cloneValue(): JsRecurrenceRule
}

export declare class JsReference {
  cloneValue(): JsReference
}

export declare class JsRelationType {
  equals(other: JsRelationType): boolean
  cloneValue(): JsRelationType
}

export declare class JsResidueMethods {
  /** Compute residue for simple pole using limit formula

  # Arguments

   * `numerator` - Numerator of the rational function
   * `denominator` - Denominator of the rational function
   * `variable` - The variable symbol
   * `pole` - Location of the pole

  # Returns

  Expression representing the residue computation */
  static simplePoleResidue(numerator: JsExpression, denominator: JsExpression, variable: symbol, pole: JsExpression): JsExpression
  /** Compute residue for pole of order m using derivative formula

  # Arguments

   * `numerator` - Numerator of the rational function
   * `denominator` - Denominator of the rational function
   * `variable` - The variable symbol
   * `pole` - Location of the pole
   * `order` - Order of the pole

  # Returns

  Expression representing the residue */
  static higherOrderPoleResidue(numerator: JsExpression, denominator: JsExpression, variable: symbol, pole: JsExpression, order: number): JsExpression
  /** Compute factorial

  # Arguments

   * `n` - The number to compute factorial of

  # Returns

  Expression representing n! */
  static factorial(n: number): JsExpression
}

export declare class JsRischResult {
  equals(other: JsRischResult): boolean
  cloneValue(): JsRischResult
}

export declare class JsRodriguesFormula {
  cloneValue(): JsRodriguesFormula
}

export declare class JsRombergIntegration {
  /** Create a new Romberg integrator

  # Arguments

   * `max_order` - Maximum order of extrapolation (typically 5-10)

  # Examples

  ```rust
  use mathhook_core::calculus::integrals::numerical::RombergIntegration;

  let integrator = RombergIntegration::new(8);
  ``` */
  constructor(maxOrder: number)
}

export declare class JsRootFindingConfig {
  constructor()
  cloneValue(): JsRootFindingConfig
}

export declare class JsRootType {
  equals(other: JsRootType): boolean
  cloneValue(): JsRootType
}

export declare class JsRuntimeProfiler {
  constructor()
  /** Get performance statistics for monitoring */
  getStatistics(): JsProfilerStatistics
  /** Record a performance measurement */
  recordMeasurement(measurement: JsPerformanceMeasurement): void
  /** Get current adaptive thresholds */
  getThresholds(): JsAdaptiveThresholds
}

export declare class JsSecantMethod {
  /** Create a new secant method with two initial guesses

  # Arguments

   * `x0` - First initial guess
   * `x1` - Second initial guess (should be close to but different from x0)

  # Examples

  ```rust
  use mathhook_core::algebra::root_finding::SecantMethod;

  let method = SecantMethod::new(1.0, 2.0);
  ``` */
  constructor(x0: number, x1: number)
}

export declare class JsSeparableOdeSolver {
  constructor()
  /** Check if ODE is separable

  An ODE dy/dx = f(x,y) is separable if it can be written as g(x)*h(y)

  # Examples

  ```rust
  use mathhook_core::{symbol, expr};
  use mathhook_core::calculus::ode::first_order::separable::SeparableODESolver;

  let x = symbol!(x);
  let y = symbol!(y);
  let solver = SeparableODESolver::new();

  // Separable: x*y
  assert!(solver.is_separable(&expr!(x * y), &y, &x));

  // Not separable: x + y
  assert!(!solver.is_separable(&expr!(x + y), &y, &x));
  ```

  # Example: Common Separable Forms

  ```rust
  use mathhook_core::{symbol, expr};
  use mathhook_core::calculus::ode::first_order::separable::SeparableODESolver;

  let x = symbol!(x);
  let y = symbol!(y);
  let solver = SeparableODESolver::new();

  // Separable examples
  assert!(solver.is_separable(&expr!(x), &y, &x));      // dy/dx = x
  assert!(solver.is_separable(&expr!(y), &y, &x));      // dy/dx = y
  assert!(solver.is_separable(&expr!(x * y), &y, &x));  // dy/dx = xy

  // Non-separable examples
  assert!(!solver.is_separable(&expr!(x + y), &y, &x)); // dy/dx = x + y
  ``` */
  isSeparable(rhs: JsExpression, dependent: symbol, independent: symbol): boolean
}
export type JsSeparableODESolver = JsSeparableOdeSolver

export declare class JsSeparatedSolution {
  equals(other: JsSeparatedSolution): boolean
  cloneValue(): JsSeparatedSolution
}

export declare class JsSerializationError {
  cloneValue(): JsSerializationError
}

export declare class JsSeriesMethods {
  /** Compute general Taylor series using derivatives

  Taylor series: f(x) = Σ [f^(n)(a) / n!] * (x-a)^n

  For noncommutative expressions, order is preserved:
  - Derivative f^(n)(a) comes first
  - Power (x-a)^n comes second
  - Division by n! comes last */
  static generalTaylorSeries(expr: JsExpression, variable: symbol, point: JsExpression, order: number): JsExpression
  /** Compute binomial coefficient */
  static binomialCoefficient(n: number, k: number): JsExpression
  /** Get known series expansion for common functions */
  static knownSeries(functionName: string, variable: symbol, point: JsExpression, order: number): JsExpression | null
  /** Compute factorial */
  static factorial(n: number): JsExpression
  /** Evaluate expression at a specific point */
  static evaluateAtPoint(expr: JsExpression, variable: symbol, point: JsExpression): JsExpression
}

export declare class JsSeriesType {
  equals(other: JsSeriesType): boolean
  cloneValue(): JsSeriesType
}

export declare class JsSimdOptimized {

}

export declare class JsSimdStatistics {
  constructor()
  cloneValue(): JsSimdStatistics
}

export declare class JsSimpleContext {
  constructor()
  cloneValue(): JsSimpleContext
}

export declare class JsSimplificationRegistry {
  constructor()
  /** List all registered function names (for debugging) */
  listFunctions(): Array<string>
  /** Get count of registered strategies (for debugging) */
  strategyCount(): number
  /** Check if function has simplification strategy registered */
  hasStrategy(name: string): boolean
}

export declare class JsSinSimplificationStrategy {
  name(): string
}

export declare class JsSmartDisplayFormatter {
  /** Extract the positive form of a negated expression

  If the expression is negated (-1 * expr), returns the positive part.
  Otherwise returns None. */
  static extractNegatedExpression(expr: JsExpression): JsExpression | null
  /** Check if an expression is in division form

  High-level utility to detect if multiplication represents division */
  static isDivisionExpression(expr: JsExpression): boolean
  /** Check if an expression is in negated form

  This is a high-level utility that checks if an expression
  represents a negated value using the canonical Neg trait pattern. */
  static isNegatedExpression(expr: JsExpression): boolean
}

export declare class JsSmartEquationSolver {
  constructor()
  /** Legacy solve method (deprecated, use solve_with_equation instead) */
  solve(): [JsSolverResult, JsStepByStepExplanation]
  /** Solve equation with educational explanation, including equation analysis

  This is the primary entry point for solving equations with full educational
  integration. It automatically:
  1. Analyzes the equation type
  2. Explains the equation structure
  3. Selects the appropriate solver
  4. Provides step-by-step solution with explanations

  # Arguments

   * `equation` - The equation expression to solve
   * `variable` - The variable to solve for

  # Returns

  A tuple containing:
  - The solver result (solutions or error)
  - Complete step-by-step explanation starting with equation analysis */
  solveWithEquation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
}

export declare class JsSolutionMetadata {
  equals(other: JsSolutionMetadata): boolean
  cloneValue(): JsSolutionMetadata
}

export declare class JsSolverConfig {
  constructor()
  equals(other: JsSolverConfig): boolean
  cloneValue(): JsSolverConfig
}

export declare class JsSolverError {
  equals(other: JsSolverError): boolean
  cloneValue(): JsSolverError
}

export declare class JsSolverResult {
  /** Get number of solutions */
  solutionCount(): number | null
  /** Check if result represents a valid solution */
  isValidSolution(): boolean
  equals(other: JsSolverResult): boolean
  cloneValue(): JsSolverResult
}

/** Result from solveWithSteps containing both solutions and educational steps */
export declare class JsSolveWithStepsResult {
  /** Get the result type: "single", "multiple", "no_solution", "infinite", "parametric", "partial" */
  get resultType(): string
  /** Get the solution expressions */
  get solutions(): Array<JsExpression>
  /** Get the steps of the solving process */
  get steps(): Array<JsStep>
}

export declare class JsSpecialIntelligence {
  constructor()
  /** Get all properties for registration

  Returns a vector of (function_name, properties) pairs for all special
  functions. Used by UniversalFunctionRegistry for automatic registration. */
  getAllProperties(): Array<[string, JsFunctionProperties]>
}

export declare class JsSpecialProperties {
  cloneValue(): JsSpecialProperties
}

export declare class JsSpecialStepGenerator {

}

export declare class JsSpecialValue {
  cloneValue(): JsSpecialValue
}

export declare class JsSqrtIntelligence {
  constructor()
  /** Get square root function properties

  # Examples

  ```
  use mathhook_core::functions::elementary::sqrt::SqrtIntelligence;

  let intelligence = SqrtIntelligence::new();
  let props = intelligence.get_properties();
  assert!(props.contains_key("sqrt"));
  ``` */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is square root

  # Arguments

   * `name` - The function name to check

  # Examples

  ```
  use mathhook_core::functions::elementary::sqrt::SqrtIntelligence;

  let intelligence = SqrtIntelligence::new();
  assert!(intelligence.has_function("sqrt"));
  assert!(!intelligence.has_function("sin"));
  ``` */
  hasFunction(name: string): boolean
}

export declare class JsSqrtSimplificationStrategy {
  name(): string
}

export declare class JsStableCache {
  /** Get cache statistics without locks */
  static stats(): [number, number, number]
  /** Get cached result without locks */
  static get(hash: number): JsExpression | null
  /** Store result in cache without locks */
  static store(hash: number, result: JsExpression): void
}

export declare class JsStableMatrix {

}

export declare class JsStableSimd {

}
export type JsStableSIMD = JsStableSimd

export declare class JsStep {
  /** Create a new step from String arguments (FFI-friendly, no generics) */
  static fromStrings(title: string, description: string): JsStep
  equals(other: JsStep): boolean
  cloneValue(): JsStep
}

export declare class JsStepByStepExplanation {
  /** Create a new step-by-step explanation */
  constructor(steps: Array<JsStep>)
  equals(other: JsStepByStepExplanation): boolean
  cloneValue(): JsStepByStepExplanation
}

export declare class JsStrategyContext {
  constructor()
  /** Check if a strategy is currently active (would cause recursion) */
  isActive(strategy: JsIntegrationStrategy): boolean
  /** Get current recursion depth */
  depth(): number
  cloneValue(): JsStrategyContext
}

export declare class JsSummationMethods {
  /** Compute geometric series sum: Σ(ar^(i-1)) from i=1 to n

  # Formula
  Sum = a * (1 - r^n) / (1 - r) for r ≠ 1

  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static geometricSeries(firstTerm: JsExpression, commonRatio: JsExpression, numTerms: JsExpression): JsExpression
  /** Check convergence of infinite series

  Simplified p-series test: Σ(1/n^p) converges iff p > 1

  # Performance
  - **Time Complexity:** O(1) - pattern matching only
  - **Space Complexity:** O(1) - returns enum variant */
  static convergenceTest(expr: JsExpression, variable: symbol): JsConvergenceResult
  /** Compute arithmetic series sum: Σ(a + (i-1)d) from i=1 to n

  # Formula
  Sum = n/2 * (2a + (n-1)d)
  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static arithmeticSeries(firstTerm: JsExpression, commonDifference: JsExpression, numTerms: JsExpression): JsExpression
  /** Compute power sum: Σ(i^k) from i=1 to n using Faulhaber's formulas

  # Formulas (SymPy Validated)
  - k=0: Σ1 = n
  - k=1: Σi = n(n+1)/2
  - k=2: Σi² = n(n+1)(2n+1)/6
  - k=3: Σi³ = [n(n+1)/2]²

  # Performance
  - **Time Complexity:** O(1) for k ∈ {0,1,2,3}, symbolic for k > 3
  - **Space Complexity:** O(1) - constant expression construction */
  static powerSum(power: JsExpression, upperLimit: JsExpression): JsExpression
  /** Compute infinite geometric series sum: Σ(ar^(i-1)) from i=1 to ∞

  # Formula
  Sum = a / (1 - r) for |r| < 1

  # Domain Restriction
  Convergence requires |r| < 1. For |r| ≥ 1, series diverges.

  # Performance
  - **Time Complexity:** O(1) - uses closed-form formula
  - **Space Complexity:** O(1) - constant expression construction */
  static infiniteGeometricSeries(firstTerm: JsExpression, commonRatio: JsExpression): JsExpression
}

export declare class JsSvdDecomposition {
  equals(other: JsSvdDecomposition): boolean
  cloneValue(): JsSvdDecomposition
}
export type JsSVDDecomposition = JsSvdDecomposition

export declare class JsSymbol {
  /** Create a matrix symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let A = Symbol::matrix("A");
  assert_eq!(A.commutativity(), Commutativity::Noncommutative);
  ``` */
  static matrix(name: string): symbol
  /** Get the type of this symbol

  # Examples

  ```
  use mathhook_core::core::symbol::{Symbol, SymbolType};

  let x = Symbol::scalar("x");
  assert_eq!(x.symbol_type(), SymbolType::Scalar);

  let A = Symbol::matrix("A");
  assert_eq!(A.symbol_type(), SymbolType::Matrix);
  ``` */
  symbolType(): JsSymbolType
  /** Create a scalar symbol (commutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  assert_eq!(x.commutativity(), Commutativity::Commutative);
  ``` */
  static scalar(name: string): symbol
  /** Create a new scalar symbol (default behavior, backward compatible)

   **Note**: Prefer using `symbol!(x)` macro in application code.
  This method is kept for backward compatibility and internal use.

  # Examples

  ```rust
  use mathhook_core::symbol;

  let x = symbol!(x);
  let alpha = symbol!(alpha);
  ``` */
  constructor(name: string)
  /** Create an operator symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let p = Symbol::operator("p");
  assert_eq!(p.commutativity(), Commutativity::Noncommutative);
  ``` */
  static operator(name: string): symbol
  /** Create a quaternion symbol (noncommutative)

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let i = Symbol::quaternion("i");
  assert_eq!(i.commutativity(), Commutativity::Noncommutative);
  ``` */
  static quaternion(name: string): symbol
  /** Get the symbol name

  # Examples

  ```rust
  use mathhook_core::symbol;

  let x = symbol!(x);
  assert_eq!(x.name(), "x");
  ``` */
  name(): string
  /** Get commutativity of this symbol

  # Examples

  ```
  use mathhook_core::core::symbol::Symbol;
  use mathhook_core::core::commutativity::Commutativity;

  let x = Symbol::scalar("x");
  assert_eq!(x.commutativity(), Commutativity::Commutative);

  let A = Symbol::matrix("A");
  assert_eq!(A.commutativity(), Commutativity::Noncommutative);
  ``` */
  commutativity(): JsCommutativity
  equals(other: symbol): boolean
  cloneValue(): symbol
}

export declare class JsSymbolicExpander {
  cloneValue(): JsSymbolicExpander
}

export declare class JsSymbolType {
  constructor()
  equals(other: JsSymbolType): boolean
  cloneValue(): JsSymbolType
}

export declare class JsSystemSolver {
  constructor()
  solve(equation: JsExpression, variable: symbol): JsSolverResult
  canSolve(equation: JsExpression): boolean
  solveWithExplanation(equation: JsExpression, variable: symbol): [JsSolverResult, JsStepByStepExplanation]
  cloneValue(): JsSystemSolver
}

export declare class JsTanSimplificationStrategy {
  name(): string
}

export declare class JsThreeTermRecurrence {
  cloneValue(): JsThreeTermRecurrence
}

export declare class JsTokenCategory {
  equals(other: JsTokenCategory): boolean
  cloneValue(): JsTokenCategory
}

export declare class JsTrigonometricIntelligence {
  constructor()
  /** Get all trigonometric function properties */
  getProperties(): Record<string, JsFunctionProperties>
  /** Check if function is trigonometric */
  hasFunction(name: string): boolean
}

export declare class JsUniversalFunctionRegistry {
  constructor()
  /** Debug: List all registered functions */
  listAllFunctions(): Array<string>
  /** Check if function has mathematical intelligence */
  hasIntelligence(name: string): boolean
  /** Get function properties */
  getProperties(name: string): JsFunctionProperties | null
  /** Debug: Get registry size */
  registrySize(): number
}

export declare class JsUserProperties {
  cloneValue(): JsUserProperties
}

export declare class JsUserProperty {
  cloneValue(): JsUserProperty
}

export declare class JsValidationIssue {
  cloneValue(): JsValidationIssue
}

export declare class JsValidationLevel {
  equals(other: JsValidationLevel): boolean
  cloneValue(): JsValidationLevel
}

export declare class JsValidationMetrics {
  cloneValue(): JsValidationMetrics
}

export declare class JsValidationResult {
  cloneValue(): JsValidationResult
}

export declare class JsVerifiedConstant {
  cloneValue(): JsVerifiedConstant
}

export declare class JsVerifiedRelationship {
  cloneValue(): JsVerifiedRelationship
}

export declare class JsVersion {
  equals(other: JsVersion): boolean
  cloneValue(): JsVersion
}

export declare class JsWaveEquationSolver {
  constructor()
  priority(): number
  name(): string
  canSolve(pdeType: JsPdeType): boolean
  static withMaxTerms(maxTerms: number): JsWaveEquationSolver
  description(): string
}

export declare class JsWaveSolution {
  equals(other: JsWaveSolution): boolean
  cloneValue(): JsWaveSolution
}

export declare class JsWolframContext {
  constructor()
  cloneValue(): JsWolframContext
}

/** LU Decomposition result */
export declare class LuDecompositionResult {
  /** Get lower triangular matrix L */
  get l(): JsExpression
  /** Get upper triangular matrix U */
  get u(): JsExpression
  /** Get permutation matrix P (if pivoting was needed) */
  get p(): JsExpression | null
}
export type LUDecompositionResult = LuDecompositionResult

/** QR Decomposition result */
export declare class QrDecompositionResult {
  /** Get orthogonal matrix Q */
  get q(): JsExpression
  /** Get upper triangular matrix R */
  get r(): JsExpression
}
export type QRDecompositionResult = QrDecompositionResult

/** SVD Decomposition result */
export declare class SvdDecompositionResult {
  /** Get left singular vectors U */
  get u(): JsExpression
  /** Get singular values (diagonal matrix Σ) */
  get sigma(): JsExpression
  /** Get right singular vectors V^T */
  get vt(): JsExpression
}
export type SVDDecompositionResult = SvdDecompositionResult

/** Evaluate absolute value function

# Mathematical Definition

|x| = { x   if x ≥ 0
{ -x  if x < 0

# Arguments

 * `arg` - Expression to compute absolute value of

# Returns

Absolute value expression

# Examples

```
use mathhook_core::functions::elementary::abs_eval::abs;
use mathhook_core::expr;

let result = abs(&expr!(-5));
assert_eq!(result, expr!(5));
``` */
export declare function abs(arg: JsExpression): JsExpression

export declare function abs(x: JsExpression | number): JsExpression

export declare function acos(x: JsExpression | number): JsExpression

/** Get complete algorithm overview */
export declare function algorithmOverview(): string

export declare function asin(x: JsExpression | number): JsExpression

/** Assemble a RationalIntegral into a single Expression */
export declare function assembleIntegral(integral: JsRationalIntegral): JsExpression

export declare function atan(x: JsExpression | number): JsExpression

/** Bessel function of the first kind J_n(x)

# Mathematical Properties

- J_0(0) = 1, J_n(0) = 0 for n > 0
- J_{-n}(x) = (-1)^n J_n(x)
- Recurrence: J_{n+1}(x) = (2n/x)J_n(x) - J_{n-1}(x)

# Examples

```rust
use mathhook_core::functions::special::bessel_j;
use mathhook_core::{Expression, Number};

let j0 = bessel_j(0, &Expression::Number(Number::Integer(0)));
assert_eq!(j0, Expression::Number(Number::Integer(1)));
``` */
export declare function besselJ(n: number, x: JsExpression): JsExpression

export declare function besselJ(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Bessel function of the second kind Y_n(x)

Y_n has logarithmic singularity at x = 0.

# Mathematical Properties

- Y_n(0) = -∞, Y_{-n}(x) = (-1)^n Y_n(x)
- Recurrence: Y_{n+1}(x) = (2n/x)Y_n(x) - Y_{n-1}(x)

# Examples

```rust
use mathhook_core::functions::special::bessel_y;
use mathhook_core::{Expression, Number};

let y0 = bessel_y(0, &Expression::Number(Number::Float(1.0)));
``` */
export declare function besselY(n: number, x: JsExpression): JsExpression

export declare function besselY(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Beta function B(a, b)

The Beta function is defined as:
B(a, b) = Γ(a)·Γ(b) / Γ(a+b)

# Mathematical Properties

- B(a, b) = B(b, a) (symmetric)
- B(a, b) = ∫₀¹ t^(a-1)·(1-t)^(b-1) dt

# Numerical Evaluation

Float inputs are evaluated numerically using Lanczos gamma approximation.
Mixed Float/Integer inputs are converted to numerical evaluation.

# Arguments

 * `a` - First parameter
 * `b` - Second parameter

# Examples

```rust
use mathhook_core::{Expression, Number};
use mathhook_core::functions::special::beta;

let a = Expression::Number(Number::Integer(2));
let b = Expression::Number(Number::Integer(3));
let result = beta(&a, &b);

let a_float = Expression::Number(Number::Float(2.5));
let b_float = Expression::Number(Number::Float(3.7));
let result_num = beta(&a_float, &b_float);
``` */
export declare function beta(a: JsExpression, b: JsExpression): JsExpression

export declare function beta(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Numerically evaluates the beta function B(a, b) = Γ(a)·Γ(b)/Γ(a+b)

Uses Lanczos gamma approximation for high accuracy.

# Arguments

 * `a` - First parameter
 * `b` - Second parameter

# Examples

```rust
use mathhook_core::functions::special::beta::beta_numerical;

let result = beta_numerical(2.0, 3.0);
assert!((result - 1.0/12.0).abs() < 1e-14);
``` */
export declare function betaNumerical(a: number, b: number): number

/** Build a function expression with cached name construction

Combines function name caching with expression construction for
optimal performance in indexed function parsing.

# Examples

```rust
use mathhook_core::parser::cache::build_cached_function;
use mathhook_core::Expression;

let args = vec![Expression::integer(1), Expression::symbol("x")];
let func = build_cached_function("bessel", "j_indexed", args);
``` */
export declare function buildCachedFunction(base: string, suffix: string, args: Array<JsExpression>): JsExpression

/** Reuse Vec allocations for expression lists

Builds a `Vec<Expression>` using a thread-local buffer to minimize
heap allocations during parsing.

# Examples

```rust
use mathhook_core::parser::cache::build_expr_list;
use mathhook_core::Expression;

let exprs = vec![Expression::integer(1), Expression::integer(2)];
let result = build_expr_list(exprs);
```

# Performance

- Reuses pre-allocated Vec capacity
- Single clone operation instead of multiple allocations
- Thread-local storage avoids synchronization overhead */
export declare function buildExprList(exprs: Array<JsExpression>): Array<JsExpression>

/** Build differential extension tower for expression

Analyzes the expression structure and identifies transcendental
extensions (exponentials and logarithms).

# Arguments

 * `expr` - The expression to analyze
 * `var` - The variable of integration

# Examples

```rust
use mathhook_core::calculus::integrals::risch::differential_extension::build_extension_tower;
use mathhook_core::Expression;
use mathhook_core::symbol;

let x = symbol!(x);
let expr = Expression::function("exp", vec![Expression::symbol(x.clone())]);
let tower = build_extension_tower(&expr, x);
assert!(tower.is_some());
``` */
export declare function buildExtensionTower(expr: JsExpression, var: symbol): Array<JsDifferentialExtension> | null

/** Cache a computation result */
export declare function cacheResult(exprHash: number, result: JsExpression): void

/** Get comprehensive cache statistics for monitoring */
export declare function cacheStats(): JsCacheStatistics

/** Ceiling function (round up to nearest integer)

# Mathematical Definition

ceil(x) = ⌈x⌉ = smallest integer ≥ x

# Arguments

 * `arg` - Expression to ceil

# Returns

Ceiling expression

# Examples

```
use mathhook_core::functions::elementary::rounding::ceil;
use mathhook_core::{expr, Expression};

assert_eq!(ceil(&Expression::float(3.2)), Expression::integer(4));
assert_eq!(ceil(&Expression::float(-2.7)), Expression::integer(-2));
``` */
export declare function ceil(arg: JsExpression): JsExpression

export declare function ceil(x: JsExpression | number): JsExpression

/** Classify a PDE and return its type */
export declare function classifyPde(pde: JsPde): JsPdeType

/** Clear background computation cache */
export declare function clearBackgroundCompute(): void

/** Clear the global cache */
export declare function clearCache(): void

/** Clear all thread-local caches

Useful for testing or when memory usage needs to be minimized.
Should rarely be needed in normal operation. */
export declare function clearCaches(): void

/** Clear persistent cache */
export declare function clearPersistentCache(): void

/** Compute hash for expression (for memoization) */
export declare function computeExprHash(expr: JsExpression): number

/** Compute Heaviside coefficient for repeated linear factors

For `(x-r)^n` in denominator, coefficient k is:
```text
Aₖ = (1/(n-k)!) · [d^(n-k)/dx^(n-k) of g(x)]|ₓ₌ᵣ
```
where `g(x) = (x-r)^n · P(x)/Q(x)`

# Arguments

 * `numerator` - Numerator polynomial `P(x)`
 * `denominator` - Full denominator `Q(x)`
 * `root` - The root `r`
 * `total_power` - Multiplicity `n`
 * `k` - Coefficient index (1 to n)
 * `var` - Integration variable

# Returns

The coefficient `Aₖ` or `None` if computation fails

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::linear::compute_heaviside_coefficient;

let x = symbol!(x);
let numerator = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-1),
]),
Expression::integer(3),
);
let root = Expression::integer(1);

let coeff = compute_heaviside_coefficient(&numerator, &denominator, &root, 3, 1, &x);
assert!(coeff.is_some());
``` */
export declare function computeHeavisideCoefficient(numerator: JsExpression, denominator: JsExpression, root: JsExpression, totalPower: number, k: number, var: symbol): JsExpression | null

export declare function cos(x: JsExpression | number): JsExpression

/** Evaluate hyperbolic cosine cosh(x)

# Mathematical Definition

cosh(x) = (e^x + e^(-x)) / 2

# Arguments

 * `arg` - Expression to compute cosh of

# Returns

Hyperbolic cosine expression

# Examples

```
use mathhook_core::functions::elementary::hyperbolic_eval::cosh;
use mathhook_core::expr;

let result = cosh(&expr!(0));
assert_eq!(result, expr!(1));
``` */
export declare function cosh(arg: JsExpression): JsExpression

export declare function cosh(x: JsExpression | number): JsExpression

/** Get polynomial degree

# Mathematical Definition

degree(p(x)) = highest power of x in polynomial p

# Arguments

 * `poly` - Polynomial expression
 * `var` - Variable to check degree for

# Returns

Degree as integer expression or symbolic

# Examples

```ignore
use mathhook_core::functions::polynomials::polynomial_eval::degree;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let poly = expr!((x ^ 3) + (2 * (x ^ 2)) + x + 1);
let deg = degree(&poly, &x);
assert_eq!(deg, expr!(3));
``` */
export declare function degree(poly: JsExpression, var: symbol): JsExpression

/**
 * Get polynomial degree with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to check degree for
 *
 * # Returns
 *
 * Degree as integer expression or symbolic
 *
 * # Examples
 *
 * ```javascript
 * const { degree, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^3 + 2*x^2 + x + 1');
 * const deg = degree(poly, 'x');  // Returns 3
 * ```
 */
export declare function degree(poly: JsExpression, variable: string): JsExpression

/** Digamma function ψ(z) = Γ'(z)/Γ(z)

The digamma function is the logarithmic derivative of the Gamma function:
ψ(z) = d/dz ln(Γ(z))

# Mathematical Properties

- ψ(1) = -γ (Euler-Mascheroni constant ≈ -0.5772156649)
- ψ(n+1) = ψ(n) + 1/n for positive integers n
- ψ(z+1) = ψ(z) + 1/z (recurrence relation)
- ψ(1/2) = -γ - ln(4)

# Implementation

Uses reflection formula for z < 0.5 and series expansion for z ≥ 0.5.
Special values are computed exactly when possible.

# Arguments

 * `z` - Expression to evaluate digamma function at

# Examples

```rust
use mathhook_core::{Expression, Number};
use mathhook_core::functions::special::digamma;

let z = Expression::Number(Number::Integer(1));
let result = digamma(&z);
``` */
export declare function digamma(z: JsExpression): JsExpression

export declare function digamma(x: JsExpression | number): JsExpression

/** Numerically evaluates the digamma function using series expansion

Uses reflection formula for z < 0.5 and asymptotic series for z ≥ 0.5.

# Arguments

 * `z` - Value to evaluate digamma at

# Returns

ψ(z) value */
export declare function digammaNumerical(z: number): number

/** Error function erf(x)

# Mathematical Definition

erf(x) = (2/√π) ∫₀ˣ e^(-t²) dt

# Arguments

 * `arg` - Expression to compute error function of

# Returns

Error function expression

# Examples

```
use mathhook_core::functions::special::error_functions::erf;
use mathhook_core::expr;

let result = erf(&expr!(0));
assert_eq!(result, expr!(0));
``` */
export declare function erf(arg: JsExpression): JsExpression

export declare function erf(x: JsExpression | number): JsExpression

/** Complementary error function erfc(x)

# Mathematical Definition

erfc(x) = 1 - erf(x) = (2/√π) ∫ₓ^∞ e^(-t²) dt

# Arguments

 * `arg` - Expression to compute complementary error function of

# Returns

Complementary error function expression

# Examples

```
use mathhook_core::functions::special::error_functions::erfc;
use mathhook_core::expr;

let result = erfc(&expr!(0));
assert_eq!(result, expr!(1));
``` */
export declare function erfc(arg: JsExpression): JsExpression

export declare function erfc(x: JsExpression | number): JsExpression

/** Evaluate polynomial using three-term recurrence relation

Generic implementation for all orthogonal polynomials that uses the
recurrence relation defined in PolynomialProperties. This is mathematically
the most stable approach for polynomial evaluation.

# Recurrence Form

For orthogonal polynomials, the three-term recurrence has the form:
```text
P_{n+1}(x) = (alpha_n * x + beta_n) * P_n(x) + gamma_n * P_{n-1}(x)
```

# Arguments

 * `properties` - Polynomial properties containing recurrence coefficients
 * `n` - Polynomial degree (must be non-negative)
 * `x` - Evaluation point

# Returns

Numerical value of P_n(x) computed using recurrence relation

# Examples

```rust
use mathhook_core::functions::polynomials::evaluation::evaluate_recurrence;
use mathhook_core::functions::polynomials::legendre::LegendreIntelligence;
use mathhook_core::functions::properties::FunctionProperties;

let legendre = LegendreIntelligence::new();
let props = legendre.get_properties();
if let Some(FunctionProperties::Polynomial(legendre_props)) = props.get("legendre_p") {
  let result = evaluate_recurrence(legendre_props, 5, 0.5);
  assert!((result - 0.08984375).abs() < 1e-10);
}
``` */
export declare function evaluateRecurrence(properties: JsPolynomialProperties, n: number, x: number): number

/** Evaluate exponential function e^x

# Mathematical Definition

exp(x) = e^x where e ≈ 2.71828...

# Arguments

 * `arg` - Exponent expression

# Returns

Exponential expression

# Examples

```
use mathhook_core::functions::elementary::exp_eval::exp;
use mathhook_core::expr;

let result = exp(&expr!(0));
assert_eq!(result, expr!(1));
``` */
export declare function exp(arg: JsExpression): JsExpression

export declare function exp(x: JsExpression | number): JsExpression

/** Expand polynomial expression

# Mathematical Definition

expand((x+1)²) = x² + 2x + 1

# Arguments

 * `expr` - Expression to expand

# Returns

Expanded expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::expand;
use mathhook_core::expr;

let result = expand(&expr!(1));
assert_eq!(result, expr!(1));
``` */
export declare function expand(expr: JsExpression): JsExpression

/** Expand Chebyshev polynomial of the first kind T_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- T_0(x) = 1
- T_1(x) = x
- T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)

Chebyshev polynomials of the first kind are important in approximation theory
and have the explicit form T_n(x) = cos(n arccos(x)) for |x| ≤ 1.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Chebyshev polynomial T_n(x)

# Mathematical Background

Chebyshev polynomials of the first kind are solutions to:
(1-x²)y'' - xy' + n²y = 0

They are orthogonal on [-1, 1] with weight function w(x) = 1/√(1-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_chebyshev_first_symbolic;
use mathhook_core::core::Expression;

let t0 = expand_chebyshev_first_symbolic(0);
let t1 = expand_chebyshev_first_symbolic(1);
let t2 = expand_chebyshev_first_symbolic(2);
let t3 = expand_chebyshev_first_symbolic(3);
``` */
export declare function expandChebyshevFirstSymbolic(n: number): JsExpression

/** Expand Chebyshev polynomial of the second kind U_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- U_0(x) = 1
- U_1(x) = 2x
- U_{n+1}(x) = 2x U_n(x) - U_{n-1}(x)

Chebyshev polynomials of the second kind have the explicit form
U_n(x) = sin((n+1) arccos(x)) / sin(arccos(x)) for |x| < 1.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Chebyshev polynomial U_n(x)

# Mathematical Background

Chebyshev polynomials of the second kind are orthogonal on [-1, 1]
with weight function w(x) = √(1-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_chebyshev_second_symbolic;
use mathhook_core::core::Expression;

let u0 = expand_chebyshev_second_symbolic(0);
let u1 = expand_chebyshev_second_symbolic(1);
let u2 = expand_chebyshev_second_symbolic(2);
let u3 = expand_chebyshev_second_symbolic(3);
``` */
export declare function expandChebyshevSecondSymbolic(n: number): JsExpression

/** Expand Hermite polynomial H_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- H_0(x) = 1
- H_1(x) = 2x
- H_{n+1}(x) = 2x H_n(x) - 2n H_{n-1}(x)

These are the physicist's Hermite polynomials used in quantum mechanics
for the harmonic oscillator eigenfunctions.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Hermite polynomial H_n(x)

# Mathematical Background

Hermite polynomials are solutions to Hermite's differential equation:
y'' - 2xy' + 2ny = 0

They are orthogonal on (-∞, ∞) with weight function w(x) = e^(-x²).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_hermite_symbolic;
use mathhook_core::core::Expression;

let h0 = expand_hermite_symbolic(0);
let h1 = expand_hermite_symbolic(1);
let h2 = expand_hermite_symbolic(2);
let h3 = expand_hermite_symbolic(3);
``` */
export declare function expandHermiteSymbolic(n: number): JsExpression

/** Expand Laguerre polynomial L_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- L_0(x) = 1
- L_1(x) = 1 - x
- (n+1)L_{n+1}(x) = (2n+1-x)L_n(x) - nL_{n-1}(x)

These are the standard Laguerre polynomials (not generalized).

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Laguerre polynomial L_n(x)

# Mathematical Background

Laguerre polynomials are solutions to Laguerre's differential equation:
xy'' + (1-x)y' + ny = 0

They are orthogonal on [0, ∞) with weight function w(x) = e^(-x).

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_laguerre_symbolic;
use mathhook_core::core::Expression;

let l0 = expand_laguerre_symbolic(0);
let l1 = expand_laguerre_symbolic(1);
let l2 = expand_laguerre_symbolic(2);
let l3 = expand_laguerre_symbolic(3);
``` */
export declare function expandLaguerreSymbolic(n: number): JsExpression

/** Expand Legendre polynomial P_n(x) to explicit symbolic form

Uses three-term recurrence to build symbolic expression:
- P_0(x) = 1
- P_1(x) = x
- P_{n+1}(x) = [(2n+1)x P_n(x) - n P_{n-1}(x)] / (n+1)

This implementation builds the polynomial iteratively using the Expression system,
applying simplification at each step to maintain manageable expression size.

# Arguments

 * `n` - Polynomial degree (non-negative integer)

# Returns

Expression representing the expanded Legendre polynomial P_n(x)

# Mathematical Background

Legendre polynomials are solutions to Legendre's differential equation:
(1-x²)y'' - 2xy' + n(n+1)y = 0

They are orthogonal on [-1, 1] with weight function w(x) = 1.

# Examples

```rust
use mathhook_core::functions::polynomials::symbolic::expand_legendre_symbolic;
use mathhook_core::core::Expression;

let p0 = expand_legendre_symbolic(0);
let p1 = expand_legendre_symbolic(1);
let p2 = expand_legendre_symbolic(2);
let p3 = expand_legendre_symbolic(3);
``` */
export declare function expandLegendreSymbolic(n: number): JsExpression

/** Explain algorithm selection criteria for polynomial GCD

Provides educational explanation of when to use each GCD algorithm
based on polynomial characteristics. */
export declare function explainAlgorithmSelection(): string

/** Generate educational explanation for constant integration

# Arguments

 * `constant` - The constant expression
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_constant_rule;

let x = symbol!(x);
let constant = Expression::integer(5);
let explanation = explain_constant_rule(&constant, &x);
assert!(explanation.steps.len() >= 2);
``` */
export declare function explainConstantRule(constant: JsExpression, variable: symbol): JsStepByStepExplanation

/** Explain the content extraction step */
export declare function explainContentExtraction(): string

/** Explain the CRT reconstruction step */
export declare function explainCrtReconstruction(): string

/** Generate educational explanation for definite integral evaluation

# Arguments

 * `integrand` - The integrand expression
 * `variable` - The variable of integration
 * `lower_bound` - The lower limit of integration
 * `upper_bound` - The upper limit of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_definite_integral;

let x = symbol!(x);
let integrand = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let lower = Expression::integer(0);
let upper = Expression::integer(2);
let explanation = explain_definite_integral(&integrand, &x, &lower, &upper);
assert!(explanation.steps.len() >= 5);
``` */
export declare function explainDefiniteIntegral(integrand: JsExpression, variable: symbol, lowerBound: JsExpression, upperBound: JsExpression): JsStepByStepExplanation

/** Generate educational explanation for integration by parts

# Arguments

 * `u_choice` - The u function choice
 * `dv_choice` - The dv function choice
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_integration_by_parts;

let x = symbol!(x);
let u_choice = Expression::symbol(x.clone());
let dv_choice = Expression::function("exp", vec![Expression::symbol(x.clone())]);
let explanation = explain_integration_by_parts(&u_choice, &dv_choice, &x);
assert!(explanation.steps.len() >= 7);
``` */
export declare function explainIntegrationByParts(uChoice: JsExpression, dvChoice: JsExpression, variable: symbol): JsStepByStepExplanation

/** Generate step-by-step description for a specific GCD iteration

# Arguments
 * `iteration` - Current iteration number (1-based)
 * `prime` - The prime used in this iteration
 * `gcd_degree` - Degree of GCD computed mod p
 * `converged` - Whether coefficients have stabilized */
export declare function explainIterationStep(iteration: number, prime: number, gcdDegree: number, converged: boolean): string

/** Explain multivariate evaluation-interpolation */
export declare function explainMultivariateEvaluation(): string

export declare function explainPolyDivisionImpl(expr: JsExpression, divisor: JsExpression, var: symbol): JsStepByStepExplanation

export declare function explainPolyFactorizationImpl(expr: JsExpression, var: symbol): JsStepByStepExplanation

export declare function explainPolyGcdImpl(expr: JsExpression, other: JsExpression): JsStepByStepExplanation

/** Generate educational explanation for power rule integration

# Arguments

 * `base` - The base expression (typically a variable)
 * `exponent` - The exponent expression
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_power_rule;

let x = symbol!(x);
let base = Expression::symbol(x.clone());
let exponent = Expression::integer(2);
let explanation = explain_power_rule(&base, &exponent, &x);
assert!(explanation.steps.len() >= 3);
``` */
export declare function explainPowerRule(base: JsExpression, exponent: JsExpression, variable: symbol): JsStepByStepExplanation

/** Explain why a particular algorithm was chosen

# Arguments
 * `is_univariate` - Whether polynomial is univariate
 * `max_degree` - Maximum degree of input polynomials
 * `is_sparse` - Whether polynomial is sparse (density < 0.3)
 * `large_coeffs` - Whether coefficients exceed 64-bit range */
export declare function explainSelectionRationale(isUnivariate: boolean, maxDegree: number, isSparse: boolean, largeCoeffs: boolean): string

/** Explain sparse polynomial optimization */
export declare function explainSparseOptimization(): string

/** Explain trial division verification */
export declare function explainTrialDivision(): string

/** Generate educational explanation for u-substitution

# Arguments

 * `integrand` - The integrand expression
 * `substitution` - The u substitution
 * `variable` - The variable of integration

# Examples

```rust
use mathhook_core::{symbol, Expression};
use mathhook_core::calculus::integrals::educational::explain_u_substitution;

let x = symbol!(x);
let integrand = Expression::mul(vec![
Expression::integer(2),
Expression::symbol(x.clone()),
Expression::function("sin", vec![Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))]),
]);
let substitution = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let explanation = explain_u_substitution(&integrand, &substitution, &x);
assert!(explanation.steps.len() >= 6);
``` */
export declare function explainUSubstitution(integrand: JsExpression, substitution: JsExpression, variable: symbol): JsStepByStepExplanation

/** Extract division pattern from expression

Division can be represented as:
1. Mul([numerator, Pow(denominator, -1)]) for general divisions like 3/x
2. Pow(denominator, -1) for 1/x (the 1 is simplified away)

Returns Some((numerator, denominator)) if pattern matches. */
export declare function extractDivision(expr: JsExpression): [JsExpression, JsExpression] | null

/** Extract coefficients A and B from linear expression `Ax+B`

# Arguments

 * `expr` - Expression to analyze
 * `var` - Variable to extract coefficient for

# Returns

`Some((A, B))` if expression is linear, `None` otherwise

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::extract_linear_coefficients;

let x = symbol!(x);

let expr1 = Expression::add(vec![
Expression::mul(vec![Expression::integer(3), Expression::symbol(x.clone())]),
Expression::integer(5),
]);
let (a, b) = extract_linear_coefficients(&expr1, &x).unwrap();

let expr2 = Expression::integer(7);
let (a2, b2) = extract_linear_coefficients(&expr2, &x).unwrap();
``` */
export declare function extractLinearCoefficients(expr: JsExpression, var: symbol): [JsExpression, JsExpression] | null

/** Extract numerator and denominator from rational expression

# Arguments

 * `expr` - Rational expression

# Returns

Tuple `(numerator, denominator)`

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::extract_numerator_denominator;

let x = symbol!(x);
let expr = Expression::mul(vec![
Expression::integer(2),
Expression::pow(
Expression::symbol(x.clone()),
Expression::integer(-1),
),
]);

let (num, den) = extract_numerator_denominator(&expr);
``` */
export declare function extractNumeratorDenominator(expr: JsExpression): [JsExpression, JsExpression]

/** Factor polynomial expression

# Mathematical Definition

factor(x² - 1) = (x - 1)(x + 1)

# Arguments

 * `expr` - Expression to factor

# Returns

Factored expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::factor;
use mathhook_core::expr;

let result = factor(&expr!(1));
assert_eq!(result, expr!(1));
``` */
export declare function factor(expr: JsExpression): JsExpression

/** Factorial function n!

# Mathematical Definition

n! = n × (n-1) × (n-2) × ... × 2 × 1
0! = 1 by convention

# Arguments

 * `arg` - Expression to compute factorial of

# Returns

Factorial expression

# Examples

```
use mathhook_core::functions::special::factorial::factorial;
use mathhook_core::{expr, Expression};

// Factorial returns BigInteger, so we check it's a number
let result = factorial(&Expression::integer(0));
assert!(matches!(result, Expression::Number(_)));

let result2 = factorial(&Expression::integer(5));
assert!(matches!(result2, Expression::Number(_)));
``` */
export declare function factorial(arg: JsExpression): JsExpression

export declare function factorial(x: JsExpression | number): JsExpression

/** Compute factorial of a non-negative integer

# Arguments

 * `n` - Non-negative integer

# Examples

```
use mathhook_core::calculus::integrals::rational::helpers::factorial;

assert_eq!(factorial(0), 1);
assert_eq!(factorial(1), 1);
assert_eq!(factorial(5), 120);
assert_eq!(factorial(10), 3628800);
``` */
export declare function factorialWithN(n: number): number

/** Floor function (round down to nearest integer)

# Mathematical Definition

floor(x) = ⌊x⌋ = greatest integer ≤ x

# Arguments

 * `arg` - Expression to floor

# Returns

Floor expression

# Examples

```
use mathhook_core::functions::elementary::rounding::floor;
use mathhook_core::{expr, Expression};

assert_eq!(floor(&Expression::float(3.7)), Expression::integer(3));
assert_eq!(floor(&Expression::float(-2.3)), Expression::integer(-3));
``` */
export declare function floor(arg: JsExpression): JsExpression

export declare function floor(x: JsExpression | number): JsExpression

/** Gamma function Γ(z)

The Gamma function extends the factorial to complex numbers:
Γ(n) = (n-1)! for positive integers n

# Mathematical Properties

- Γ(n+1) = n·Γ(n) (functional equation)
- Γ(1) = 1
- Γ(1/2) = √π
- Pole at non-positive integers

# Numerical Evaluation

Float inputs are evaluated numerically using Lanczos approximation (14-digit precision).
Half-integers return exact symbolic forms (e.g., Γ(1/2) = √π).

# Input Validation

- NaN or infinity inputs return NaN
- Non-positive integers are poles (return symbolic or error)

# Arguments

 * `z` - Expression to evaluate gamma function at

# Examples

```rust
use mathhook_core::{Expression, Number};
use mathhook_core::functions::special::gamma;

let result = gamma(&Expression::Number(Number::Integer(5)));
assert_eq!(result, Expression::Number(Number::Integer(24)));

let half = gamma(&Expression::Number(Number::Float(0.5)));
``` */
export declare function gamma(z: JsExpression): JsExpression

export declare function gamma(x: JsExpression | number): JsExpression

export declare function gcd(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Get current adaptive thresholds from the global profiler */
export declare function getAdaptiveThresholds(): JsAdaptiveThresholds

/** Get background computation statistics */
export declare function getBackgroundComputeStatistics(): JsBackgroundComputeStatistics

/** Get a precomputed result */
export declare function getBackgroundResult(taskId: number): JsComputeResult | null

/** Get result by expression if available */
export declare function getBackgroundResultByExpression(expr: JsExpression): JsComputeResult | null

/** Efficient function name construction with caching

Constructs function names like "bessel_j_indexed" and caches them
to avoid repeated string allocations.

# Examples

```rust
use mathhook_core::parser::cache::get_cached_function_name;

let name1 = get_cached_function_name("bessel", "j_indexed");
let name2 = get_cached_function_name("bessel", "j_indexed");
// Second call reuses cached result
```

# Performance

- First call: O(n) string construction + HashMap insertion
- Subsequent calls: O(1) HashMap lookup + clone */
export declare function getCachedFunctionName(base: string, suffix: string): string

/** Get cached result for expression hash */
export declare function getCachedResult(exprHash: number): JsExpression | null

/** Get configuration statistics for monitoring */
export declare function getConfigInfo(): JsConfigInfo

/** Get the current global performance configuration */
export declare function getGlobalConfig(): JsPerformanceConfig

/** Get GPU capabilities information */
export declare function getGpuCapabilities(): JsGpuCapabilities | null

/** Get GPU acceleration statistics */
export declare function getGpuStatistics(): JsGpuStatistics

/** Get a PDE educational message by key */
export declare function getPdeMessage(key: JsPdeMessageKey): string | null

/** Get comprehensive performance metrics for monitoring and debugging

Note: SIMD and parallel statistics tracking is not yet implemented.
These fields return default values until runtime tracking is added. */
export declare function getPerformanceMetrics(): JsPerformanceMetrics

/** Get performance summary as human-readable string */
export declare function getPerformanceSummary(): string

/** Get a cached result from the global persistent cache */
export declare function getPersistentCachedResult(expressionHash: number): JsExpression | null

/** Get profiler statistics for monitoring */
export declare function getProfilerStatistics(): JsProfilerStatistics

/**
 * Compute Gröbner basis for a system of polynomials
 *
 * A Gröbner basis is a special generating set for a polynomial ideal that
 * has useful computational properties, analogous to row echelon form for matrices.
 *
 * # Arguments
 *
 * * `polynomials` - Array of polynomial expressions
 * * `variables` - Array of variable names
 * * `order` - Monomial ordering: "lex" (lexicographic), "grlex" (graded lex), or "grevlex" (graded reverse lex)
 *
 * # Examples
 *
 * ```javascript
 * const x = JsExpression.symbol("x");
 * const y = JsExpression.symbol("y");
 * const p1 = x.pow(JsExpression.integer(2)).add(y.pow(JsExpression.integer(2))).subtract(JsExpression.integer(1));
 * const p2 = x.subtract(y);
 * const basis = groebnerBasis([p1, p2], ["x", "y"], "lex");
 * // Returns Gröbner basis for the ideal generated by p1 and p2
 * ```
 */
export declare function groebnerBasis(polynomials: Array<JsExpression>, variables: Array<string>, order: string): Array<JsExpression>

/** Initialize global performance optimizer */
export declare function initPerformanceOptimizer(config: JsPerformanceConfig): void

/** Integrate linear partial fraction using Heaviside's method

For simple pole (power=1): Uses cover-up method
For repeated pole (power>1): Uses Heaviside's method with derivatives

# Mathematical Basis

For `P(x)/Q(x)` with `Q(x) = (x-r)^n · R(x)`, we want:
```text
P(x)/Q(x) = A₁/(x-r) + A₂/(x-r)² + ... + Aₙ/(x-r)ⁿ + (other terms)
```

Heaviside's method: Define `g(x) = (x-r)ⁿ · P(x)/Q(x) = P(x)/R(x)`
Then: `Aₖ = (1/(n-k)!) · [d^(n-k)/dx^(n-k) g(x)]|ₓ₌ᵣ`

# Integration Formulas

- `∫A/(x-r) dx = A·ln|x-r| + C`
- `∫A/(x-r)ⁿ dx = -A/((n-1)(x-r)^(n-1)) + C` for `n > 1`

# Arguments

 * `numerator` - Numerator polynomial `P(x)`
 * `denominator` - Full denominator `Q(x)`
 * `root` - The root `r` of the linear factor
 * `power` - Multiplicity `n` of the root
 * `var` - Integration variable

# Returns

Integrated expression or `None` if integration fails

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::linear::integrate_linear_factor;
use mathhook_core::simplify::Simplify;

let x = symbol!(x);

let numerator = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-2),
]),
Expression::integer(2),
);
let root = Expression::integer(2);

let result = integrate_linear_factor(&numerator, &denominator, &root, 2, &x);
assert!(result.is_some());
``` */
export declare function integrateLinearFactor(numerator: JsExpression, denominator: JsExpression, root: JsExpression, power: number, var: symbol): JsExpression | null

/** Integrate rational function `P(x)/Q(x)` via partial fractions

# Arguments

 * `expr` - Rational expression to integrate
 * `var` - Integration variable

# Returns

Integrated expression or `None` if not a rational function or unsupported

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::integrate_rational;

let x = symbol!(x);
let rational = Expression::mul(vec![
Expression::integer(1),
Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(-1),
]),
Expression::integer(-1),
),
]);

let result = integrate_rational(&rational, &x);
assert!(result.is_some());
``` */
export declare function integrateRational(expr: JsExpression, var: symbol): JsExpression | null

/** Integrate a rational function P(x)/Q(x)

Implements Hermite reduction algorithm for complete rational function integration.

# Arguments

 * `numerator` - Polynomial P(x)
 * `denominator` - Polynomial Q(x) (must be non-zero)
 * `var` - Variable of integration

# Algorithm

1. If deg(P) ≥ deg(Q): Perform polynomial long division
- P/Q = quotient + remainder/Q
- Integrate quotient using power rule
2. Apply Hermite reduction to remainder/Q:
- Compute D = gcd(Q, Q') where Q' is derivative
- Use extended GCD to extract logarithmic terms
- Separate into algebraic + logarithmic parts
3. Return complete integral

# Examples

```rust
use mathhook_core::calculus::integrals::risch::rational::integrate_rational;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let num = expr!((x^2) + 1);
let den = expr!(x - 1);
let result = integrate_rational(&num, &den, &x);
```

# Returns

Returns `RationalIntegral` containing:
- `polynomial_part`: Result of integrating quotient
- `logarithmic_terms`: List of (coefficient, argument) for ln terms
- `remaining`: Any unintegrated rational part (None if complete) */
export declare function integrateRationalWithNumeratorDenominatorVar(numerator: JsExpression, denominator: JsExpression, var: symbol): JsRationalIntegral

/** Integrate repeated irreducible quadratic using Ostrogradsky's reduction

For `∫(Ax+B)/(x²+px+q)^m dx` where `m > 1`, uses Ostrogradsky's formula:
```text
∫f/D^m dx = g/D^(m-1) + ∫h/D dx
```

# Mathematical Method (Ostrogradsky's Reduction)

1. Set up reduction formula with unknown linear polynomial `g = ax+b`
2. Use identity: `f = g'·D - (m-1)·g·D' + h·D^(m-1)`
3. Expand and collect coefficients to solve for `a`, `b`, `h`
4. Integrate remainder `h/D` using simple quadratic formula

# Current Implementation

Handles `m=2` case (most common). For higher powers, returns `None`.
Can be generalized using recursive Ostrogradsky reduction.

# Arguments

 * `numerator` - Numerator expression (linear in `x`)
 * `denominator` - Full denominator (for reference)
 * `p` - Linear coefficient in `x²+px+q`
 * `q` - Constant term in `x²+px+q`
 * `power` - Exponent `m` (currently only `m=2` supported)
 * `var` - Integration variable

# Returns

Integrated expression or `None` if unsupported power

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::integrate_repeated_quadratic;

let x = symbol!(x);
let numerator = Expression::integer(1);
let p = Expression::integer(0);
let q = Expression::integer(1);
let denominator = Expression::pow(
Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
q.clone(),
]),
Expression::integer(2),
);

let result = integrate_repeated_quadratic(&numerator, &denominator, &p, &q, 2, &x);
assert!(result.is_some());
```

# References

- Stewart, Calculus (8th ed), Section 7.4
- Bronstein, "Symbolic Integration I" (reduction formulas) */
export declare function integrateRepeatedQuadratic(numerator: JsExpression, denominator: JsExpression, p: JsExpression, q: JsExpression, power: number, var: symbol): JsExpression | null

/** Integrate simple irreducible quadratic `(Bx+C)/(x²+px+q)`

# Mathematical Method

For `x²+px+q` with discriminant `Δ = p²-4q < 0` (irreducible):

1. Complete the square: `x²+px+q = (x+p/2)² + a²` where `a² = q - p²/4`
2. Split integral: `∫(Bx+C)/(x²+px+q) dx = B∫x/(x²+px+q) dx + C∫1/(x²+px+q) dx`
3. Logarithmic part: `∫x/(x²+px+q) dx = (1/2)ln|x²+px+q| - (p/2)∫1/(x²+px+q) dx`
4. Arctangent part: `∫1/(x²+px+q) dx = (1/a)arctan((x+p/2)/a)`

# Current Implementation

Simplified version assumes constant numerator (B=0, C=1).

# Arguments

 * `_numerator` - Numerator (currently unused, assumes 1)
 * `_denominator` - Full denominator (for reference)
 * `p` - Linear coefficient in `x²+px+q`
 * `q` - Constant term in `x²+px+q`
 * `var` - Integration variable

# Returns

Integrated expression or `None` if quadratic is not irreducible

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::quadratic::integrate_simple_quadratic;

let x = symbol!(x);
let numerator = Expression::integer(1);
let p = Expression::integer(0);
let q = Expression::integer(1);
let denominator = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
q.clone(),
]);

let result = integrate_simple_quadratic(&numerator, &denominator, &p, &q, &x);
assert!(result.is_some());
``` */
export declare function integrateSimpleQuadratic(numerator: JsExpression, denominator: JsExpression, p: JsExpression, q: JsExpression, var: symbol): JsExpression | null

/** Main integration strategy dispatcher

Tries strategies in order from fast to slow, returning first success.

# Recursion Depth Limit

Returns symbolic integral if depth >= MAX_DEPTH (10) to prevent infinite recursion. */
export declare function integrateWithStrategy(expr: JsExpression, var: symbol, depth: number): JsExpression

/** Check if GPU acceleration is available */
export declare function isGpuAvailable(): boolean

/** Check if expression is just the variable

Returns true if the expression is exactly the given symbol variable.

# Arguments

 * `expr` - The expression to check
 * `var` - The variable symbol to compare against

# Examples

```rust
use mathhook_core::calculus::integrals::risch::helpers::is_just_variable;
use mathhook_core::{Expression, symbol};

let x = symbol!(x);
let expr = Expression::symbol(x.clone());
assert!(is_just_variable(&expr, &x));
``` */
export declare function isJustVariable(expr: JsExpression, var: symbol): boolean

/** Check if expression is the constant 1

# Arguments

 * `expr` - The expression to check

# Examples

```rust
use mathhook_core::calculus::integrals::risch::helpers::is_one;
use mathhook_core::Expression;

let one = Expression::integer(1);
assert!(is_one(&one));

let two = Expression::integer(2);
assert!(!is_one(&two));
``` */
export declare function isOne(expr: JsExpression): boolean

/** Check if expression is a polynomial in the given variable

Polynomial: only var, constants, +, *, and non-negative integer powers. */
export declare function isPolynomial(expr: JsExpression, var: symbol): boolean

/** Check if expression is a polynomial in the given variable

# Arguments

 * `expr` - The expression to check
 * `var` - The variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::is_polynomial;

let x = symbol!(x);
let poly = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::symbol(x.clone()),
Expression::integer(1),
]);

assert!(is_polynomial(&poly, &x));

let non_poly = Expression::function("sin", vec![Expression::symbol(x.clone())]);
assert!(!is_polynomial(&non_poly, &x));
``` */
export declare function isPolynomialWithExprVar(expr: JsExpression, var: symbol): boolean

/** Primality test

# Mathematical Definition

isprime(n) = true if n is prime, false otherwise

# Arguments

 * `arg` - Expression to test for primality

# Returns

Boolean expression (1 for true, 0 for false) or symbolic

# Examples

```
use mathhook_core::functions::number_theory_eval::isprime;
use mathhook_core::expr;

assert_eq!(isprime(&expr!(2)), expr!(1));
assert_eq!(isprime(&expr!(17)), expr!(1));
assert_eq!(isprime(&expr!(4)), expr!(0));
``` */
export declare function isprime(arg: JsExpression): JsExpression

export declare function isprime(x: JsExpression | number): JsExpression

/** Check if expression is a rational function

A rational function is P(x)/Q(x) where P and Q are polynomials.
This excludes transcendental functions like exp, ln, sin, cos. */
export declare function isRationalFunction(expr: JsExpression): boolean

/** Check if expression is a rational function `P(x)/Q(x)`

# Arguments

 * `expr` - Expression to check
 * `var` - Variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::is_rational_function;

let x = symbol!(x);
let rational = Expression::mul(vec![
Expression::symbol(x.clone()),
Expression::pow(
Expression::add(vec![
Expression::symbol(x.clone()),
Expression::integer(1),
]),
Expression::integer(-1),
),
]);

assert!(is_rational_function(&rational, &x));
``` */
export declare function isRationalFunctionWithExprVar(expr: JsExpression, var: symbol): boolean

/** Solver result wrapper for JavaScript */
export interface JsSolverResult {
  /** Type of result: "single", "multiple", "no_solution", "infinite_solutions" */
  resultType: string
  /** Solution expressions as strings (empty for no_solution/infinite_solutions) */
  solutions: Array<string>
  /** Number of solutions found */
  count: number
  /** Optional metadata about the solution */
  metadata?: string
}

/** Step in explanation */
export interface JsStep {
  title: string
  description: string
  before: string
  after: string
}

/** Step-by-step explanation */
export interface JsStepByStepExplanation {
  steps: Array<JsStep>
}

/** Lanczos approximation for Gamma function (for numerical evaluation)

Provides accurate numerical evaluation using the Lanczos approximation
with 14-digit precision. This is used for non-special values.

# Input Validation

- NaN or infinity inputs return NaN
- Non-positive integers (poles) return infinity

# Examples

```rust
use mathhook_core::functions::special::lanczos_gamma;

let result = lanczos_gamma(5.0);
assert!((result - 24.0).abs() < 1e-10);

let half = lanczos_gamma(0.5);
let sqrt_pi = std::f64::consts::PI.sqrt();
assert!((half - sqrt_pi).abs() < 1e-14);
``` */
export declare function lanczosGamma(z: number): number

/** Least common multiple (LCM)

# Mathematical Definition

lcm(a, b) = |a × b| / gcd(a, b)

# Arguments

 * `a` - First expression
 * `b` - Second expression

# Returns

LCM expression

# Examples

```
use mathhook_core::functions::number_theory_eval::lcm;
use mathhook_core::expr;

let result = lcm(&expr!(12), &expr!(18));
assert_eq!(result, expr!(36));
``` */
export declare function lcm(a: JsExpression, b: JsExpression): JsExpression

export declare function lcm(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Evaluate natural logarithm ln(x)

# Mathematical Definition

ln(x) = log_e(x), inverse of exp(x)

# Arguments

 * `arg` - Expression to compute logarithm of

# Returns

Logarithm expression

# Examples

```
use mathhook_core::functions::elementary::log_eval::ln;
use mathhook_core::expr;

let result = ln(&expr!(1));
assert_eq!(result, expr!(0));
``` */
export declare function ln(arg: JsExpression): JsExpression

export declare function ln(x: JsExpression | number): JsExpression

/** Evaluate base-10 logarithm log10(x)

# Mathematical Definition

log10(x) = log_10(x)

# Arguments

 * `arg` - Expression to compute logarithm of

# Returns

Logarithm expression

# Examples

```
use mathhook_core::functions::elementary::log_eval::log10;
use mathhook_core::expr;

let result = log10(&expr!(10));
assert_eq!(result, expr!(1));
``` */
export declare function log10(arg: JsExpression): JsExpression

export declare function log10(x: JsExpression | number): JsExpression

/** Check if operation size meets parallel threshold (for binding-specific use) */
export declare function meetsParallelThreshold(operationSize: number): boolean

/** Applies the method of characteristics to a first-order quasi-linear PDE

# Arguments

 * `pde` - The first-order PDE to solve: a(x,y,u)·∂u/∂x + b(x,y,u)·∂u/∂y = c(x,y,u)

# Returns

Returns `CharacteristicSolution` containing:
- Characteristic equations (dx/ds, dy/ds, du/ds)
- General solution in implicit form
- Extracted coefficients

# Examples

```ignore
use mathhook_core::calculus::pde::method_of_characteristics::method_of_characteristics;
use mathhook_core::calculus::pde::types::Pde;
use mathhook_core::{symbol, expr};

// Transport equation: ∂u/∂t + c·∂u/∂x = 0
let u = symbol!(u);
let t = symbol!(t);
let x = symbol!(x);
let equation = expr!(u);
let pde = Pde::new(equation, u, vec![t, x]);

let result = method_of_characteristics(&pde);
assert!(result.is_ok());
```

# Errors

Returns error if:
- PDE is not first-order
- Not quasi-linear form
- Coefficients are singular
- ODE solver fails */
export declare function methodOfCharacteristics(pde: JsPde): JsCharacteristicSolution

/** Modulo operation

# Mathematical Definition

a mod b = remainder when a is divided by b

# Arguments

 * `a` - Dividend expression
 * `b` - Divisor expression

# Returns

Modulo expression

# Examples

```
use mathhook_core::functions::number_theory_eval::modulo;
use mathhook_core::expr;

let result = modulo(&expr!(17), &expr!(5));
assert_eq!(result, expr!(2));
``` */
export declare function modulo(a: JsExpression, b: JsExpression): JsExpression

export declare function modulo(x: JsExpression | number, y: JsExpression | number): JsExpression

/**
 * Parse a mathematical expression from a string
 *
 * Supports multiple input formats with auto-detection:
 * - **Standard notation**: `x^2 + 2*x + 1`
 * - **LaTeX notation**: `\frac{x^2}{2} + \sin(x)`
 * - **Wolfram notation**: `Sin[x] + Cos[y]`
 * - **Implicit multiplication**: `2x`, `(a)(b)`, `2(x+1)`
 * - **Functions**: sin, cos, tan, exp, log, sqrt, and all special functions
 * - **Greek letters**: alpha, beta, gamma, theta, pi, etc.
 * - **Constants**: pi, e, i (imaginary unit)
 *
 * # Arguments
 * * `expression` - Mathematical expression string in any supported format
 *
 * # Returns
 * Parsed Expression object ready for manipulation
 *
 * # Errors
 * Returns error if the expression cannot be parsed
 *
 * # Examples
 * ```javascript
 * const { parse } = require('mathhook');
 *
 * // Basic arithmetic
 * const expr1 = parse('x^2 + 2*x + 1');
 *
 * // Implicit multiplication
 * const expr2 = parse('2x + 3y');  // Same as '2*x + 3*y'
 *
 * // Functions
 * const expr3 = parse('sin(x) + cos(y)');
 *
 * // LaTeX (auto-detected)
 * const expr4 = parse('\\frac{x^2}{2}');
 *
 * // Wolfram notation (auto-detected)
 * const expr5 = parse('Sin[x] + Cos[y]');
 *
 * // Greek letters
 * const expr6 = parse('alpha + beta');
 *
 * // Complex expressions
 * const expr7 = parse('sin(2*pi*x) + exp(-x^2/2)');
 * ```
 */
export declare function parse(expression: string): JsExpression

/** Convert PascalCase function names to snake_case

This provides a flexible, generic way to convert Wolfram function names
(like "BesselJ", "ArcSin") to consistent snake_case format.

# Examples

```rust
use mathhook_core::parser::constants::pascal_to_snake_case;

assert_eq!(pascal_to_snake_case("Sin"), "sin");
assert_eq!(pascal_to_snake_case("BesselJ"), "bessel_j");
assert_eq!(pascal_to_snake_case("ArcSin"), "arc_sin");
assert_eq!(pascal_to_snake_case("DiracDelta"), "dirac_delta");
``` */
export declare function pascalToSnakeCase(name: string): string

/** PDE Solution result */
export interface PdeSolution {
  /** Solution expression */
  solution: string
  /** Method used for solving */
  method: string
  /** Eigenvalues (for separation of variables) */
  eigenvalues?: Array<string>
  /** Fourier coefficients */
  coefficients?: Array<string>
}

/** Polygamma function ψ^(n)(z)

The polygamma function is the (n+1)-th derivative of ln(Γ(z)):
ψ^(n)(z) = d^(n+1)/dz^(n+1) ln(Γ(z))

# Special Cases

- ψ^(0)(z) = ψ(z) (digamma)
- ψ^(1)(z) = trigamma
- ψ^(2)(z) = tetragamma

# Mathematical Properties

- ψ^(1)(1) = π²/6 (trigamma at 1)
- ψ^(n)(z+1) = ψ^(n)(z) + (-1)^n · n! / z^(n+1)

# Arguments

 * `n` - Order of derivative (0 = digamma, 1 = trigamma, etc.)
 * `z` - Argument

# Examples

```rust
use mathhook_core::{Expression, Number};
use mathhook_core::functions::special::polygamma;

let result = polygamma(0, &Expression::Number(Number::Integer(1)));
let trigamma = polygamma(1, &Expression::Number(Number::Integer(1)));
``` */
export declare function polygamma(n: number, z: JsExpression): JsExpression

export declare function polygamma(x: JsExpression | number, y: JsExpression | number): JsExpression

/** Get polynomial degree with respect to a variable

# Arguments

 * `expr` - The polynomial expression
 * `var` - The variable

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::polynomial_degree;

let x = symbol!(x);
let cubic = Expression::pow(Expression::symbol(x.clone()), Expression::integer(3));
assert_eq!(polynomial_degree(&cubic, &x), 3);

let linear = Expression::symbol(x.clone());
assert_eq!(polynomial_degree(&linear, &x), 1);

let constant = Expression::integer(5);
assert_eq!(polynomial_degree(&constant, &x), 0);
``` */
export declare function polynomialDegree(expr: JsExpression, var: symbol): number

/** Unified polynomial division with automatic type routing

Returns (quotient, remainder) such that:
`dividend = divisor * quotient + remainder`

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_div;

let x = symbol!(x);
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let (quot, rem) = polynomial_div(&dividend, &divisor, &x);
``` */
export declare function polynomialDiv(dividend: JsExpression, divisor: JsExpression, var: symbol): [JsExpression, JsExpression]

/** Polynomial long division

Returns (quotient, remainder) such that:
`dividend = divisor * quotient + remainder`
and `degree(remainder) < degree(divisor)`

Uses IntPoly fast-path for univariate integer polynomials (primary path).

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by (must be non-zero)
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.
Returns `MathError::NotImplemented` for complex symbolic polynomial division.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_div;

let x = symbol!(x);
// (x^2 + 3x + 2) / (x + 1) = (x + 2) with remainder 0
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let (quot, rem) = polynomial_div(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
```

# Returns

Returns `(quotient, remainder)` tuple where both are expressions */
export declare function polynomialDivWithDividendDivisorVar(dividend: JsExpression, divisor: JsExpression, var: symbol): [JsExpression, JsExpression]

/** Evaluate polynomial at integer value for main variable

Substitutes var = value and simplifies to get a polynomial in remaining variables. */
export declare function polynomialEvaluateAt(poly: JsExpression, var: symbol, value: number): JsExpression

/** Polynomial GCD - routes to best algorithm automatically

Uses fast-path optimization to avoid expensive classification for simple cases.

# Arguments

 * `p1` - First expression
 * `p2` - Second expression

# Returns

GCD of the two expressions

# Examples

```rust
use mathhook_core::algebra::gcd::polynomial_gcd;
use mathhook_core::core::Expression;

let a = Expression::integer(12);
let b = Expression::integer(18);
let gcd = polynomial_gcd(&a, &b).unwrap();
assert_eq!(gcd, Expression::integer(6));
``` */
export declare function polynomialGcd(p1: JsExpression, p2: JsExpression): JsExpression

/** Unified polynomial GCD with automatic type routing

Analyzes coefficient types and routes to optimal implementation:
- All integers → IntPoly GCD (fastest)
- Any rationals → RationalPoly GCD (field operations)
- Symbolic → fallback to Euclidean algorithm

# Arguments
 * `a` - First polynomial
 * `b` - Second polynomial
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_gcd;

let x = symbol!(x);
let p1 = expr!((x^2) - 1);
let p2 = expr!(x - 1);
let gcd = polynomial_gcd(&p1, &p2, &x);
``` */
export declare function polynomialGcdWithABVar(a: JsExpression, b: JsExpression, var: symbol): JsExpression

/** Interpolate polynomial from integer using symmetric representation

Recovers polynomial coefficients from integer h using base x.
Uses symmetric modular representation: if coeff > x/2, use coeff - x. */
export declare function polynomialInterpolate(h: JsExpression, x: number, var: symbol): JsExpression

/** Unified polynomial quotient with automatic type routing

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_quo;

let x = symbol!(x);
let dividend = expr!((x^2) - 1);
let divisor = expr!(x - 1);
let quot = polynomial_quo(&dividend, &divisor, &x);
``` */
export declare function polynomialQuo(dividend: JsExpression, divisor: JsExpression, var: symbol): JsExpression

/** Polynomial quotient (division without remainder)

Returns only the quotient part of polynomial division

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_quo;

let x = symbol!(x);
let dividend = expr!((x^2) + (3*x) + 2);
let divisor = expr!(x + 1);
let quot = polynomial_quo(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
``` */
export declare function polynomialQuoWithDividendDivisorVar(dividend: JsExpression, divisor: JsExpression, var: symbol): JsExpression

/** Unified polynomial remainder with automatic type routing

# Arguments
 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Example
```rust
use mathhook_core::{expr, symbol};
use mathhook_core::core::polynomial::dispatch::polynomial_rem;

let x = symbol!(x);
let dividend = expr!((x^2) + 1);
let divisor = expr!(x - 1);
let rem = polynomial_rem(&dividend, &divisor, &x);
``` */
export declare function polynomialRem(dividend: JsExpression, divisor: JsExpression, var: symbol): JsExpression

/** Polynomial remainder

Returns only the remainder part of polynomial division

# Arguments

 * `dividend` - Polynomial to divide
 * `divisor` - Polynomial to divide by
 * `var` - Variable to treat as polynomial variable

# Errors

Returns `MathError::DivisionByZero` if divisor is zero.

# Examples

```rust
use mathhook_core::{expr, symbol};
use mathhook_core::algebra::polynomial_division::polynomial_rem;

let x = symbol!(x);
let dividend = expr!((x^2) + 1);
let divisor = expr!(x - 1);
let rem = polynomial_rem(&dividend, &divisor, &x)?;
# Ok::<(), mathhook_core::error::MathError>(())
``` */
export declare function polynomialRemWithDividendDivisorVar(dividend: JsExpression, divisor: JsExpression, var: symbol): JsExpression

/** Predict and precompute based on current expression */
export declare function predictAndPrecompute(currentExpr: JsExpression): void

/** Resolve special function name for indexed functions

# Examples

```rust
use mathhook_core::parser::constants::resolve_special_function;

assert_eq!(resolve_special_function("J"), Some("bessel_j"));
assert_eq!(resolve_special_function("P"), Some("legendre_p"));
assert_eq!(resolve_special_function("Unknown"), None);
``` */
export declare function resolveSpecialFunction(name: string): string | null

/** Resolve standard function name (for simple functions like sin(x))

# Examples

```rust
use mathhook_core::parser::constants::resolve_standard_function;

assert_eq!(resolve_standard_function("sin"), Some("sin"));
assert_eq!(resolve_standard_function("asin"), Some("arcsin"));
assert_eq!(resolve_standard_function("unknown"), None);
``` */
export declare function resolveStandardFunction(name: string): string | null

/** Efficient function name lookup with fallback

# Examples

```rust
use mathhook_core::parser::constants::resolve_wolfram_function;

assert_eq!(resolve_wolfram_function("Sin"), Some("sin"));
assert_eq!(resolve_wolfram_function("UnknownFunction"), None);
``` */
export declare function resolveWolframFunction(name: string): string | null

/** Find polynomial roots

# Mathematical Definition

roots(p(x)) = {x : p(x) = 0}

# Arguments

 * `poly` - Polynomial expression
 * `var` - Variable to solve for

# Returns

Set of roots or symbolic expression

# Examples

```
use mathhook_core::functions::polynomials::polynomial_eval::roots;
use mathhook_core::{expr, symbol};

let x = symbol!(x);
let poly = expr!((x ^ 2) - 1);
let r = roots(&poly, &x);
``` */
export declare function roots(poly: JsExpression, var: symbol): JsExpression

/**
 * Find polynomial roots with respect to a variable
 *
 * # Arguments
 *
 * * `poly` - Polynomial expression
 * * `variable` - Variable name to solve for
 *
 * # Returns
 *
 * Set of roots or symbolic expression
 *
 * # Examples
 *
 * ```javascript
 * const { roots, symbols, parse } = require('mathhook');
 *
 * const [x] = symbols('x');
 * const poly = parse('x^2 - 1');
 * const r = roots(poly, 'x');  // Returns roots of quadratic
 * ```
 */
export declare function roots(poly: JsExpression, variable: string): JsExpression

/** Round function (round to nearest integer)

# Mathematical Definition

round(x) rounds to nearest integer, with ties rounding away from zero

# Arguments

 * `arg` - Expression to round

# Returns

Rounded expression

# Examples

```
use mathhook_core::functions::elementary::rounding::round;
use mathhook_core::{expr, Expression};

assert_eq!(round(&Expression::float(3.4)), Expression::integer(3));
assert_eq!(round(&Expression::float(3.6)), Expression::integer(4));
assert_eq!(round(&Expression::float(3.5)), Expression::integer(4));
``` */
export declare function round(arg: JsExpression): JsExpression

export declare function round(x: JsExpression | number): JsExpression

/** Force save persistent cache to disk */
export declare function savePersistentCache(): void

/** Set global configuration for a specific binding context

Convenience method for binding crates:

```ignore
// In mathhook-node/src/lib.rs
use mathhook_core::core::performance::config::set_binding_config;
use mathhook_core::core::performance::strategy::BindingContext;

fn init_mathhook_node() {
  set_binding_config(BindingContext::NodeJs);
}
``` */
export declare function setBindingConfig(context: JsBindingContext): void

/** Set the global performance configuration

This is typically called once by binding crates during initialization:

```ignore
// In mathhook-python/src/lib.rs
use mathhook_core::core::performance::config::set_global_config;
use mathhook_core::core::performance::strategy::{PerformanceConfig, BindingContext};

#[pymodule]
fn mathhook_python(_py: Python, m: &PyModule) -> PyResult<()> {
  // Set Python-optimized configuration globally
  let config = PerformanceConfig::for_binding(BindingContext::Python);
  set_global_config(config);
  Ok(())
}
``` */
export declare function setGlobalConfig(config: JsPerformanceConfig): void

/** Smart SIMD decision: use SIMD only when beneficial */
export declare function shouldUseSimd(operationSize: number): boolean

/** Sign function

# Mathematical Definition

sign(x) = { -1  if x < 0
{  0  if x = 0
{  1  if x > 0

# Arguments

 * `arg` - Expression to compute sign of

# Returns

Sign expression (-1, 0, or 1)

# Examples

```
use mathhook_core::functions::elementary::rounding::sign;
use mathhook_core::{expr, Expression};

assert_eq!(sign(&expr!(-5)), expr!(-1));
assert_eq!(sign(&expr!(0)), expr!(0));
assert_eq!(sign(&expr!(5)), expr!(1));
``` */
export declare function sign(arg: JsExpression): JsExpression

export declare function sign(x: JsExpression | number): JsExpression

/** Simplify absolute value expressions

Applies mathematical simplification rules for absolute value.

# Simplification Rules

- |0| = 0
- |-x| = |x|
- |x²| = x² (squares are always non-negative)
- |a*b| = |a|*|b|
- |a/b| = |a|/|b|
- ||x|| = |x|

# Arguments

 * `arg` - The argument to the absolute value function

# Returns

Simplified expression

# Examples

```
use mathhook_core::core::Expression;
use mathhook_core::functions::elementary::abs::simplify_abs;

let zero = Expression::integer(0);
assert_eq!(simplify_abs(&zero), Expression::integer(0));

let neg_five = Expression::integer(-5);
assert_eq!(simplify_abs(&neg_five), Expression::integer(5));

let squared = Expression::pow(Expression::symbol("x"), Expression::integer(2));
assert_eq!(simplify_abs(&squared), squared);
``` */
export declare function simplifyAbs(arg: JsExpression): JsExpression

/** Simplify square root expressions

Applies mathematical simplification rules for square root.

# Simplification Rules

- sqrt(0) = 0
- sqrt(1) = 1
- sqrt(4) = 2, sqrt(9) = 3, etc. (perfect squares)
- sqrt(x²) = |x|
- sqrt(x⁴) = x² (even powers)
- sqrt(a*b) = sqrt(a)*sqrt(b) (when a, b ≥ 0)
- sqrt(a²*b) = a*sqrt(b) (factor perfect squares)
- sqrt(1/4) = 1/2 (rational perfect squares)

# Arguments

 * `arg` - The argument to the square root function

# Returns

Simplified expression

# Examples

```
use mathhook_core::core::Expression;
use mathhook_core::functions::elementary::sqrt::simplify_sqrt;

let zero = Expression::integer(0);
assert_eq!(simplify_sqrt(&zero), Expression::integer(0));

let four = Expression::integer(4);
assert_eq!(simplify_sqrt(&four), Expression::integer(2));

let squared = Expression::pow(Expression::symbol("x"), Expression::integer(2));
assert_eq!(
simplify_sqrt(&squared),
Expression::function("abs", vec![Expression::symbol("x")])
);
``` */
export declare function simplifySqrt(arg: JsExpression): JsExpression

export declare function sin(x: JsExpression | number): JsExpression

/** Evaluate hyperbolic sine sinh(x)

# Mathematical Definition

sinh(x) = (e^x - e^(-x)) / 2

# Arguments

 * `arg` - Expression to compute sinh of

# Returns

Hyperbolic sine expression

# Examples

```
use mathhook_core::functions::elementary::hyperbolic_eval::sinh;
use mathhook_core::expr;

let result = sinh(&expr!(0));
assert_eq!(result, expr!(0));
``` */
export declare function sinh(arg: JsExpression): JsExpression

export declare function sinh(x: JsExpression | number): JsExpression

/** Solve Sturm-Liouville eigenvalue problem with boundary conditions

Solves: X''(x) + λX(x) = 0 on [a, b] with given BCs

# Arguments

 * `bc_left` - Boundary condition at left endpoint
 * `bc_right` - Boundary condition at right endpoint
 * `num_modes` - Number of eigenvalue/eigenfunction pairs to compute

# Returns

Eigenvalues and eigenfunctions, or error if BCs are incompatible

# Examples

```rust
use mathhook_core::calculus::pde::common::eigenvalue_problem::solve_sturm_liouville;
use mathhook_core::calculus::pde::types::BoundaryCondition;
use mathhook_core::{symbol, expr};

let x = symbol!(x);
let bc_left = BoundaryCondition::dirichlet_at(x.clone(), expr!(0), expr!(0));
let bc_right = BoundaryCondition::dirichlet_at(x.clone(), expr!(pi), expr!(0));

let result = solve_sturm_liouville(&bc_left, &bc_right, 5);
assert!(result.is_ok());
let solution = result.unwrap();
assert_eq!(solution.eigenvalues.len(), 5);
``` */
export declare function solveSturmLiouville(bcLeft: JsBoundaryCondition, bcRight: JsBoundaryCondition, numModes: number): JsEigenvalueSolution

/** Evaluate square root function

# Mathematical Definition

√x = x^(1/2)

# Arguments

 * `arg` - Expression to compute square root of

# Returns

Square root expression

# Examples

```
use mathhook_core::functions::elementary::sqrt_eval::sqrt;
use mathhook_core::expr;

let result = sqrt(&expr!(4));
assert_eq!(result, expr!(2));
``` */
export declare function sqrt(arg: JsExpression): JsExpression

/**
 * Square root function
 *
 * Uses Expression::pow(expr, 1/2) internally to match SymPy's representation.
 *
 * # Arguments
 * * `x` - Expression or number to evaluate
 *
 * # Examples
 * ```javascript
 * const { sqrt, symbol } = require('mathhook');
 * const x = symbol('x');
 * const expr = sqrt(x);  // √x (represented as x^(1/2))
 * const value = sqrt(4);  // Evaluates to 2
 * ```
 */
export declare function sqrt(x: JsExpression | number): JsExpression

/** Store a result in the global persistent cache */
export declare function storePersistentCachedResult(expressionHash: number, simplified: JsExpression): void

/** Submit a task for background computation */
export declare function submitBackgroundTask(expression: JsExpression, priority: JsComputePriority, likelihood: number): number

/** Substitute a value for a variable in an expression

# Arguments

 * `expr` - The expression
 * `var` - The variable to substitute
 * `value` - The value to substitute

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::substitute_variable;
use mathhook_core::simplify::Simplify;

let x = symbol!(x);
let expr = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::integer(1),
]);

let result = substitute_variable(&expr, &x, &Expression::integer(3));
assert_eq!(result.simplify(), Expression::integer(10));
``` */
export declare function substituteVariable(expr: JsExpression, var: symbol, value: JsExpression): JsExpression

/**
 * Create a single symbol
 *
 * Creates a symbolic variable for use in mathematical expressions.
 * This is the primary way to create variables in MathHook.
 *
 * # Arguments
 *
 * * `name` - Name of the symbol (e.g., "x", "y", "theta")
 *
 * # Returns
 *
 * A JsExpression representing the symbol
 *
 * # Examples
 *
 * ```javascript
 * const { symbol } = require('mathhook-node');
 *
 * // Create a single symbol
 * const x = symbol('x');
 * const y = symbol('y');
 *
 * // Use in expressions
 * const expr = x.pow(2).add(y);
 * console.log(expr.toSimple());  // "x^2 + y"
 *
 * // Greek letters
 * const theta = symbol('θ');
 * const alpha = symbol('alpha');
 * ```
 */
export declare function symbol(name: string): JsExpression

/**
 * Create multiple symbols at once from a string specification
 *
 * Supports three input formats:
 * - Space-separated: `"x y z"` → [x, y, z]
 * - Comma-separated: `"a, b, c"` or `"a,b,c"` → [a, b, c]
 * - Range syntax: `"x0:3"` → [x0, x1, x2]
 *
 * # Arguments
 *
 * * `names` - String containing symbol names in one of the supported formats
 *
 * # Returns
 *
 * Array of JsExpression symbols
 *
 * # Examples
 *
 * ```javascript
 * // Space-separated
 * const [x, y, z] = symbols('x y z');
 *
 * // Comma-separated
 * const [a, b, c] = symbols('a, b, c');
 *
 * // Range syntax
 * const [x0, x1, x2] = symbols('x0:3');
 *
 * // Use in expressions
 * const expr = x.add(y).multiply(z);
 * ```
 */
export declare function symbols(names: string): Array<JsExpression>

export declare function tan(x: JsExpression | number): JsExpression

/** Evaluate hyperbolic tangent tanh(x)

# Mathematical Definition

tanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))

# Arguments

 * `arg` - Expression to compute tanh of

# Returns

Hyperbolic tangent expression

# Examples

```
use mathhook_core::functions::elementary::hyperbolic_eval::tanh;
use mathhook_core::expr;

let result = tanh(&expr!(0));
assert_eq!(result, expr!(0));
``` */
export declare function tanh(arg: JsExpression): JsExpression

export declare function tanh(x: JsExpression | number): JsExpression

/** Try integration by parts using the LIATE heuristic

Applies the product rule in reverse for expressions like x*exp(x). */
export declare function tryByParts(expr: JsExpression, var: symbol, depth: number): JsExpression | null

/** Try to extract quadratic coefficients from x² + px + q

Returns Some((p, q)) if expression matches x² + px + q pattern where the
coefficient of x² is exactly 1.

# Arguments

 * `expr` - The expression to analyze
 * `var` - The variable to match against

# Examples

```
use mathhook_core::{Expression, symbol};
use mathhook_core::calculus::integrals::rational::helpers::try_extract_quadratic;

let x = symbol!(x);

let quadratic = Expression::add(vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
Expression::integer(1),
]);

let result = try_extract_quadratic(&quadratic, &x);
assert!(result.is_some());
let (p, q) = result.unwrap();
assert_eq!(p, Expression::integer(2));
assert_eq!(q, Expression::integer(1));
``` */
export declare function tryExtractQuadratic(expr: JsExpression, var: symbol): [JsExpression, JsExpression] | null

/** Try function registry integration using known antiderivatives

Uses the function intelligence registry for elementary functions. */
export declare function tryRegistryIntegration(expr: JsExpression, var: symbol): JsExpression | null

/** Main Risch integration entry point

Attempts to integrate using the Risch algorithm. Returns Some(result)
if successful, or None if the integral is proven non-elementary or
cannot be determined by the basic Risch implementation.

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Examples

```rust
use mathhook_core::calculus::integrals::risch::try_risch_integration;
use mathhook_core::Expression;
use mathhook_core::symbol;

let x = symbol!(x);
let integrand = Expression::function("exp", vec![Expression::symbol(x.clone())]);

let result = try_risch_integration(&integrand, &x);
assert!(result.is_some());
``` */
export declare function tryRischIntegration(expr: JsExpression, var: symbol): JsExpression | null

/** Try to integrate using u-substitution

Automatically detects composite function patterns and applies substitution.

# Arguments

 * `expr` - The integrand expression
 * `var` - The variable of integration
 * `depth` - Current recursion depth (prevents infinite recursion)

# Returns

Some(result) if substitution succeeds, None if no suitable substitution found

# Examples

```rust
use mathhook_core::calculus::integrals::substitution::try_substitution;
use mathhook_core::symbol;
use mathhook_core::core::Expression;

let x = symbol!(x);
// ∫2x*sin(x²) dx
let integrand = Expression::mul(vec![
Expression::integer(2),
Expression::symbol(x.clone()),
Expression::function("sin", vec![
Expression::pow(Expression::symbol(x.clone()), Expression::integer(2))
])
]);

let result = try_substitution(&integrand, &x, 0);
assert!(result.is_some());
``` */
export declare function trySubstitution(expr: JsExpression, var: symbol, depth: number): JsExpression | null

/** Try to integrate expression using table lookup

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Returns

Some(integrated_expression) if pattern matches, None otherwise

# Examples

```rust
use mathhook_core::calculus::integrals::table::try_table_lookup;
use mathhook_core::{Expression, symbol};

let x = symbol!(x);
let expr = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
let result = try_table_lookup(&expr, &x);
assert!(result.is_some());
``` */
export declare function tryTableLookup(expr: JsExpression, var: symbol): JsExpression | null

/** Try to integrate trigonometric expressions

# Arguments

 * `expr` - The expression to integrate
 * `var` - The variable of integration

# Returns

Some(result) if pattern matches, None otherwise

# Examples

```rust
use mathhook_core::calculus::integrals::trigonometric::try_trigonometric_integration;
use mathhook_core::symbol;
use mathhook_core::core::Expression;

let x = symbol!(x);
// ∫sin³(x) dx
let integrand = Expression::pow(
Expression::function("sin", vec![Expression::symbol(x.clone())]),
Expression::integer(3)
);
let result = try_trigonometric_integration(&integrand, &x);
assert!(result.is_some());
``` */
export declare function tryTrigonometricIntegration(expr: JsExpression, var: symbol): JsExpression | null

/** Univariate polynomial GCD with IntPoly fast-path

Uses IntPoly for integer coefficient polynomials, falls back to Expression::gcd().

# Arguments

 * `p1` - First univariate polynomial
 * `p2` - Second univariate polynomial
 * `var` - The variable of the polynomials

# Returns

GCD of the two polynomials */
export declare function univariateGcd(p1: JsExpression, p2: JsExpression, var: symbol): JsExpression

/** Univariate polynomial GCD with cofactors

Returns (gcd, cofactor_p1, cofactor_p2) using IntPoly fast-path.

# Arguments

 * `p1` - First univariate polynomial
 * `p2` - Second univariate polynomial
 * `var` - The variable of the polynomials

# Returns

Tuple of (gcd, cofactor_p1, cofactor_p2) */
export declare function univariateGcdModular(p1: JsExpression, p2: JsExpression, var: symbol): [JsExpression, JsExpression, JsExpression]

/** Riemann zeta function ζ(s)

The Riemann zeta function extends the series Σ 1/n^s to the entire
complex plane via analytic continuation.

# Mathematical Properties

- ζ(2) = π²/6 (Basel problem)
- ζ(4) = π⁴/90
- ζ(6) = π⁶/945
- ζ(8) = π⁸/9450
- ζ(10) = π¹⁰/93555
- ζ(0) = -1/2
- ζ(-1) = -1/12 (famous result used in string theory)
- ζ(-2n) = 0 for positive integers n (trivial zeros)
- ζ(-3) = 1/120
- ζ(-5) = -1/252
- ζ(-7) = 1/240
- Pole at s=1 with residue 1
- Functional equation: ζ(s) = 2^s π^(s-1) sin(πs/2) Γ(1-s) ζ(1-s)

# Arguments

 * `s` - Expression argument to evaluate zeta function at

# Examples

```rust
use mathhook_core::functions::special::zeta;
use mathhook_core::{Expression, Number};

let zeta_2 = zeta(&Expression::Number(Number::Integer(2)));
``` */
export declare function zeta(s: JsExpression): JsExpression

export declare function zeta(x: JsExpression | number): JsExpression

/** Numerical evaluation of Riemann zeta function

Uses different algorithms depending on the value of s:
- Euler-Maclaurin acceleration for Re(s) > 1.5 (50 terms for 14-digit accuracy)
- Functional equation for Re(s) < 0
- Dirichlet eta relation for 0 < Re(s) < 1.5

# Mathematical Algorithm

For Re(s) > 1.5, uses Euler-Maclaurin acceleration:
ζ(s) = Σ(n=1 to N) 1/n^s + integral correction + Bernoulli corrections

For Re(s) < 0, uses the functional equation:
ζ(s) = 2^s π^(s-1) sin(πs/2) Γ(1-s) ζ(1-s) */
export declare function zetaNumerical(s: number): number
