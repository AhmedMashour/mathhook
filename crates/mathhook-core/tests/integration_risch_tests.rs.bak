//! Integration tests for Risch algorithm implementation
//!
//! Comprehensive test suite covering:
//! - Simple exponential functions
//! - Logarithmic derivatives
//! - Non-elementary detection
//! - Edge cases

use mathhook_core::calculus::integrals::risch::{try_risch_integration, RischResult};
use mathhook_core::calculus::integrals::risch::rde::integrate_transcendental;
use mathhook_core::calculus::integrals::risch::differential_extension::{build_extension_tower, DifferentialExtension};
use mathhook_core::core::expression::CalculusData;
use mathhook_core::Expression;
use mathhook_core::symbol;

// Simple Exponential Tests (10 tests)

#[test]
fn test_risch_simple_exp_x() {
    let x = symbol!(x);
    let integrand = Expression::function("exp", vec![Expression::symbol(x.clone())]);

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫e^x dx should succeed");
}

#[test]
fn test_risch_exp_2x() {
    let x = symbol!(x);
    let integrand = Expression::function(
        "exp",
        vec![Expression::mul(vec![
            Expression::integer(2),
            Expression::symbol(x.clone()),
        ])],
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫e^(2x) dx should succeed");
}

#[test]
fn test_risch_exp_3x() {
    let x = symbol!(x);
    let integrand = Expression::function(
        "exp",
        vec![Expression::mul(vec![
            Expression::integer(3),
            Expression::symbol(x.clone()),
        ])],
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫e^(3x) dx should succeed");
}

#[test]
fn test_risch_exp_negative_x() {
    let x = symbol!(x);
    let integrand = Expression::function(
        "exp",
        vec![Expression::mul(vec![
            Expression::integer(-1),
            Expression::symbol(x.clone()),
        ])],
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫e^(-x) dx should succeed");
}

#[test]
fn test_risch_exp_half_x() {
    let x = symbol!(x);
    let integrand = Expression::function(
        "exp",
        vec![Expression::div(Expression::symbol(x.clone()), Expression::integer(2))],
    );

    let result = try_risch_integration(&integrand, x);
    // May return None if division pattern not supported yet
    // This is acceptable for basic implementation
}

#[test]
fn test_rde_exp_x() {
    let x = symbol!(x);
    let expr = Expression::function("exp", vec![Expression::symbol(x.clone())]);
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(matches!(result, RischResult::Integral(_)), "RDE should solve e^x");
}

#[test]
fn test_rde_exp_2x() {
    let x = symbol!(x);
    let expr = Expression::function(
        "exp",
        vec![Expression::mul(vec![
            Expression::integer(2),
            Expression::symbol(x.clone()),
        ])],
    );
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(matches!(result, RischResult::Integral(_)), "RDE should solve e^(2x)");
}

#[test]
fn test_rde_exp_ax_general() {
    let x = symbol!(x);
    let expr = Expression::function(
        "exp",
        vec![Expression::mul(vec![
            Expression::integer(5),
            Expression::symbol(x.clone()),
        ])],
    );
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(matches!(result, RischResult::Integral(_)), "RDE should solve e^(ax)");
}

#[test]
fn test_tower_construction_exponential() {
    let x = symbol!(x);
    let expr = Expression::function("exp", vec![Expression::symbol(x.clone())]);

    let tower = build_extension_tower(&expr, x);
    assert!(tower.is_some(), "Should build tower for e^x");

    let extensions = tower.unwrap();
    assert!(extensions.len() >= 1, "Should have at least one extension");
}

#[test]
fn test_exponential_product_x_exp_x() {
    let x = symbol!(x);
    let integrand = Expression::mul(vec![
        Expression::symbol(x.clone()),
        Expression::function("exp", vec![Expression::symbol(x.clone())]),
    ]);
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&integrand, &extensions, x);
    assert!(
        matches!(result, RischResult::Integral(_)) || matches!(result, RischResult::Unknown),
        "x*e^x should integrate or return Unknown"
    );
}

// Logarithmic Derivative Tests (10 tests)

#[test]
fn test_risch_one_over_x() {
    let x = symbol!(x);
    let integrand = Expression::div(Expression::integer(1), Expression::symbol(x.clone()));

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/x dx should succeed");
}

#[test]
fn test_risch_one_over_2x() {
    let x = symbol!(x);
    let integrand = Expression::div(
        Expression::integer(1),
        Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/(2x) dx should succeed");
}

#[test]
fn test_risch_one_over_3x() {
    let x = symbol!(x);
    let integrand = Expression::div(
        Expression::integer(1),
        Expression::mul(vec![Expression::integer(3), Expression::symbol(x.clone())]),
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/(3x) dx should succeed");
}

#[test]
fn test_risch_one_over_x_plus_1() {
    let x = symbol!(x);
    let integrand = Expression::div(
        Expression::integer(1),
        Expression::add(vec![Expression::symbol(x.clone()), Expression::integer(1)]),
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/(x+1) dx should succeed");
}

#[test]
fn test_risch_one_over_x_plus_5() {
    let x = symbol!(x);
    let integrand = Expression::div(
        Expression::integer(1),
        Expression::add(vec![Expression::symbol(x.clone()), Expression::integer(5)]),
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/(x+5) dx should succeed");
}

#[test]
fn test_risch_one_over_2x_plus_3() {
    let x = symbol!(x);
    let integrand = Expression::div(
        Expression::integer(1),
        Expression::add(vec![
            Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
            Expression::integer(3),
        ]),
    );

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_some(), "∫1/(2x+3) dx should succeed");
}

#[test]
fn test_rde_logarithmic_derivative() {
    let x = symbol!(x);
    let expr = Expression::div(Expression::integer(1), Expression::symbol(x.clone()));
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(matches!(result, RischResult::Integral(_)), "RDE should solve 1/x");
}

#[test]
fn test_tower_construction_logarithmic() {
    let x = symbol!(x);
    let expr = Expression::div(Expression::integer(1), Expression::symbol(x.clone()));

    let tower = build_extension_tower(&expr, x);
    assert!(tower.is_some(), "Should build tower for 1/x");
}

#[test]
fn test_logarithmic_function_ln_x() {
    let x = symbol!(x);
    let expr = Expression::function("ln", vec![Expression::symbol(x.clone())]);

    let tower = build_extension_tower(&expr, x);
    assert!(tower.is_some(), "Should build tower for ln(x)");
}

#[test]
fn test_logarithmic_function_log_x() {
    let x = symbol!(x);
    let expr = Expression::function("log", vec![Expression::symbol(x.clone())]);

    let tower = build_extension_tower(&expr, x);
    assert!(tower.is_some(), "Should build tower for log(x)");
}

// Non-Elementary Detection Tests (10 tests)

#[test]
fn test_risch_non_elementary_exp_x_squared() {
    let x = symbol!(x);
    let x_squared = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
    let integrand = Expression::function("exp", vec![x_squared]);

    let result = try_risch_integration(&integrand, x);
    // Should return None (non-elementary)
    assert!(result.is_none(), "∫e^(x²) dx should be detected as non-elementary");
}

#[test]
fn test_risch_non_elementary_exp_negative_x_squared() {
    let x = symbol!(x);
    let neg_x_squared = Expression::mul(vec![
        Expression::integer(-1),
        Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
    ]);
    let integrand = Expression::function("exp", vec![neg_x_squared]);

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_none(), "∫e^(-x²) dx should be detected as non-elementary");
}

#[test]
fn test_risch_non_elementary_exp_over_x() {
    let x = symbol!(x);
    let exp_x = Expression::function("exp", vec![Expression::symbol(x.clone())]);
    let integrand = Expression::div(exp_x, Expression::symbol(x.clone()));

    let result = try_risch_integration(&integrand, x);
    assert!(result.is_none(), "∫e^x/x dx should be detected as non-elementary");
}

#[test]
fn test_risch_non_elementary_sin_over_x() {
    let x = symbol!(x);
    let sin_x = Expression::function("sin", vec![Expression::symbol(x.clone())]);
    let integrand = Expression::div(sin_x, Expression::symbol(x.clone()));

    let result = try_risch_integration(&integrand, x);
    // May return None (non-elementary) or Unknown (not handled)
    // Either is acceptable for basic implementation
}

#[test]
fn test_risch_non_elementary_one_over_ln_x() {
    let x = symbol!(x);
    let ln_x = Expression::function("ln", vec![Expression::symbol(x.clone())]);
    let integrand = Expression::div(Expression::integer(1), ln_x);

    let result = try_risch_integration(&integrand, x);
    // May return None (non-elementary) or Unknown
}

#[test]
fn test_rde_non_elementary_exp_x_squared() {
    let x = symbol!(x);
    let x_squared = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
    let expr = Expression::function("exp", vec![x_squared]);
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(
        matches!(result, RischResult::NonElementary),
        "RDE should detect e^(x²) as non-elementary"
    );
}

#[test]
fn test_rde_non_elementary_exp_over_x() {
    let x = symbol!(x);
    let exp_x = Expression::function("exp", vec![Expression::symbol(x.clone())]);
    let expr = Expression::div(exp_x, Expression::symbol(x.clone()));
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(
        matches!(result, RischResult::NonElementary),
        "RDE should detect e^x/x as non-elementary"
    );
}

#[test]
fn test_rde_non_elementary_sin_over_x() {
    let x = symbol!(x);
    let sin_x = Expression::function("sin", vec![Expression::symbol(x.clone())]);
    let expr = Expression::div(sin_x, Expression::symbol(x.clone()));
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(
        matches!(result, RischResult::NonElementary) || matches!(result, RischResult::Unknown),
        "RDE should detect sin(x)/x as non-elementary or unknown"
    );
}

#[test]
fn test_rde_non_elementary_one_over_ln_x() {
    let x = symbol!(x);
    let ln_x = Expression::function("ln", vec![Expression::symbol(x.clone())]);
    let expr = Expression::div(Expression::integer(1), ln_x);
    let extensions = vec![DifferentialExtension::Rational];

    let result = integrate_transcendental(&expr, &extensions, x);
    assert!(
        matches!(result, RischResult::NonElementary) || matches!(result, RischResult::Unknown),
        "RDE should detect 1/ln(x) as non-elementary or unknown"
    );
}

#[test]
fn test_pattern_detection_exp_x_squared() {
    let x = symbol!(x);
    let x_squared = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
    let integrand = Expression::function("exp", vec![x_squared]);
    let extensions = vec![DifferentialExtension::Rational];

    // Test that RDE detects e^(x²) as non-elementary
    let result = integrate_transcendental(&integrand, &extensions, x);
    assert!(
        matches!(result, RischResult::NonElementary),
        "Should detect e^(x²) as non-elementary"
    );
}

// Edge Cases and Integration Tests (10 tests)

#[test]
fn test_risch_constant() {
    let x = symbol!(x);
    let integrand = Expression::integer(5);

    let result = try_risch_integration(&integrand, x);
    // May return None (rational, handled by other layers)
}

#[test]
fn test_risch_linear() {
    let x = symbol!(x);
    let integrand = Expression::symbol(x.clone());

    let result = try_risch_integration(&integrand, x);
    // May return None (polynomial, handled by other layers)
}

#[test]
fn test_risch_quadratic() {
    let x = symbol!(x);
    let integrand = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));

    let result = try_risch_integration(&integrand, x);
    // May return None (polynomial, handled by other layers)
}

#[test]
fn test_risch_exp_constant() {
    let x = symbol!(x);
    let integrand = Expression::function("exp", vec![Expression::integer(5)]);

    let result = try_risch_integration(&integrand, x);
    // Should return None (constant, no variable dependence)
}

#[test]
fn test_risch_ln_constant() {
    let x = symbol!(x);
    let integrand = Expression::function("ln", vec![Expression::integer(5)]);

    let result = try_risch_integration(&integrand, x);
    // Should return None (constant)
}

#[test]
fn test_integration_via_strategy_exp_x() {
    let x = symbol!(x);
    let integrand = Expression::function("exp", vec![Expression::symbol(x.clone())]);

    use mathhook_core::calculus::integrals::Integration;
    let result = integrand.integrate(x);

    // Should succeed via Risch or other layers
    // Not a symbolic integral
    if let Expression::Calculus(data) = &result {
        match &**data {
            CalculusData::Integral { .. } => {
                panic!("Integration should not return symbolic integral for e^x");
            }
            _ => {}
        }
    }
}

#[test]
fn test_integration_via_strategy_one_over_x() {
    let x = symbol!(x);
    let integrand = Expression::div(Expression::integer(1), Expression::symbol(x.clone()));

    use mathhook_core::calculus::integrals::Integration;
    let result = integrand.integrate(x);

    // Should succeed via Risch or other layers
    if let Expression::Calculus(data) = &result {
        match &**data {
            CalculusData::Integral { .. } => {
                panic!("Integration should not return symbolic integral for 1/x");
            }
            _ => {}
        }
    }
}

#[test]
fn test_integration_via_strategy_exp_x_squared() {
    let x = symbol!(x);
    let x_squared = Expression::pow(Expression::symbol(x.clone()), Expression::integer(2));
    let integrand = Expression::function("exp", vec![x_squared]);

    use mathhook_core::calculus::integrals::Integration;
    let result = integrand.integrate(x);

    // Should return symbolic integral (non-elementary)
    let is_symbolic = if let Expression::Calculus(data) = &result {
        matches!(&**data, CalculusData::Integral { .. })
    } else {
        false
    };

    assert!(
        is_symbolic,
        "Integration of e^(x²) should return symbolic integral (non-elementary)"
    );
}

#[test]
fn test_multiple_layers_cooperation() {
    let x = symbol!(x);

    // Test that Risch plays nicely with other layers
    let test_cases = vec![
        // Simple cases (may be handled by earlier layers)
        Expression::integer(1),
        Expression::symbol(x.clone()),
        Expression::pow(Expression::symbol(x.clone()), Expression::integer(2)),
        // Risch cases
        Expression::function("exp", vec![Expression::symbol(x.clone())]),
        Expression::div(Expression::integer(1), Expression::symbol(x.clone())),
    ];

    use mathhook_core::calculus::integrals::Integration;
    for case in test_cases {
        let result = case.integrate(x.clone());
        // Should not panic
        let _ = result;
    }
}

#[test]
fn test_risch_does_not_interfere_with_polynomials() {
    let x = symbol!(x);

    // Polynomial that should be handled by basic layers
    let poly = Expression::add(vec![
        Expression::pow(Expression::symbol(x.clone()), Expression::integer(3)),
        Expression::mul(vec![Expression::integer(2), Expression::symbol(x.clone())]),
        Expression::integer(1),
    ]);

    use mathhook_core::calculus::integrals::Integration;
    let result = poly.integrate(x);

    // Should succeed (not return symbolic integral)
    if let Expression::Calculus(data) = &result {
        match &**data {
            CalculusData::Integral { .. } => {
                panic!("Polynomial integration should not return symbolic integral");
            }
            _ => {}
        }
    }
}
