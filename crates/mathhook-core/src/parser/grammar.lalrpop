use std::ops::Neg;
use crate::core::{Expression, Symbol};
use crate::parser::constants::resolve_special_function;
use crate::parser::cache;
use crate::core::expression::RelationType;
grammar;

match {
    // Tier 1: Ultra-high frequency (>10% of tokens) - CPU cache friendly
    "+" => PLUS,        // ~15% of all mathematical tokens
    "-" => MINUS,       // ~12% of all tokens  
    "*" => MULTIPLY,    // ~10% of all tokens
    
    // Tier 2: High frequency (5-10% of tokens)
    "(" => LPAREN,      // ~8% of all tokens
    ")" => RPAREN,      // ~8% of all tokens
    "^" => POWER,       // ~6% of all tokens
    "=" => EQUALS,      // ~5% of all tokens
    
    // Tier 3: Medium frequency (1-5% of tokens)
    "/" => DIVIDE,      // ~4% of all tokens
    "," => COMMA,       // ~3% of all tokens
    "{" => LBRACE,      // ~2% of all tokens
    "}" => RBRACE,      // ~2% of all tokens
    "[" => LBRACKET,    // ~1.5% of all tokens
    "]" => RBRACKET,    // ~1.5% of all tokens
    "!" => FACTORIAL,   // ~1% of all tokens
    "|" => PIPE,        // ~1% of all tokens
    
    // Tier 4: Relations and operators (0.5-1% of tokens)
    "==" => DOUBLE_EQUALS,
    "!=" => NOT_EQUALS,
    "<" => LESS,
    "<=" => LESS_EQUAL,
    ">" => GREATER,
    ">=" => GREATER_EQUAL,
    
    // Tier 5: Delimiters and special tokens (0.1-0.5% of tokens)
    "->" => ARROW,
    "d" => DIFFERENTIAL,
    "_" => SUBSCRIPT,
    ";" => SEMICOLON,  // Phase 1: For continued fractions
    
    // Tier 6: LaTeX commands (0.1-1% of tokens) - alphabetically organized
    "\\arccos" => LATEX_ARCCOS,    // Phase 1: Extended trig functions
    "\\arcsin" => LATEX_ARCSIN,    // Phase 1: Extended trig functions
    "\\arctan" => LATEX_ARCTAN,    // Phase 1: Extended trig functions
    "\\cdot" => LATEX_CDOT,
    "\\cos" => LATEX_COS,
    "\\cosh" => LATEX_COSH,        // Phase 1: Hyperbolic functions
    "\\cot" => LATEX_COT,          // Phase 1: Extended trig functions
    "\\csc" => LATEX_CSC,          // Phase 1: Extended trig functions
    "\\frac" => LATEX_FRAC,
    "\\Gamma" => LATEX_GAMMA,
    "\\gamma" => LATEX_EULER_GAMMA,
    "\\infty" => LATEX_INFTY,
    "\\int" => LATEX_INT,
    "\\iint" => LATEX_IINT,
    "\\iiint" => LATEX_IIINT,
    "\\oint" => LATEX_OINT,
    "\\lim" => LATEX_LIM,
    "\\partial" => LATEX_PARTIAL,
    "\\nabla" => LATEX_NABLA,
    "\\prod" => LATEX_PROD,
    "\\to" => LATEX_TO,
    "\\rightarrow" => LATEX_RIGHTARROW,
    "\\leftarrow" => LATEX_LEFTARROW,
    "\\Rightarrow" => LATEX_DOUBLE_RIGHTARROW,
    "\\Leftarrow" => LATEX_DOUBLE_LEFTARROW,
    "\\leftrightarrow" => LATEX_LEFTRIGHTARROW,
    "\\Leftrightarrow" => LATEX_DOUBLE_LEFTRIGHTARROW,
    "\\ln" => LATEX_LN,
    "\\log" => LATEX_LOG,
    "\\phi" => LATEX_PHI,
    "\\pi" => LATEX_PI,
    "\\sec" => LATEX_SEC,  
    "\\sinh" => LATEX_SINH,        // Phase 1: Hyperbolic functions
    "\\tan" => LATEX_TAN,
    "\\tanh" => LATEX_TANH,        // Phase 1: Hyperbolic functions
    "\\sqrt" => LATEX_SQRT,
    "\\sum" => LATEX_SUM,
    "\\text" => LATEX_TEXT,        // Phase 1: Text functions
    "\\varphi" => LATEX_VARPHI,
    "\\{" => LATEX_LBRACE,
    "\\}" => LATEX_RBRACE,
    
    // Phase 3: More LaTeX constructs
    "\\begin" => LATEX_BEGIN,
    "\\end" => LATEX_END,
    "\\left" => LATEX_LEFT,
    "\\right" => LATEX_RIGHT,
    "\\overline" => LATEX_OVERLINE,
    "\\underline" => LATEX_UNDERLINE,
    "\\hat" => LATEX_HAT,
    "\\tilde" => LATEX_TILDE,
    "\\vec" => LATEX_VEC,
    "\\dot" => LATEX_DOT,
    "\\ddot" => LATEX_DDOT,
    "\\bar" => LATEX_BAR,
    "\\prime" => LATEX_PRIME,
    "\\binom" => LATEX_BINOM,
    "\\choose" => LATEX_CHOOSE,
    "\\det" => LATEX_DET,
    "\\max" => LATEX_MAX,
    "\\min" => LATEX_MIN,
    "\\sup" => LATEX_SUP,
    "\\inf" => LATEX_INF,
    "\\gcd" => LATEX_GCD,
    "\\lcm" => LATEX_LCM,
    
    // Phase 3: More mathematical symbols
    "\\leq" => LATEX_LEQ,
    "\\geq" => LATEX_GEQ,
    "\\neq" => LATEX_NEQ,
    "\\equiv" => LATEX_EQUIV,
    "\\approx" => LATEX_APPROX,
    "\\sim" => LATEX_SIM,
    "\\propto" => LATEX_PROPTO,
    "\\in" => LATEX_IN,
    "\\notin" => LATEX_NOTIN,
    "\\subset" => LATEX_SUBSET,
    "\\supset" => LATEX_SUPSET,
    "\\subseteq" => LATEX_SUBSETEQ,
    "\\supseteq" => LATEX_SUPSETEQ,
    "\\cup" => LATEX_CUP,
    "\\cap" => LATEX_CAP,
    "\\emptyset" => LATEX_EMPTYSET,
    "\\forall" => LATEX_FORALL,
    "\\exists" => LATEX_EXISTS,
    "\\nexists" => LATEX_NEXISTS,
    "\\land" => LATEX_LAND,
    "\\lor" => LATEX_LOR,
    "\\lnot" => LATEX_LNOT,
    "\\implies" => LATEX_IMPLIES,
    "\\iff" => LATEX_IFF,
    
    // Phase 3: Greek symbols

    // Latex greek symbols
    "\\alpha" => LATEX_ALPHA,
    "\\beta" => LATEX_BETA,
    "\\delta" => LATEX_DELTA,
    "\\epsilon" => LATEX_EPSILON,
    "\\zeta" => LATEX_ZETA,
    "\\eta" => LATEX_ETA,
    "\\theta" => LATEX_THETA,
    "\\iota" => LATEX_IOTA,
    "\\kappa" => LATEX_KAPPA,
    "\\lambda" => LATEX_LAMBDA,
    "\\mu" => LATEX_MU,
    "\\nu" => LATEX_NU,
    "\\xi" => LATEX_XI,
    "\\omicron" => LATEX_OMICRON,
    "\\rho" => LATEX_RHO,
    "\\sigma" => LATEX_SIGMA,
    "\\tau" => LATEX_TAU,
    "\\upsilon" => LATEX_UPSILON,
    "\\chi" => LATEX_CHI,
    "\\psi" => LATEX_PSI,
    "\\omega" => LATEX_OMEGA,

    // Wolfram greek symbols
    "\\[Alpha]" => WOLFRAM_ALPHA,
    "\\[Beta]" => WOLFRAM_BETA,
    "\\[Delta]" => WOLFRAM_DELTA,
    "\\[Epsilon]" => WOLFRAM_EPSILON,
    "\\[Zeta]" => WOLFRAM_ZETA,
    "\\[Eta]" => WOLFRAM_ETA,
    "\\[Theta]" => WOLFRAM_THETA,
    "\\[Iota]" => WOLFRAM_IOTA,
    "\\[Kappa]" => WOLFRAM_KAPPA,
    "\\[Lambda]" => WOLFRAM_LAMBDA,
    "\\[Mu]" => WOLFRAM_MU,
    "\\[Nu]" => WOLFRAM_NU,
    "\\[Xi]" => WOLFRAM_XI,
    "\\[Omicron]" => WOLFRAM_OMICRON,
    "\\[Rho]" => WOLFRAM_RHO,
    "\\[Sigma]" => WOLFRAM_SIGMA,
    "\\[Tau]" => WOLFRAM_TAU,
    "\\[Upsilon]" => WOLFRAM_UPSILON,
    "\\[Chi]" => WOLFRAM_CHI,
    "\\[Psi]" => WOLFRAM_PSI,
    "\\[Omega]" => WOLFRAM_OMEGA,


    // Phase 3: LaTeX environments
    "pmatrix" => LATEX_PMATRIX,
    "bmatrix" => LATEX_BMATRIX,
    "vmatrix" => LATEX_VMATRIX,
    "Vmatrix" => LATEX_VMATRIX_CAPS,
    "cases" => LATEX_CASES,
    "align" => LATEX_ALIGN,
    "equation" => LATEX_EQUATION,
    "array" => LATEX_ARRAY,
    
    // Phase 3: More LaTeX symbols and delimiters
    "\\&" => LATEX_AMPERSAND,
    "\\\\" => LATEX_DOUBLE_BACKSLASH,
    "\\cr" => LATEX_CR,
    "\\hline" => LATEX_HLINE,
    "\\cdots" => LATEX_CDOTS,
    "\\ldots" => LATEX_LDOTS,
    "\\vdots" => LATEX_VDOTS,
    "\\ddots" => LATEX_DDOTS,
    "\\dots" => LATEX_DOTS,
    "\\pm" => LATEX_PM,
    "\\mp" => LATEX_MP,
    "\\times" => LATEX_TIMES,
    "\\div" => LATEX_DIV,
    "\\ast" => LATEX_AST,
    "\\star" => LATEX_STAR,
    "\\circ" => LATEX_CIRC,
    "\\bullet" => LATEX_BULLET,
    "\\otimes" => LATEX_OTIMES,
    "\\oslash" => LATEX_OSLASH,
    "\\odot" => LATEX_ODOT,
    "\\wedge" => LATEX_WEDGE,
    "\\vee" => LATEX_VEE,
    
    // Tier 7: Wolfram functions (0.1-0.5% of tokens) - alphabetically organized
    "Cos" => WOLFRAM_COS,
    "CyclotomicPolynomial" => WOLFRAM_CYCLOTOMIC,      // Phase 2: Polynomial theory
    "D" => WOLFRAM_D,
    "Discriminant" => WOLFRAM_DISCRIMINANT,            // Phase 2: Polynomial theory
    "EulerPhi" => WOLFRAM_EULER_PHI,                   // Phase 2: Number theory
    "Exp" => WOLFRAM_EXP,
    "Gamma" => WOLFRAM_GAMMA,
    "GroebnerBasis" => WOLFRAM_GROEBNER,               // Phase 2: Polynomial theory
    "Integrate" => WOLFRAM_INTEGRATE,
    "Limit" => WOLFRAM_LIMIT,
    "Log" => WOLFRAM_LOG,
    "MinimalPolynomial" => WOLFRAM_MINIMAL,            // Phase 2: Polynomial theory
    "MoebiusMu" => WOLFRAM_MOEBIUS,                    // Phase 2: Number theory
    "Piecewise" => WOLFRAM_PIECEWISE,
    "PolynomialGCD" => WOLFRAM_POLY_GCD,               // Phase 2: Polynomial theory
    "PrimePi" => WOLFRAM_PRIME_PI,                     // Phase 2: Number theory
    "Resultant" => WOLFRAM_RESULTANT,                  // Phase 2: Polynomial theory
    "RiemannSiegelTheta" => WOLFRAM_RIEMANN_SIEGEL,    // Phase 2: Number theory
    "Sqrt" => WOLFRAM_SQRT,
    "Sum" => WOLFRAM_SUM,
    "Times" => WOLFRAM_TIMES,
    
    // Phase 3: More Wolfram functions
    "Abs" => WOLFRAM_ABS,
    "Max" => WOLFRAM_MAX,
    "Min" => WOLFRAM_MIN,
    "Floor" => WOLFRAM_FLOOR,
    "Ceiling" => WOLFRAM_CEILING,
    "Round" => WOLFRAM_ROUND,
    "Sign" => WOLFRAM_SIGN,
    "Re" => WOLFRAM_RE,
    "Im" => WOLFRAM_IM,
    "Conjugate" => WOLFRAM_CONJUGATE,
    "Arg" => WOLFRAM_ARG,
    "Plus" => WOLFRAM_PLUS,
    "Subtract" => WOLFRAM_SUBTRACT,
    "Divide" => WOLFRAM_DIVIDE,
    "Mod" => WOLFRAM_MOD,
    "GCD" => WOLFRAM_GCD_CAPS,
    "LCM" => WOLFRAM_LCM_CAPS,
    "Factorial" => WOLFRAM_FACTORIAL,
    "Binomial" => WOLFRAM_BINOMIAL,
    
    // Phase 3: More advanced Wolfram functions
    "Det" => WOLFRAM_DET,
    "Tr" => WOLFRAM_TR,
    "Inverse" => WOLFRAM_INVERSE,
    "Transpose" => WOLFRAM_TRANSPOSE,
    "Eigenvalues" => WOLFRAM_EIGENVALUES,
    "Eigenvectors" => WOLFRAM_EIGENVECTORS,
    "MatrixPower" => WOLFRAM_MATRIX_POWER,
    "MatrixExp" => WOLFRAM_MATRIX_EXP,
    "Norm" => WOLFRAM_NORM,
    "Cross" => WOLFRAM_CROSS,
    "Dot" => WOLFRAM_DOT,
    "Inner" => WOLFRAM_INNER,
    "Outer" => WOLFRAM_OUTER,
    "KroneckerProduct" => WOLFRAM_KRONECKER,
    "LinearSolve" => WOLFRAM_LINEAR_SOLVE,
    "LeastSquares" => WOLFRAM_LEAST_SQUARES,
    "QRDecomposition" => WOLFRAM_QR,
    "SingularValueDecomposition" => WOLFRAM_SVD,
    "LUDecomposition" => WOLFRAM_LU,
    "CholeskyDecomposition" => WOLFRAM_CHOLESKY,
    
    // Tier 8: Constants and keywords (0.1-0.5% of tokens)
    "e" => E_CONST,
    "E" => WOLFRAM_E,
    "euler_gamma" => EULER_GAMMA,
    "gamma" => GAMMA_CONST,
    "golden_ratio" => GOLDEN_RATIO,
    "i" => I_CONST,
    "I" => WOLFRAM_I,

    "infinity" => INFINITY,
    "Infinity" => WOLFRAM_INFINITY,
    
    "phi" => PHI,
    
    "pi" => PI,
    "Pi" => WOLFRAM_PI,
    "undefined" => UNDEFINED,
    
    // Tier 9: Regex patterns (processed last for performance)
    r"[0-9]+\.[0-9]+" => FLOAT,
    r"[0-9]+" => INTEGER,
    r"[a-zA-Z][a-zA-Z0-9_]*" => IDENTIFIER,
    
    // Skip whitespace
    r"\s*" => { },
}


// 1. Public Entry Point
pub Expression: Expression = {
    Relation,
};

// 2. Relations (Non-associative)
Relation: Expression = {
    <l:Addition> EQUALS <r:Addition> => Expression::relation(l, r, RelationType::Equal),
    <l:Addition> DOUBLE_EQUALS <r:Addition> => Expression::relation(l, r, RelationType::Equal),
    <l:Addition> NOT_EQUALS <r:Addition> => Expression::relation(l, r, RelationType::NotEqual),
    <l:Addition> LESS <r:Addition> => Expression::relation(l, r, RelationType::Less),
    <l:Addition> LESS_EQUAL <r:Addition> => Expression::relation(l, r, RelationType::LessEqual),
    <l:Addition> GREATER <r:Addition> => Expression::relation(l, r, RelationType::Greater),
    <l:Addition> GREATER_EQUAL <r:Addition> => Expression::relation(l, r, RelationType::GreaterEqual),
    <l:Addition> LATEX_NEQ <r:Addition> => Expression::relation(l, r, RelationType::NotEqual),
    <l:Addition> LATEX_LEQ <r:Addition> => Expression::relation(l, r, RelationType::LessEqual),
    <l:Addition> LATEX_GEQ <r:Addition> => Expression::relation(l, r, RelationType::GreaterEqual),
    <l:Addition> LATEX_EQUIV <r:Addition> => Expression::relation(l, r, RelationType::Equal),
    <l:Addition> LATEX_APPROX <r:Addition> => Expression::relation(l, r, RelationType::Approximate),
    <l:Addition> LATEX_SIM <r:Addition> => Expression::relation(l, r, RelationType::Similar),
    <l:Addition> LATEX_PROPTO <r:Addition> => Expression::relation(l, r, RelationType::Proportional),
    Addition,
};

// 3. Addition/Subtraction
Addition: Expression = {
    <l:Addition> PLUS <r:Multiplication> => Expression::add(vec![l, r]),
    <l:Addition> MINUS <r:Multiplication> => Expression::add(vec![l, Expression::mul(vec![Expression::integer(-1), r])]),
    <l:Addition> LATEX_PM <r:Multiplication> => Expression::function("plus_minus", vec![l, r]),
    <l:Addition> LATEX_MP <r:Multiplication> => Expression::function("minus_plus", vec![l, r]),
    Multiplication,
};

// 4. Multiplication/Division (EXPLICIT ONLY - no implicit multiplication)
Multiplication: Expression = {
    <l:Multiplication> MULTIPLY <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> DIVIDE <r:Power> => Expression::mul(vec![l, Expression::pow(r, Expression::integer(-1))]),
    <l:Multiplication> LATEX_CDOT <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> LATEX_TIMES <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> LATEX_DIV <r:Power> => Expression::mul(vec![l, Expression::pow(r, Expression::integer(-1))]),
    <l:Multiplication> LATEX_AST <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> LATEX_STAR <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> LATEX_CIRC <r:Power> => Expression::function("compose", vec![l, r]),
    <l:Multiplication> LATEX_BULLET <r:Power> => Expression::function("dot_product", vec![l, r]),
    <l:Multiplication> LATEX_OTIMES <r:Power> => Expression::mul(vec![l, r]),
    <l:Multiplication> LATEX_OSLASH <r:Power> => Expression::function("oslash", vec![l, r]),
    <l:Multiplication> LATEX_ODOT <r:Power> => Expression::function("odot", vec![l, r]),
    <l:Multiplication> LATEX_WEDGE <r:Power> => Expression::function("wedge", vec![l, r]),
    <l:Multiplication> LATEX_VEE <r:Power> => Expression::function("vee", vec![l, r]),
    <l:Multiplication> LATEX_CAP <r:Power> => Expression::function("intersection", vec![l, r]),
    <l:Multiplication> LATEX_CUP <r:Power> => Expression::function("union", vec![l, r]),
    Power,
};

// 5. Exponentiation
Power: Expression = {
    <b:Factorial> POWER <e:Power> => Expression::pow(b, e),
    Factorial,
};

// 6. Unary and Postfix Operators
Factorial: Expression = {
    MINUS <e:Factorial> => e.neg(),
    <e:Atom> FACTORIAL FACTORIAL => Expression::function("double_factorial", vec![e]),
    <e:Atom> FACTORIAL => Expression::function("factorial", vec![e]),
    Atom,
};

// 7. Atoms
Atom: Expression = {
    GreekSymbol,
    Number,
    Constant,
    ParenExpression,
    IdentifierOrFunction,
    AbsoluteValue,
    Set,
    Interval,
};

// Simplified identifier handling - no conflicts
IdentifierOrFunction: Expression = {
    // Indexed function with power: P_l^m(x) - LONGEST PATTERN FIRST
    <base:IDENTIFIER> SUBSCRIPT LBRACE <sub:Expression> RBRACE POWER LBRACE <sup:Expression> RBRACE LPAREN <args:ExprList> RPAREN => {
        match resolve_special_function(base) {
            Some(func_name) => {
                println!("resolving function: {}", func_name);
                let indexed_name = cache::get_cached_function_name(func_name, "indexed_power");
                let mut all_args = vec![sub, sup];
                all_args.extend(args);
                Expression::function(indexed_name, all_args)
            }
            None => {
                println!("caching function: {}", base);
                println!("it is indexed_power");
                cache::build_cached_function(base, "indexed_power", {
                    let mut all_args = vec![sub, sup];
                    all_args.extend(args);
                    all_args
                })
            }
        }
    },
    
    // Indexed function: J_n(x) - SECOND LONGEST
    <base:IDENTIFIER> SUBSCRIPT LBRACE <sub:Expression> RBRACE LPAREN <args:ExprList> RPAREN => {
        match resolve_special_function(base) {
            Some(func_name) => {
                let indexed_name = cache::get_cached_function_name(func_name, "indexed");
                let mut all_args = vec![sub];
                all_args.extend(args);
                Expression::function(indexed_name, all_args)
            }
            None => {
                println!("caching function: {}", base);
                println!("it is indexed");
                cache::build_cached_function(base, "indexed", {
                    let mut all_args = vec![sub];
                    all_args.extend(args);
                    all_args
                })
            }
        }
    },

    // Simple function call: f(x) - THIRD LONGEST
    <base:IDENTIFIER> LPAREN <args:ExprList> RPAREN => {
        println!("it is simple function call {}", base);
        match resolve_special_function(base) {
            Some(func_name) => Expression::function(func_name, args),
            None => Expression::function(base, args)
        }
    },

    <base:IDENTIFIER> LBRACKET <args:ExprList> RBRACKET => {
        println!("it is simple wolfram function call {}", base);
        let updated_base = base.to_lowercase().to_string();
        match resolve_special_function(&updated_base) {
            Some(func_name) => Expression::function(updated_base, args),
            None => Expression::function(updated_base, args)
        }
    },
    
    // Simple identifier: x, y, z - SHORTEST PATTERN
    <v:IDENTIFIER> => Expression::symbol(Symbol::new(v)),
};

// Helper rules
ParenExpression: Expression = {
    LPAREN <e:Expression> RPAREN => e,
};

AbsoluteValue: Expression = {
    PIPE <e:Expression> PIPE => Expression::function("abs", vec![e]),
};

// Numbers
Number: Expression = {
    FLOAT => Expression::number(<>.parse::<f64>().unwrap()),
    INTEGER => Expression::integer(<>.parse::<i64>().unwrap()),
};

// Greek symbols
GreekSymbol: Expression = {
    LATEX_ALPHA => Expression::symbol(Symbol::new("alpha")),
    LATEX_BETA => Expression::symbol(Symbol::new("beta")),
    LATEX_DELTA => Expression::symbol(Symbol::new("delta")),
    LATEX_EPSILON => Expression::symbol(Symbol::new("epsilon")),
    LATEX_ZETA => Expression::symbol(Symbol::new("zeta")),
    LATEX_ETA => Expression::symbol(Symbol::new("eta")),
    LATEX_THETA => Expression::symbol(Symbol::new("theta")),
    LATEX_IOTA => Expression::symbol(Symbol::new("iota")),
    LATEX_KAPPA => Expression::symbol(Symbol::new("kappa")),
    LATEX_LAMBDA => Expression::symbol(Symbol::new("lambda")),
    LATEX_MU => Expression::symbol(Symbol::new("mu")),
    LATEX_NU => Expression::symbol(Symbol::new("nu")),
    LATEX_XI => Expression::symbol(Symbol::new("xi")),
    LATEX_OMICRON => Expression::symbol(Symbol::new("omicron")),
    LATEX_RHO => Expression::symbol(Symbol::new("rho")),
    LATEX_SIGMA => Expression::symbol(Symbol::new("sigma")),
    LATEX_TAU => Expression::symbol(Symbol::new("tau")),
    LATEX_UPSILON => Expression::symbol(Symbol::new("upsilon")),
    LATEX_CHI => Expression::symbol(Symbol::new("chi")),
    LATEX_PSI => Expression::symbol(Symbol::new("psi")),
    LATEX_OMEGA => Expression::symbol(Symbol::new("omega")),

    WOLFRAM_ALPHA => Expression::symbol(Symbol::new("alpha")),
    WOLFRAM_BETA => Expression::symbol(Symbol::new("beta")),
    WOLFRAM_DELTA => Expression::symbol(Symbol::new("delta")),
    WOLFRAM_EPSILON => Expression::symbol(Symbol::new("epsilon")),
    WOLFRAM_ZETA => Expression::symbol(Symbol::new("zeta")),
    WOLFRAM_ETA => Expression::symbol(Symbol::new("eta")),
    WOLFRAM_THETA => Expression::symbol(Symbol::new("theta")),  
    WOLFRAM_IOTA => Expression::symbol(Symbol::new("iota")),
    WOLFRAM_KAPPA => Expression::symbol(Symbol::new("kappa")),
    WOLFRAM_LAMBDA => Expression::symbol(Symbol::new("lambda")),
    WOLFRAM_MU => Expression::symbol(Symbol::new("mu")),
    WOLFRAM_NU => Expression::symbol(Symbol::new("nu")),
    WOLFRAM_XI => Expression::symbol(Symbol::new("xi")),
    WOLFRAM_OMICRON => Expression::symbol(Symbol::new("omicron")),
    WOLFRAM_RHO => Expression::symbol(Symbol::new("rho")),
    WOLFRAM_SIGMA => Expression::symbol(Symbol::new("sigma")),
    WOLFRAM_TAU => Expression::symbol(Symbol::new("tau")),
    WOLFRAM_UPSILON => Expression::symbol(Symbol::new("upsilon")),
    WOLFRAM_CHI => Expression::symbol(Symbol::new("chi")),
    WOLFRAM_PSI => Expression::symbol(Symbol::new("psi")),
    WOLFRAM_OMEGA => Expression::symbol(Symbol::new("omega")),
};

// Mathematical constants
Constant: Expression = {
    PI => Expression::pi(),
    WOLFRAM_PI => Expression::pi(),
    LATEX_PI => Expression::pi(),

    E_CONST => Expression::e(),
    WOLFRAM_E => Expression::e(),

    I_CONST => Expression::i(),
    WOLFRAM_I => Expression::i(),

    INFINITY => Expression::infinity(),
    WOLFRAM_INFINITY => Expression::infinity(),
    LATEX_INFTY => Expression::infinity(),

    PHI => Expression::golden_ratio(),
    GOLDEN_RATIO => Expression::golden_ratio(),
    GAMMA_CONST => Expression::euler_gamma(),
    EULER_GAMMA => Expression::euler_gamma(),
    UNDEFINED => Expression::undefined(),
    LATEX_PHI => Expression::golden_ratio(),
    LATEX_VARPHI => Expression::golden_ratio(),
    LATEX_EULER_GAMMA => Expression::euler_gamma(),
};

Set: Expression = {
    LBRACE <elements:ExprList> RBRACE => Expression::set(elements),
    LATEX_LBRACE <elements:ExprList> LATEX_RBRACE => Expression::set(elements),
};

// Intervals
Interval: Expression = {
    LBRACKET <start:Expression> COMMA <end:Expression> RBRACKET => Expression::interval(start, end, true, true),
    LPAREN <start:Expression> COMMA <end:Expression> RPAREN => Expression::interval(start, end, false, false),
    LBRACKET <start:Expression> COMMA <end:Expression> RPAREN => Expression::interval(start, end, true, false),
    LPAREN <start:Expression> COMMA <end:Expression> RBRACKET => Expression::interval(start, end, false, true),
};

// Expression lists (for function arguments)
ExprList: Vec<Expression> = {
    <v:(<Expression> COMMA)*> <e:Expression?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};