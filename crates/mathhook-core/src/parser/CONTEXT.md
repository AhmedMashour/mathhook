# Parser Module Context

**Purpose**: Multi-format parsing (LaTeX, Wolfram, standard notation) with implicit multiplication, symbol type inference, and zero-copy lexing

**Last Updated**: 2025-10-30

---

## Module Structure

### Files in This Module

**Core Parser** (18,800 + 1,181 lines):
- `grammar.lalrpop` (1,181 lines / ~47KB) - LALRPOP LR(1) parser grammar
- `grammar.rs` (18,800 lines) - **GENERATED FILE** (do not edit manually)
- `error.rs` (29 lines) - Parse error types
- `config.rs` (11 lines) - Parser configuration

**Lexer** (1,269 lines):
- `lexer.rs` (26 lines) - Main lexer interface
- `lexer/tokens.rs` (302 lines) - Token definitions and types
- `lexer/token_maps.rs` (96 lines) - Token type mappings
- `lexer/rules.rs` (141 lines) - Lexical rules and token categorization
- `lexer/implicit_multiplication.rs` (499 lines) - Implicit multiplication insertion (2x → 2 * x)
- `lexer/multiplication_rules.rs` (65 lines) - Fast multiplication detection rules
- `lexer/standard_tokens.rs` (101 lines) - Standard notation tokens
- `lexer/wolfram_tokens.rs` (136 lines) - Wolfram Mathematica tokens

**Constants & Caching** (745 lines):
- `constants.rs` (488 lines) - Mathematical constant resolution (π, e, i, etc.)
- `cache.rs` (257 lines) - Expression and function name caching

**Total Module Size**: ~20,795 lines (excluding generated `grammar.rs`)
**Critical Note**: `grammar.rs` (18,800 lines) is GENERATED by LALRPOP - never edit directly

---

## Public API

### Key Structs
- `pub struct ParserConfig` - Parser configuration options
- `pub struct ImplicitMultiplicationProcessor` - Handles implicit multiplication
- `pub struct CacheStats` - Parser cache statistics

### Key Enums
- `pub enum ParseError` - Parse error types (invalid syntax, unexpected token, etc.)
- `pub enum TokenType` - Token classification (number, identifier, operator, etc.)
- `pub enum Token<'input>` - Lexical tokens with source references
- `pub enum TokenCategory` - High-level token categories for rules

### Key Functions
- `pub fn parse_latex()` - Parse LaTeX mathematical notation (generated from grammar.lalrpop)
- `pub fn parse_standard()` - Parse standard notation (generated from grammar.lalrpop)
- `pub fn parse_wolfram()` - Parse Wolfram Mathematica notation (generated from grammar.lalrpop)
- `pub fn should_insert_multiplication_fast()` - Fast implicit multiplication check
- `pub fn resolve_wolfram_function()` - Wolfram function name resolution
- `pub fn resolve_special_function()` - Special function name resolution
- `pub fn resolve_standard_function()` - Standard function name resolution
- `pub fn get_cached_expression()` - Cache lookup for common expressions
- `pub fn clear_caches()` - Clear parser caches

---

## Dependencies

### Imports FROM Other Modules
**Core Types** (Critical):
- `core/expression/` - Expression enum (target of parsing)
- `core/symbol.rs` - Symbol type for variables
- `core/number.rs` - Number type for literals
- `core/constants.rs` - Mathematical constants (π, e, i)

**Functions** (Moderate):
- `functions/` - Function name resolution and validation

**Minimal External**:
- LALRPOP runtime - Parser generator runtime library

### Used BY Other Modules
**Primary Entry Point**:
- **User Interface** - Main entry point for all user input
- `educational/` - Parses user equations for solving
- `formatter/` - Round-trip: format → parse → verify

**Secondary Consumers**:
- `algebra/` - Parses equations for solving
- `calculus/` - Parses calculus notation (∫, d/dx, ∂/∂x)
- `matrix/` - Parses matrix notation

---

## Testing

### Module-Specific Test Commands
```bash
# All parser tests
cargo test -p mathhook-core parser

# Implicit multiplication tests
cargo test -p mathhook-core implicit_multiplication

# LaTeX parser tests
cargo test -p mathhook-core latex

# Wolfram parser tests
cargo test -p mathhook-core wolfram

# Cache tests
cargo test -p mathhook-core cache
```

### Test Coverage
- Unit tests: ~60 `#[test]` functions
- Integration tests: Cross-format parsing tests
- Doctests: Examples in public API

**Critical Test Cases** (from CLAUDE.md):
```rust
// Basic operations
"2+3*4"           // Should: 2 + (3 * 4) = 14
"2^3^4"           // Should: 2^(3^4) = 2^81 (right-associative)

// Implicit multiplication
"2x"              // Should: 2 * x
"2(x+1)"          // Should: 2 * (x + 1)
"(a+b)(c+d)"      // Should: (a + b) * (c + d)
"2.5x"            // Should: 2.5 * x

// Functions
"sin(x)cos(y)"    // Should: sin(x) * cos(y)
"2sin(x)"         // Should: 2 * sin(x)
"sin(x)"          // Should: sin(x) (NOT sin * x)
"log(x)/log(y)"   // Should: log(x) / log(y)

// Edge cases
"--x"             // Should: -(-x) = x (double negation)
"2+-3"            // Should: 2 + (-3) = -1
"x^-2"            // Should: x^(-2) = 1/x^2
```

---

## External References

### SymPy Equivalent
**Location**: `~/Documents/work/math/sympy/sympy/parsing/`
**Key Files**:
- `sympy/parsing/latex/` - LaTeX parser
- `sympy/parsing/mathematica.py` - Mathematica notation parser
- `sympy/parsing/sympy_parser.py` - Standard notation parser

### Symbolica Equivalent
**Location**: `~/Documents/work/math/symbolica/src/`
**Key Files**:
- `symbolica/src/parser/` - Parser implementation
- `symbolica/src/lexer.rs` - Lexical analysis

---

## Common Patterns & Pitfalls

### Design Patterns Used
1. **Two-Stage Parsing**: Lexer (tokenization) → Parser (grammar)
2. **Generated Parser**: LALRPOP generates `grammar.rs` from `grammar.lalrpop`
3. **Zero-Copy Lexing**: Tokens reference source string slices (`&str`)
4. **Implicit Multiplication**: Lexer inserts multiplication tokens before parsing
5. **Multi-Format Support**: Same Expression output from LaTeX, Wolfram, standard
6. **Symbol Type Inference**: Automatic type detection from notation (Wave 8)
   - `\mathbf{A}` → Matrix symbol
   - `\hat{p}` → Operator symbol
   - Standard → Scalar symbol

### Common Pitfalls

**CRITICAL LALRPOP CONSTRAINTS**:
1. **LR(1) Lookahead**: Only ONE token lookahead
   - Complex disambiguation needs lexer preprocessing
   - Pattern like `\frac{dy}{dx}` (derivative) vs `\frac{a}{b}` (fraction) is ambiguous

2. **Left Recursion** (FATAL):
   - **Direct**: `A: Expression = { A ... }` causes infinite loop
   - **Indirect**: `Atom → NablaOperators → Factorial → Atom` cycles forever
   - **Detection**: If `cargo build` hangs during parser generation, you have left recursion
   - **Solution**: Break cycle with restricted rule types

3. **Implicit Multiplication Handling**:
   - **Lexer handles this** - don't duplicate in grammar
   - `2x` → lexer inserts `*` → parser sees `2 * x`
   - Function calls are special: `sin(x)` does NOT get `*` inserted

4. **Operator Precedence** (highest to lowest):
   - Function application: `sin(x)`, `log(y)`
   - Exponentiation: `^` (right-associative!)
   - Multiplication/division: `*`, `/` (left-associative)
   - Addition/subtraction: `+`, `-` (left-associative)

5. **Grammar Rule Ordering**:
   - More specific patterns MUST come FIRST
   - Example: `FractionNotation` before `IdentifierOrFunction`

6. **Operator Body Expressions**:
   - Use `Atom` level for operator bodies to avoid ambiguity
   - Trade-off: Complex expressions need parentheses `\int (x^2) dx`

7. **Shift/Reduce Conflicts**:
   - LALRPOP defaults to shift
   - Check generated `grammar.rs` for conflict warnings

**General Pitfalls**:
8. **String Interning**: Use `Symbol::new()` for variable names (O(1) comparison)
9. **Number Parsing**: Preserve exactness (rationals, not floats)
10. **Constant Resolution**: π, e, i are special - use dedicated constructors

---

## CLAUDE.md Constraints (Module-Specific)

### File Size Compliance
**Current Status**: ⚠️ **SPECIAL CASE - Generated File**
- `grammar.rs` (18,800 lines) - **GENERATED by LALRPOP**
  - This is ACCEPTABLE - generated files exempt from 500-line rule
  - DO NOT edit `grammar.rs` directly - edit `grammar.lalrpop` instead
- `grammar.lalrpop` (1,181 lines / ~47KB) - **SOURCE FILE**
  - This exceeds 500 lines but is ACCEPTABLE as grammar specification
  - Splitting LALRPOP grammar would make it unmaintainable

**All other files compliant** (≤500 lines)

### Module-Specific Rules
1. **NEVER edit `grammar.rs`** - Always edit `grammar.lalrpop` and regenerate
2. **Parser regeneration command**:
   ```bash
   lalrpop crates/mathhook-core/src/parser/grammar.lalrpop
   ```
   OR
   ```bash
   cargo build -p mathhook-core
   ```
3. **Test after grammar changes**: `cargo test -p mathhook-core parser`
4. **Implicit multiplication in lexer**: Don't duplicate in grammar
5. **Zero-copy parsing**: Use `&str` slices, convert to owned types only when storing

---

## Recent Changes

### Last 3 Major Modifications
1. **Wave 8**: LaTeX parser type inference (Oct 2024)
   - Automatic symbol type detection from LaTeX notation
   - `\mathbf{A}` → Matrix, `\hat{p}` → Operator
   - 27 tests, 9.5/10 quality score

2. **Fraction Notation**: Added `\frac{num}{den}` support
   - Converts to division: `num * den^(-1)`
   - Partial derivatives: `\frac{\partial f}{\partial x}`
   - Placed early in `Atom` alternatives to prevent ambiguity

3. **Left Recursion Fix**: Fixed nabla operator cycle (Critical bug)
   - Created `NablaArgument` rule to break `Atom → NablaOperators → Factorial → Atom` cycle
   - Prevented infinite loop during parser generation

---

## Technical Debt

### Known Issues
1. **Full Derivative Notation**: Deferred due to LR(1) ambiguity
   - `\frac{d}{dx} expr` ambiguous with `\frac{dy}{dx}` until second token
   - Would require lexer preprocessing or procedural macro parser
   - **Current workaround**: Parse as regular fractions, use explicit derivative functions

2. **Grammar Size**: `grammar.lalrpop` is 1,181 lines (large grammar)
   - Acceptable but hard to navigate
   - Consider adding more inline comments for maintainability

3. **Cache Tuning**: Parser caches could be better tuned
   - Profile cache hit rates
   - Optimize cache size vs memory tradeoff

### Future Improvements
1. Procedural macro parser for complex LaTeX patterns (derivative notation)
2. Better error messages with suggested fixes
3. Parser performance profiling and optimization
4. Add more LaTeX operators (limits, summation, product)
5. Add Wolfram notebook format support
6. Incremental parsing for large expressions

---

## Integration Points

### Parsing Flow
```
User Input String
    ↓
Lexer: Tokenization + Implicit Multiplication
    ↓
LALRPOP Parser: grammar.lalrpop → grammar.rs
    ↓
Expression AST (core/expression/)
    ↓
Symbol Interning (core/symbol.rs)
    ↓
Canonical Form (simplify/)
    ↓
Output: Expression
```

### Symbol Type Inference Flow (Wave 8)
```
LaTeX Input: "\mathbf{A}\mathbf{X} = \mathbf{B}"
    ↓
Lexer: Detect \mathbf notation
    ↓
Parser: Create Symbol with Matrix type
    ↓
Equation Solver: Knows A, X, B are matrices → left division
```

### Implicit Multiplication Flow
```
Input: "2x(y+1)"
    ↓
Lexer:
  - See Number(2), Identifier(x) → Insert Multiply
  - See Identifier(x), LeftParen → Insert Multiply
    ↓
Token Stream: [Number(2), Multiply, Identifier(x), Multiply, LeftParen, ...]
    ↓
Parser: Handles as explicit multiplication
```

---

## LALRPOP Grammar Modification Guide

**When modifying `grammar.lalrpop`**:

1. **Test BEFORE cargo build**:
   ```bash
   lalrpop crates/mathhook-core/src/parser/grammar.lalrpop
   ```
   This shows LALRPOP errors immediately.

2. **Avoid Left Recursion**:
   - Check for cycles: `Atom → X → Y → Atom`
   - Create restricted rules to break cycles

3. **Order Rules Properly**:
   - More specific patterns FIRST
   - General patterns LAST

4. **Test Implicit Multiplication**:
   ```bash
   cargo test -p mathhook-core parser
   ```
   Verify: `2x`, `(a)(b)`, `2(x+1)`, `sin(x)cos(x)`

5. **Check for Shift/Reduce Conflicts**:
   - LALRPOP reports these in output
   - Review generated `grammar.rs` for warnings

6. **Document Ambiguity Resolutions**:
   - Add comments explaining why patterns are ordered
   - Note any trade-offs (e.g., requiring parentheses)

---

**Module Owner**: Core team
**Related Waves**: Wave 8 (type inference), Fraction notation enhancement, Left recursion fix
