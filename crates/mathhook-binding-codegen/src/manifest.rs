use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

/// Generated binding manifest - tracks all discovered types and their fragments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BindingManifest {
    /// Version of the manifest schema
    pub version: String,
    /// When the manifest was generated
    pub generated_at: String,
    /// Hash of mathhook-core for change detection
    pub core_hash: String,
    /// Statistics about pattern distribution
    pub pattern_stats: PatternStats,
    /// All discovered types and their binding info
    pub types: HashMap<String, TypeBindingInfo>,
    /// Standalone functions (not methods on types)
    pub standalone_functions: Vec<FunctionInfo>,
    /// Items that couldn't be bound (need manual implementation)
    pub manual_required: Vec<ManualBindingRequired>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PatternStats {
    pub direct_mappings: usize,
    pub result_types: usize,
    pub collected_iterators: usize,
    pub callback_wrappers: usize,
    pub union_generics: usize,
    pub cloned_refs: usize,
    pub unsupported_skipped: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypeBindingInfo {
    /// Core type name (e.g., "Expression")
    pub core_type: String,
    /// Python wrapper name (e.g., "PyExpression")
    pub python_wrapper: String,
    /// Node.js wrapper name (e.g., "JsExpression")
    pub node_wrapper: String,
    /// Generated fragment files for this type
    pub fragments: Vec<FragmentInfo>,
    /// Total method count across all fragments
    pub method_count: usize,
    /// Source modules that contributed methods
    pub source_modules: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FragmentInfo {
    /// Relative path from src/generated/ (e.g., "expression/algebra.rs")
    pub path: String,
    /// Source module in mathhook-core (e.g., "algebra")
    pub source_module: String,
    /// Number of methods in this fragment
    pub method_count: usize,
    /// Method names for documentation
    pub methods: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionInfo {
    /// Function name
    pub name: String,
    /// Source file in mathhook-core
    pub source_file: String,
    /// Generated fragment path
    pub fragment_path: String,
    /// Pattern type used
    pub pattern: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ManualBindingRequired {
    /// Item name
    pub name: String,
    /// Source location
    pub source: String,
    /// Why it can't be auto-bound
    pub reason: String,
    /// Pattern that was detected
    pub pattern: String,
}

impl BindingManifest {
    pub fn new(core_hash: String) -> Self {
        Self {
            version: "1.0".into(),
            generated_at: chrono::Utc::now().to_rfc3339(),
            core_hash,
            pattern_stats: PatternStats::default(),
            types: HashMap::new(),
            standalone_functions: Vec::new(),
            manual_required: Vec::new(),
        }
    }

    pub fn add_type(&mut self, info: TypeBindingInfo) {
        self.types.insert(info.core_type.clone(), info);
    }

    pub fn save<P: AsRef<Path>>(&self, path: P) -> anyhow::Result<()> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
    }

    pub fn load<P: AsRef<Path>>(path: P) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let manifest: Self = serde_json::from_str(&content)?;
        Ok(manifest)
    }

    /// Generate the include statements file for a specific type
    pub fn generate_includes_for_type(&self, type_name: &str, target: Target) -> Option<String> {
        let info = self.types.get(type_name)?;
        let mut includes = String::new();

        includes.push_str(&format!(
            "// AUTO-GENERATED by binding-codegen\n\
             // DO NOT EDIT - regenerate with `cargo run -p binding-codegen`\n\
             // Type: {} -> {}\n\
             // Generated: {}\n\n",
            info.core_type,
            match target {
                Target::Python => &info.python_wrapper,
                Target::Node => &info.node_wrapper,
            },
            self.generated_at
        ));

        for fragment in &info.fragments {
            includes.push_str(&format!(
                "// ===== {} ({} methods) =====\n",
                fragment.source_module.to_uppercase(),
                fragment.method_count
            ));
            includes.push_str(&format!("include!(\"{}\");\n\n", fragment.path));
        }

        Some(includes)
    }

    /// Generate all include files for a target
    pub fn generate_all_includes(&self, target: Target) -> HashMap<String, String> {
        let mut result = HashMap::new();

        for type_name in self.types.keys() {
            if let Some(includes) = self.generate_includes_for_type(type_name, target) {
                let filename = format!("{}_includes.rs", type_name.to_lowercase());
                result.insert(filename, includes);
            }
        }

        result
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Target {
    Python,
    Node,
}

impl Target {
    pub fn as_str(&self) -> &'static str {
        match self {
            Target::Python => "python",
            Target::Node => "node",
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_manifest_creation() {
        let mut manifest = BindingManifest::new("abc123".into());

        manifest.add_type(TypeBindingInfo {
            core_type: "Expression".into(),
            python_wrapper: "PyExpression".into(),
            node_wrapper: "JsExpression".into(),
            fragments: vec![
                FragmentInfo {
                    path: "expression/algebra.rs".into(),
                    source_module: "algebra".into(),
                    method_count: 15,
                    methods: vec!["expand".into(), "factor".into()],
                },
                FragmentInfo {
                    path: "expression/calculus.rs".into(),
                    source_module: "calculus".into(),
                    method_count: 12,
                    methods: vec!["derivative".into(), "integrate".into()],
                },
            ],
            method_count: 27,
            source_modules: vec!["algebra".into(), "calculus".into()],
        });

        let includes = manifest
            .generate_includes_for_type("Expression", Target::Python)
            .unwrap();
        assert!(includes.contains("include!(\"expression/algebra.rs\")"));
        assert!(includes.contains("include!(\"expression/calculus.rs\")"));
    }

    #[test]
    fn test_manifest_serialization() {
        let manifest = BindingManifest::new("test123".into());
        let json = serde_json::to_string(&manifest).unwrap();
        let loaded: BindingManifest = serde_json::from_str(&json).unwrap();
        assert_eq!(manifest.core_hash, loaded.core_hash);
    }
}
