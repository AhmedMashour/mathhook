<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MathHook CAS Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="High-performance educational computer algebra system in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MathHook CAS Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ahmedmashhour/mathhook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the MathHook documentation! MathHook is a high-performance educational computer algebra system (CAS) written in Rust, designed to combine mathematical correctness with exceptional performance.</p>
<h2 id="what-is-mathhook"><a class="header" href="#what-is-mathhook">What is MathHook?</a></h2>
<p>MathHook is a symbolic mathematics engine that can:</p>
<ul>
<li><strong>Parse</strong> mathematical expressions from multiple formats (LaTeX, Wolfram Language, standard notation)</li>
<li><strong>Simplify</strong> algebraic expressions using canonical forms and mathematical identities</li>
<li><strong>Differentiate</strong> and <strong>integrate</strong> expressions symbolically</li>
<li><strong>Solve</strong> equations and systems of equations</li>
<li><strong>Manipulate</strong> matrices with full linear algebra support</li>
<li><strong>Explain</strong> mathematical operations step-by-step for educational purposes</li>
</ul>
<h2 id="why-mathhook"><a class="header" href="#why-mathhook">Why MathHook?</a></h2>
<h3 id="performance-first-design"><a class="header" href="#performance-first-design">Performance-First Design</a></h3>
<p>MathHook is built from the ground up for speed:</p>
<ul>
<li><strong>32-byte expression representation</strong> fits perfectly in CPU cache lines</li>
<li><strong>SIMD operations</strong> for vectorized arithmetic (2-4x speedup)</li>
<li><strong>Zero-copy parsing</strong> directly constructs AST without intermediate allocations</li>
<li><strong>Thread-safe immutable expressions</strong> enable parallel processing</li>
<li><strong>10-100x faster</strong> than SymPy for common operations</li>
</ul>
<h3 id="mathematical-correctness"><a class="header" href="#mathematical-correctness">Mathematical Correctness</a></h3>
<p>Every operation in MathHook is designed to be mathematically correct:</p>
<ul>
<li>Exact rational arithmetic (never loses precision)</li>
<li>Proper domain handling (sqrt, log, division by zero)</li>
<li>Canonical forms for reliable equality checking</li>
<li>Validated against SymPy and Symbolica</li>
</ul>
<h3 id="educational-focus"><a class="header" href="#educational-focus">Educational Focus</a></h3>
<p>MathHook provides step-by-step explanations for all mathematical operations, making it ideal for:</p>
<ul>
<li>Educational software</li>
<li>Mathematics learning platforms</li>
<li>Interactive mathematics tools</li>
<li>Automated tutoring systems</li>
</ul>
<h3 id="multi-language-support"><a class="header" href="#multi-language-support">Multi-Language Support</a></h3>
<p>MathHook provides first-class bindings for:</p>
<ul>
<li><strong>Rust</strong> (native API with ergonomic macros)</li>
<li><strong>Python</strong> (via PyO3)</li>
<li><strong>Node.js/TypeScript</strong> (via NAPI-RS)</li>
<li><strong>WebAssembly</strong> (coming soon)</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="expression-building"><a class="header" href="#expression-building">Expression Building</a></h3>
<p>Create mathematical expressions naturally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!((x ^ 2) + (2 * x) + 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="symbolic-computation"><a class="header" href="#symbolic-computation">Symbolic Computation</a></h3>
<p>Perform algebraic manipulations symbolically:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let simplified = expr.simplify();
let expanded = expr.expand();
let factored = expr.factor();
<span class="boring">}</span></code></pre></pre>
<h3 id="calculus-operations"><a class="header" href="#calculus-operations">Calculus Operations</a></h3>
<p>Compute derivatives and integrals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let derivative = expr.derivative(&amp;x, 1);
let integral = expr.integrate(&amp;x);
<span class="boring">}</span></code></pre></pre>
<h3 id="equation-solving"><a class="header" href="#equation-solving">Equation Solving</a></h3>
<p>Solve equations and systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut solver = MathSolver::new();
let solutions = solver.solve(&amp;equation, &amp;x);
<span class="boring">}</span></code></pre></pre>
<h3 id="matrix-operations"><a class="header" href="#matrix-operations">Matrix Operations</a></h3>
<p>Full linear algebra support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let matrix = Expression::matrix(vec![
    vec![Expression::integer(1), Expression::integer(2)],
    vec![Expression::integer(3), Expression::integer(4)],
]);

let det = matrix.determinant();
let inverse = matrix.inverse();
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>MathHook is organized as a multi-crate workspace:</p>
<ul>
<li><strong>mathhook-core</strong>: Core mathematical engine (pure Rust)</li>
<li><strong>mathhook</strong>: High-level API with ergonomic macros</li>
<li><strong>mathhook-python</strong>: Python bindings</li>
<li><strong>mathhook-node</strong>: Node.js/TypeScript bindings</li>
<li><strong>mathhook-benchmarks</strong>: Performance benchmarking suite</li>
</ul>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p>MathHook follows five core principles (in priority order):</p>
<ol>
<li><strong>Mathematical Correctness First</strong>: Every operation must be mathematically correct</li>
<li><strong>Performance</strong>: Cache-friendly data structures, SIMD operations, parallel processing</li>
<li><strong>Ergonomic API</strong>: Macros and operator overloading for natural expression</li>
<li><strong>Educational Value</strong>: Step-by-step explanations for all operations</li>
<li><strong>Multi-Language</strong>: First-class bindings for Python, Node.js, and WebAssembly</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to start using MathHook? Continue to:</p>
<ul>
<li><a href="./getting-started/installation.html">Installation</a> - Set up MathHook in your project</li>
<li><a href="./getting-started/quick-start.html">Quick Start</a> - Your first 5 minutes with MathHook</li>
<li><a href="./getting-started/basic-usage.html">Basic Usage</a> - Learn the fundamentals</li>
</ul>
<h2 id="community-and-support"><a class="header" href="#community-and-support">Community and Support</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/ahmedmashhour/mathhook">https://github.com/ahmedmashhour/mathhook</a></li>
<li><strong>Documentation</strong>: <a href="https://docs.rs/mathhook">https://docs.rs/mathhook</a></li>
<li><strong>Issue Tracker</strong>: <a href="https://github.com/ahmedmashhour/mathhook/issues">https://github.com/ahmedmashhour/mathhook/issues</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>MathHook is dual-licensed under MIT or Apache 2.0. You may choose either license for your use.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>MathHook builds on the shoulders of giants:</p>
<ul>
<li><strong>LALRPOP</strong> for parser generation</li>
<li><strong>PyO3</strong> for Python bindings</li>
<li><strong>NAPI-RS</strong> for Node.js bindings</li>
<li><strong>SymPy</strong> and <strong>Symbolica</strong> for inspiration and validation</li>
</ul>
<hr />
<p>Let's dive in and explore what MathHook can do!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers installation of MathHook for Rust, Python, and Node.js.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>Rust 1.70 or higher</li>
<li>Cargo (comes with Rust)</li>
</ul>
<h3 id="adding-to-your-project"><a class="header" href="#adding-to-your-project">Adding to Your Project</a></h3>
<p>Add MathHook to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
mathhook-core = "0.1"
</code></pre>
<p>For the high-level API with ergonomic macros:</p>
<pre><code class="language-toml">[dependencies]
mathhook = "0.1"
</code></pre>
<h3 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h3>
<p>Create a simple test program:</p>
<pre><pre class="playground"><code class="language-rust">use mathhook_core::prelude::*;

fn main() {
    let x = symbol!(x);
    let expr = expr!(x ^ 2);
    println!("Expression: {}", expr);
}</code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<h3 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h3>
<ul>
<li>Python 3.8 or higher</li>
<li>pip</li>
</ul>
<h3 id="installing-via-pip"><a class="header" href="#installing-via-pip">Installing via pip</a></h3>
<pre><code class="language-bash">pip install mathhook
</code></pre>
<h3 id="installing-from-source"><a class="header" href="#installing-from-source">Installing from Source</a></h3>
<p>For the latest development version:</p>
<pre><code class="language-bash">git clone https://github.com/ahmedmashhour/mathhook.git
cd mathhook/crates/mathhook-python
pip install maturin
maturin develop
</code></pre>
<h3 id="verifying-installation-1"><a class="header" href="#verifying-installation-1">Verifying Installation</a></h3>
<pre><code class="language-python">from mathhook import Expression

x = Expression.symbol('x')
expr = x.pow(2)
print(f"Expression: {expr}")
</code></pre>
<h3 id="virtual-environments"><a class="header" href="#virtual-environments">Virtual Environments</a></h3>
<p>We recommend using a virtual environment:</p>
<pre><code class="language-bash">python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install mathhook
</code></pre>
<h2 id="nodejstypescript"><a class="header" href="#nodejstypescript">Node.js/TypeScript</a></h2>
<h3 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h3>
<ul>
<li>Node.js 18 or higher</li>
<li>npm or yarn</li>
</ul>
<h3 id="installing-via-npm"><a class="header" href="#installing-via-npm">Installing via npm</a></h3>
<pre><code class="language-bash">npm install mathhook-node
</code></pre>
<p>Or with yarn:</p>
<pre><code class="language-bash">yarn add mathhook-node
</code></pre>
<h3 id="installing-from-source-1"><a class="header" href="#installing-from-source-1">Installing from Source</a></h3>
<p>For the latest development version:</p>
<pre><code class="language-bash">git clone https://github.com/ahmedmashhour/mathhook.git
cd mathhook/crates/mathhook-node
npm install
npm run build
</code></pre>
<h3 id="verifying-installation-2"><a class="header" href="#verifying-installation-2">Verifying Installation</a></h3>
<p>Create a test file <code>test.ts</code>:</p>
<pre><code class="language-typescript">import { Expression } from 'mathhook-node';

const x = Expression.symbol('x');
const expr = x.pow(2);
console.log(`Expression: ${expr.toString()}`);
</code></pre>
<p>Run with:</p>
<pre><code class="language-bash">tsx test.ts
</code></pre>
<p>Or for JavaScript:</p>
<pre><code class="language-javascript">const { Expression } = require('mathhook-node');

const x = Expression.symbol('x');
const expr = x.pow(2);
console.log(`Expression: ${expr.toString()}`);
</code></pre>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Rust toolchain (rustup recommended)</li>
<li>Git</li>
<li>For Python bindings: Python 3.8+, maturin</li>
<li>For Node.js bindings: Node.js 18+, npm</li>
</ul>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/ahmedmashhour/mathhook.git
cd mathhook
</code></pre>
<h3 id="build-the-core"><a class="header" href="#build-the-core">Build the Core</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="run-tests"><a class="header" href="#run-tests">Run Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="build-python-bindings"><a class="header" href="#build-python-bindings">Build Python Bindings</a></h3>
<pre><code class="language-bash">cd crates/mathhook-python
pip install maturin
maturin develop --release
</code></pre>
<h3 id="build-nodejs-bindings"><a class="header" href="#build-nodejs-bindings">Build Node.js Bindings</a></h3>
<pre><code class="language-bash">cd crates/mathhook-node
npm install
npm run build
</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ul>
<li>Ensure you have Visual Studio Build Tools installed</li>
<li>Python bindings require Microsoft C++ Build Tools</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<ul>
<li>XCode Command Line Tools are required:
<pre><code class="language-bash">xcode-select --install
</code></pre>
</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>GCC or Clang is required</li>
<li>For Python bindings: <code>python3-dev</code> package
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install python3-dev

# Fedora/RHEL
sudo dnf install python3-devel
</code></pre>
</li>
</ul>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<h3 id="simd-support"><a class="header" href="#simd-support">SIMD Support</a></h3>
<p>MathHook automatically detects and uses SIMD instructions (AVX2, SSE2) if available. No configuration needed.</p>
<p>To explicitly enable/disable:</p>
<pre><code class="language-toml">[dependencies]
mathhook-core = { version = "0.1", features = ["simd"] }
</code></pre>
<h3 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h3>
<p>For parallel bulk operations:</p>
<pre><code class="language-toml">[dependencies]
mathhook-core = { version = "0.1", features = ["parallel"] }
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="rust-compilation-errors"><a class="header" href="#rust-compilation-errors">Rust: Compilation Errors</a></h3>
<p>If you encounter LALRPOP-related errors:</p>
<pre><code class="language-bash">cargo install lalrpop
cargo clean
cargo build
</code></pre>
<h3 id="python-import-errors"><a class="header" href="#python-import-errors">Python: Import Errors</a></h3>
<p>If <code>import mathhook</code> fails:</p>
<pre><code class="language-bash">pip install --force-reinstall mathhook
</code></pre>
<h3 id="nodejs-native-module-errors"><a class="header" href="#nodejs-native-module-errors">Node.js: Native Module Errors</a></h3>
<p>If you see native module loading errors:</p>
<pre><code class="language-bash">npm rebuild mathhook-node
</code></pre>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<p>On Linux/macOS, you may need to use <code>pip install --user</code>:</p>
<pre><code class="language-bash">pip install --user mathhook
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that MathHook is installed, continue to:</p>
<ul>
<li><a href="getting-started/./quick-start.html">Quick Start</a> - Your first 5 minutes with MathHook</li>
<li><a href="getting-started/./basic-usage.html">Basic Usage</a> - Learn the fundamentals</li>
<li><a href="getting-started/./common-patterns.html">Common Patterns</a> - Idioms and best practices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide will get you up and running with MathHook in 5 minutes.</p>
<h2 id="your-first-expression-rust"><a class="header" href="#your-first-expression-rust">Your First Expression (Rust)</a></h2>
<pre><pre class="playground"><code class="language-rust">use mathhook_core::prelude::*;

fn main() {
    // Create a symbol
    let x = symbol!(x);

    // Build an expression: x^2 + 2x + 1
    let expr = expr!((x ^ 2) + (2 * x) + 1);

    // Simplify it
    let simplified = expr.simplify();

    println!("Original: {}", expr);
    println!("Simplified: {}", simplified);
}</code></pre></pre>
<h2 id="your-first-expression-python"><a class="header" href="#your-first-expression-python">Your First Expression (Python)</a></h2>
<pre><code class="language-python">from mathhook import Expression

# Create a symbol
x = Expression.symbol('x')

# Build an expression: x^2 + 2x + 1
expr = x.pow(2).add(x.multiply(2)).add(1)

# Simplify it
simplified = expr.simplify()

print(f"Original: {expr}")
print(f"Simplified: {simplified}")
</code></pre>
<h2 id="your-first-expression-nodejstypescript"><a class="header" href="#your-first-expression-nodejstypescript">Your First Expression (Node.js/TypeScript)</a></h2>
<pre><code class="language-typescript">import { Expression } from 'mathhook-node';

// Create a symbol
const x = Expression.symbol('x');

// Build an expression: x^2 + 2x + 1
const expr = x.pow(2).add(x.multiply(2)).add(1);

// Simplify it
const simplified = expr.simplify();

console.log(`Original: ${expr.toString()}`);
console.log(`Simplified: ${simplified.toString()}`);
</code></pre>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="parsing-latex"><a class="header" href="#parsing-latex">Parsing LaTeX</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::parser::{Parser, ParserConfig};

let parser = Parser::new(ParserConfig::default());
let expr = parser.parse(r"\frac{x^2 + 1}{2}").unwrap();

println!("{}", expr);
<span class="boring">}</span></code></pre></pre>
<h3 id="computing-derivatives"><a class="header" href="#computing-derivatives">Computing Derivatives</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!(x ^ 3);

// First derivative: 3x^2
let derivative = expr.derivative(&amp;x, 1);

// Second derivative: 6x
let second_derivative = expr.derivative(&amp;x, 2);

println!("f(x) = {}", expr);
println!("f'(x) = {}", derivative);
println!("f''(x) = {}", second_derivative);
<span class="boring">}</span></code></pre></pre>
<h3 id="solving-equations"><a class="header" href="#solving-equations">Solving Equations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);

// Solve: x^2 = 4
let mut solver = MathSolver::new();
let equation = Expression::equation(expr!(x ^ 2), expr!(4));
let solutions = solver.solve(&amp;equation, &amp;x);

println!("Solutions: {:?}", solutions);
// Output: [x = 2, x = -2]
<span class="boring">}</span></code></pre></pre>
<h3 id="matrix-operations-1"><a class="header" href="#matrix-operations-1">Matrix Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::Expression;

let matrix = Expression::matrix(vec![
    vec![Expression::integer(1), Expression::integer(2)],
    vec![Expression::integer(3), Expression::integer(4)],
]);

let det = matrix.determinant();
println!("Determinant: {}", det);
// Output: -2
<span class="boring">}</span></code></pre></pre>
<h2 id="step-by-step-explanations"><a class="header" href="#step-by-step-explanations">Step-by-Step Explanations</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;
use mathhook_core::educational::*;

let x = symbol!(x);
let expr = expr!((x + 1) * (x - 1));

// Get educational explanation
let explanation = expr.explain_simplification();

for step in explanation.steps() {
    println!("{}: {}", step.title, step.description);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Now that you've seen the basics, dive deeper into:</p>
<ul>
<li><a href="getting-started/./basic-usage.html">Basic Usage</a> - Detailed guide to expression building and manipulation</li>
<li><a href="getting-started/../core/expressions.html">Core Concepts</a> - Understanding the type system</li>
<li><a href="getting-started/../operations/simplification.html">Mathematical Operations</a> - Learn all the operations MathHook supports</li>
<li><a href="getting-started/./common-patterns.html">Common Patterns</a> - Idioms and best practices</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="creating-expressions-programmatically"><a class="header" href="#creating-expressions-programmatically">Creating Expressions Programmatically</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::Expression;

// For known values at compile time
let expr = expr!((x ^ 2) + 3);

// For runtime/dynamic expressions
let mut terms = Vec::new();
for i in 0..5 {
    terms.push(Expression::mul(vec![
        Expression::integer(i),
        Expression::pow(symbol!(x), Expression::integer(i))
    ]));
}
let polynomial = Expression::add(terms);
<span class="boring">}</span></code></pre></pre>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!((x ^ 2) + (2 * x) + 1);

// Substitute x = 3
let result = expr.substitute(&amp;x, &amp;Expression::integer(3));
println!("Result: {}", result);
// Output: 16
<span class="boring">}</span></code></pre></pre>
<h3 id="formatting-output"><a class="header" href="#formatting-output">Formatting Output</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!(x ^ 2);

// Standard notation
println!("Standard: {}", expr);

// LaTeX notation
println!("LaTeX: {}", expr.to_latex());

// Wolfram notation
println!("Wolfram: {}", expr.to_wolfram());
<span class="boring">}</span></code></pre></pre>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ol>
<li><strong>Use macros</strong> (<code>symbol!</code>, <code>expr!</code>) for cleaner code</li>
<li><strong>Explicit grouping</strong> with parentheses in <code>expr!</code> macro avoids precedence issues</li>
<li><strong>Check errors</strong> when parsing - use <code>.unwrap()</code> only in examples</li>
<li><strong>Simplify often</strong> - many operations work better on simplified expressions</li>
<li><strong>Profile first</strong> - don't optimize prematurely</li>
</ol>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<h3 id="runtime-variables-in-macros"><a class="header" href="#runtime-variables-in-macros">Runtime Variables in Macros</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T do this - 'i' is seen as a symbol name, not the value
for i in 0..10 {
    let expr = expr!(i);  // Creates Symbol("i"), not integer i!
}

// DO this instead
for i in 0..10 {
    let expr = Expression::integer(i);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="precedence-without-parentheses"><a class="header" href="#precedence-without-parentheses">Precedence Without Parentheses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unclear precedence
let expr = expr!(2*x + 3);

// Better - explicit grouping
let expr = expr!((2*x) + 3);
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-point-comparison"><a class="header" href="#floating-point-comparison">Floating Point Comparison</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T use == for floats
if expr.evaluate() == 3.14159 { }  // BAD

// DO use epsilon comparison or exact rationals
if (expr.evaluate() - 3.14159).abs() &lt; 1e-10 { }  // GOOD
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<p>For performance-critical code:</p>
<ol>
<li>Reuse expressions when possible (they're immutable and cheap to clone)</li>
<li>Use SIMD for bulk operations (automatic for arrays &gt; 100 elements)</li>
<li>Enable parallel processing for large collections</li>
<li>Cache frequently computed results</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::core::performance::config::{
    PerformanceConfig,
    BindingContext,
    set_global_config
};

// Configure for optimal performance
let config = PerformanceConfig::for_binding(BindingContext::Native);
set_global_config(config);
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="getting-started/./basic-usage.html">Basic Usage</a> - Comprehensive usage guide</li>
<li><a href="getting-started/../core/expressions.html">Core Concepts</a> - Deep dive into the type system</li>
<li><a href="getting-started/../api/core.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-paths"><a class="header" href="#learning-paths">Learning Paths</a></h1>
<p>Choose your journey based on your background and goals. Each path is designed to get you productive with MathHook as quickly as possible.</p>
<h2 id="path-1-python-data-scientist"><a class="header" href="#path-1-python-data-scientist">Path 1: Python Data Scientist</a></h2>
<p><strong>Background</strong>: Familiar with NumPy, SymPy, pandas
<strong>Goal</strong>: Use MathHook for faster symbolic computation in Python
<strong>Time to Productivity</strong>: 1-2 hours</p>
<h3 id="your-journey"><a class="header" href="#your-journey">Your Journey</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/installation.html#python">Installation - Python</a></strong> (5 minutes)</p>
<ul>
<li><code>pip install mathhook</code></li>
<li>Verify installation with a simple test</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/quick-start.html#your-first-expression-python">Quick Start - Python Examples</a></strong> (15 minutes)</p>
<ul>
<li>Create your first symbolic expression</li>
<li>Learn basic operations: simplify, expand, solve</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../bindings/python.html">Python API Guide</a></strong> (30 minutes)</p>
<ul>
<li>Complete Python API reference</li>
<li>Operator overloading support</li>
<li>Integration with NumPy arrays</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../performance/benchmarking.html#python-vs-sympy">Performance Comparison</a></strong> (10 minutes)</p>
<ul>
<li>Understand when MathHook is 100x faster than SymPy</li>
<li>Learn which operations benefit most</li>
</ul>
</li>
</ol>
<!-- 5. **[SymPy Migration Guide](../appendix/sympy-migration.md)** (30 minutes)
   - Port existing SymPy code to MathHook
   - API differences and workarounds
   - Feature compatibility matrix -->
<h3 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h3>
<ul>
<li>How to use MathHook as a drop-in replacement for SymPy</li>
<li>When to use MathHook vs SymPy (performance vs features)</li>
<li>How to integrate with your existing Python data science stack</li>
<li>Performance optimization techniques for Python bindings</li>
</ul>
<h3 id="next-steps-after-mastery"><a class="header" href="#next-steps-after-mastery">Next Steps After Mastery</a></h3>
<ul>
<li><a href="getting-started/../operations/simplification.html">Advanced Mathematical Operations</a></li>
<li><a href="getting-started/../educational/step-by-step.html">Educational Features for Teaching</a></li>
<li><a href="getting-started/../contributing/development.html">Contributing Python Examples</a></li>
</ul>
<hr />
<h2 id="path-2-nodejstypescript-developer"><a class="header" href="#path-2-nodejstypescript-developer">Path 2: Node.js/TypeScript Developer</a></h2>
<p><strong>Background</strong>: JavaScript/TypeScript web development
<strong>Goal</strong>: Add symbolic math to web applications
<strong>Time to Productivity</strong>: 2-3 hours</p>
<h3 id="your-journey-1"><a class="header" href="#your-journey-1">Your Journey</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/installation.html#nodejs">Installation - Node.js</a></strong> (5 minutes)</p>
<ul>
<li><code>npm install mathhook</code> or <code>yarn add mathhook</code></li>
<li>TypeScript types included</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/quick-start.html#your-first-expression-nodejs-typescript">Quick Start - Node.js Examples</a></strong> (15 minutes)</p>
<ul>
<li>Build expressions with JavaScript API</li>
<li>Parse LaTeX input from web forms</li>
<li>Display formatted output</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../bindings/nodejs.html">Node.js API Reference</a></strong> (45 minutes)</p>
<ul>
<li>Complete Node.js bindings documentation</li>
<li>Promise-based async API</li>
<li>Memory management best practices</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../advanced/web-integration.html">Web Integration Patterns</a></strong> (30 minutes)</p>
<ul>
<li>Integrate with React/Vue/Angular</li>
<li>Server-side rendering considerations</li>
<li>Client-side vs server-side computation</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../performance/nodejs-benchmarks.html">Performance in Node</a></strong> (30 minutes)</p>
<ul>
<li>V8 optimization tips</li>
<li>Worker thread utilization</li>
<li>Comparison with JavaScript CAS libraries</li>
</ul>
</li>
</ol>
<h3 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You'll Learn</a></h3>
<ul>
<li>How to parse mathematical notation from web forms</li>
<li>How to render LaTeX output in the browser</li>
<li>Best practices for integrating with modern web frameworks</li>
<li>Performance optimization for V8 engine</li>
</ul>
<h3 id="next-steps-after-mastery-1"><a class="header" href="#next-steps-after-mastery-1">Next Steps After Mastery</a></h3>
<ul>
<li><a href="getting-started/../parser/latex.html">LaTeX Parsing Deep Dive</a></li>
<li><a href="getting-started/../advanced/custom-functions.html">Custom Function Implementation</a></li>
<li><a href="getting-started/../contributing/development.html">Contributing Node.js Examples</a></li>
</ul>
<hr />
<h2 id="path-3-rust-systems-programmer"><a class="header" href="#path-3-rust-systems-programmer">Path 3: Rust Systems Programmer</a></h2>
<p><strong>Background</strong>: Rust experience, need high-performance CAS
<strong>Goal</strong>: Embed MathHook in Rust application or contribute to core
<strong>Time to Productivity</strong>: 4-6 hours to mastery</p>
<h3 id="your-journey-2"><a class="header" href="#your-journey-2">Your Journey</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/installation.html#rust">Installation - Rust</a></strong> (5 minutes)</p>
<ul>
<li><code>cargo add mathhook-core</code></li>
<li>Verify with <code>cargo test</code></li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../architecture/principles.html">Architecture Overview</a></strong> (45 minutes)</p>
<ul>
<li>Design philosophy and constraints</li>
<li>32-byte Expression constraint</li>
<li>Why we made key architectural decisions</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../api/core.html">Core API - Rust</a></strong> (60 minutes)</p>
<ul>
<li>Low-level Expression API</li>
<li>Memory layout and cache optimization</li>
<li>Thread safety guarantees</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../performance/simd.html">SIMD Optimization</a></strong> (45 minutes)</p>
<ul>
<li>Vectorized operations for bulk arithmetic</li>
<li>Feature flags: AVX2, SSE2</li>
<li>Writing SIMD-friendly code</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../advanced/custom-functions.html">Custom Extensions</a></strong> (90 minutes)</p>
<ul>
<li>Extend the Universal Function Registry</li>
<li>Implement custom simplification rules</li>
<li>Add new mathematical operations</li>
</ul>
</li>
</ol>
<h3 id="what-youll-learn-2"><a class="header" href="#what-youll-learn-2">What You'll Learn</a></h3>
<ul>
<li>Deep understanding of MathHook's architecture</li>
<li>How to write cache-friendly symbolic math code</li>
<li>SIMD optimization techniques</li>
<li>Contributing to the core library</li>
</ul>
<h3 id="next-steps-after-mastery-2"><a class="header" href="#next-steps-after-mastery-2">Next Steps After Mastery</a></h3>
<ul>
<li><a href="getting-started/../contributing/correctness.html">Mathematical Correctness Guidelines</a></li>
<li><a href="getting-started/../parser/custom.html">Parser Architecture (LALRPOP)</a></li>
<li><a href="getting-started/../operations/simplification.html#advanced-techniques">Advanced Simplification Strategies</a></li>
<li><a href="getting-started/../contributing/development.html">Contributing Core Features</a></li>
</ul>
<hr />
<h2 id="path-4-mathematics-studenteducator"><a class="header" href="#path-4-mathematics-studenteducator">Path 4: Mathematics Student/Educator</a></h2>
<p><strong>Background</strong>: Calculus, linear algebra, abstract algebra knowledge
<strong>Goal</strong>: Understand CAS internals, use for teaching, contribute
<strong>Time to Productivity</strong>: 8-12 hours to contribution-ready</p>
<h3 id="your-journey-3"><a class="header" href="#your-journey-3">Your Journey</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/../appendix/math-background.html">Mathematical Foundations</a></strong> (60 minutes)</p>
<ul>
<li>Prerequisites refresher</li>
<li>Notation and terminology</li>
<li>Computer algebra vs numerical computation</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../architecture/symbolic-computation.html">How Symbolic Math Works</a></strong> (90 minutes)</p>
<ul>
<li>Theory of symbolic computation</li>
<li>Canonical forms and expression equality</li>
<li>Simplification strategies</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../core/expressions.html">Expression Representation</a></strong> (45 minutes)</p>
<ul>
<li>How expressions are stored internally</li>
<li>Abstract syntax trees (AST)</li>
<li>Pattern matching on expressions</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../operations/simplification.html">Simplification Deep Dive</a></strong> (90 minutes)</p>
<ul>
<li>Algebraic simplification algorithms</li>
<li>Trigonometric identities</li>
<li>Polynomial factorization</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../operations/differentiation.html">Derivative Engine</a></strong> (90 minutes)</p>
<ul>
<li>Chain rule implementation</li>
<li>Product and quotient rules</li>
<li>Higher-order derivatives</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../operations/integration.html">Integration Techniques</a></strong> (120 minutes)</p>
<ul>
<li>Pattern matching for integrals</li>
<li>Risch algorithm (theory)</li>
<li>Numerical integration fallback</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../educational/step-by-step.html">Educational Features</a></strong> (60 minutes)</p>
<ul>
<li>Step-by-step explanation generation</li>
<li>Message registry for educational feedback</li>
<li>Using MathHook for teaching</li>
</ul>
</li>
</ol>
<h3 id="what-youll-learn-3"><a class="header" href="#what-youll-learn-3">What You'll Learn</a></h3>
<ul>
<li>How computer algebra systems work internally</li>
<li>Algorithm implementation for symbolic operations</li>
<li>How to use MathHook for teaching mathematics</li>
<li>Contributing new mathematical features</li>
</ul>
<h3 id="next-steps-after-mastery-3"><a class="header" href="#next-steps-after-mastery-3">Next Steps After Mastery</a></h3>
<ul>
<li><a href="getting-started/../advanced/special-functions.html">Implementing New Functions</a></li>
<li><a href="getting-started/../contributing/documentation.html">Contributing Documentation</a></li>
<li><a href="getting-started/../contributing/correctness.html">Mathematical Correctness Testing</a></li>
</ul>
<hr />
<h2 id="path-5-computational-scientist"><a class="header" href="#path-5-computational-scientist">Path 5: Computational Scientist</a></h2>
<p><strong>Background</strong>: MATLAB, Julia, scientific computing
<strong>Goal</strong>: Fast symbolic preprocessing for numerical simulations
<strong>Time to Productivity</strong>: 3-4 hours</p>
<h3 id="your-journey-4"><a class="header" href="#your-journey-4">Your Journey</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/installation.html">Installation - Choose Your Language</a></strong> (10 minutes)</p>
<ul>
<li>Python bindings for MATLAB-like workflow</li>
<li>Rust for embedded numerical solvers</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../advanced/matrices.html">Matrix Operations</a></strong> (45 minutes)</p>
<ul>
<li>Symbolic matrix algebra</li>
<li>Determinants, eigenvalues, decomposition</li>
<li>Integration with numerical linear algebra</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../advanced/system-solving.html">System Solving</a></strong> (60 minutes)</p>
<ul>
<li>Linear systems</li>
<li>Nonlinear systems</li>
<li>Symbolic Jacobian generation</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../performance/parallel.html">Performance for Large Problems</a></strong> (45 minutes)</p>
<ul>
<li>Parallel processing strategies</li>
<li>Memory efficiency for large expressions</li>
<li>SIMD for vectorized operations</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../advanced/hybrid-computation.html">Hybrid Symbolic-Numerical Workflows</a></strong> (60 minutes)</p>
<ul>
<li>When to use symbolic vs numerical</li>
<li>Code generation from symbolic expressions</li>
<li>Integration with numerical libraries</li>
</ul>
</li>
</ol>
<h3 id="what-youll-learn-4"><a class="header" href="#what-youll-learn-4">What You'll Learn</a></h3>
<ul>
<li>How to use symbolic preprocessing to speed up numerical simulations</li>
<li>Generating optimized numerical code from symbolic expressions</li>
<li>Efficient handling of large symbolic systems</li>
<li>Integration with existing numerical computing tools</li>
</ul>
<h3 id="next-steps-after-mastery-4"><a class="header" href="#next-steps-after-mastery-4">Next Steps After Mastery</a></h3>
<ul>
<li><a href="getting-started/../advanced/codegen.html">Custom Code Generation</a></li>
<li><a href="getting-started/../performance/caching.html">Optimization for Large Systems</a></li>
<li><a href="getting-started/../contributing/development.html">Contributing Numerical Integration</a></li>
</ul>
<hr />
<h2 id="common-themes-across-all-paths"><a class="header" href="#common-themes-across-all-paths">Common Themes Across All Paths</a></h2>
<h3 id="essential-concepts-everyone-should-know"><a class="header" href="#essential-concepts-everyone-should-know">Essential Concepts Everyone Should Know</a></h3>
<ol>
<li>
<p><strong><a href="getting-started/../core/expressions.html#immutability">Expressions are Immutable</a></strong></p>
<ul>
<li>All operations return new expressions</li>
<li>Safe for concurrent use</li>
<li>Cheap to clone (reference counting)</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../core/expressions.html#canonical-forms">Canonical Forms</a></strong></p>
<ul>
<li>Why <code>x + y</code> and <code>y + x</code> are the same expression</li>
<li>How MathHook maintains consistency</li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../core/symbols-numbers.html#exact-vs-approximate">Exact vs Approximate Arithmetic</a></strong></p>
<ul>
<li>When to use rationals vs floats</li>
<li>Why <code>1/3</code> stays exact, not <code>0.333...</code></li>
</ul>
</li>
<li>
<p><strong><a href="getting-started/../appendix/errors.html">Error Handling</a></strong></p>
<ul>
<li>Domain errors (sqrt of negative, division by zero)</li>
<li>How to handle undefined operations</li>
</ul>
</li>
</ol>
<h3 id="key-resources-for-all-users"><a class="header" href="#key-resources-for-all-users">Key Resources for All Users</a></h3>
<ul>
<li><strong><a href="getting-started/../appendix/faq.html">FAQ</a></strong> - Common questions answered</li>
<li><strong><a href="getting-started/../appendix/glossary.html">Glossary</a></strong> - Terminology reference</li>
<li><strong><a href="getting-started/../appendix/errors.html">Error Messages Guide</a></strong> - Decode error messages</li>
<li><strong><a href="getting-started/../performance/architecture.html">Performance Tips</a></strong> - General optimization advice</li>
</ul>
<hr />
<h2 id="choosing-the-right-path"><a class="header" href="#choosing-the-right-path">Choosing the Right Path</a></h2>
<h3 id="quick-decision-guide"><a class="header" href="#quick-decision-guide">Quick Decision Guide</a></h3>
<p><strong>Choose Python Path if</strong>:</p>
<ul>
<li>You already use SymPy and want better performance</li>
<li>You're a data scientist or researcher</li>
<li>You prefer interactive exploration (Jupyter)</li>
</ul>
<p><strong>Choose Node.js Path if</strong>:</p>
<ul>
<li>You're building web applications</li>
<li>You need symbolic math in the browser</li>
<li>You work with JavaScript/TypeScript</li>
</ul>
<p><strong>Choose Rust Path if</strong>:</p>
<ul>
<li>You need maximum performance</li>
<li>You're building systems-level applications</li>
<li>You want to contribute to the core library</li>
</ul>
<p><strong>Choose Mathematics Path if</strong>:</p>
<ul>
<li>You want to understand CAS algorithms</li>
<li>You're teaching mathematics with technology</li>
<li>You want to contribute educational features</li>
</ul>
<p><strong>Choose Computational Science Path if</strong>:</p>
<ul>
<li>You use MATLAB, Julia, or Fortran</li>
<li>You need symbolic preprocessing for simulations</li>
<li>You work with large systems of equations</li>
</ul>
<hr />
<h2 id="mixing-paths"><a class="header" href="#mixing-paths">Mixing Paths</a></h2>
<p>Feel free to combine paths. Common combinations:</p>
<ul>
<li><strong>Python + Mathematics</strong>: Use MathHook for teaching, understand the algorithms</li>
<li><strong>Rust + Mathematics</strong>: Contribute core mathematical features</li>
<li><strong>Node.js + Python</strong>: Build web interfaces to Python backend</li>
<li><strong>Computational Science + Rust</strong>: Embed MathHook in high-performance solvers</li>
</ul>
<hr />
<h2 id="time-investment-summary"><a class="header" href="#time-investment-summary">Time Investment Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Path</th><th>To Productivity</th><th>To Mastery</th></tr></thead><tbody>
<tr><td>Python Data Scientist</td><td>1-2 hours</td><td>4-6 hours</td></tr>
<tr><td>Node.js Developer</td><td>2-3 hours</td><td>6-8 hours</td></tr>
<tr><td>Rust Programmer</td><td>4-6 hours</td><td>12-16 hours</td></tr>
<tr><td>Mathematics Student</td><td>3-4 hours</td><td>20-30 hours</td></tr>
<tr><td>Computational Scientist</td><td>3-4 hours</td><td>8-12 hours</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong><a href="getting-started/../appendix/faq.html">FAQ</a></strong> - Start here for common questions</li>
<li><strong><a href="https://github.com/ahmedmashhour/mathhook/discussions">GitHub Discussions</a></strong> - Ask questions</li>
<li><strong><a href="https://github.com/ahmedmashhour/mathhook/issues">Issue Tracker</a></strong> - Report bugs</li>
<li><strong><a href="getting-started/../contributing/development.html">Contributing Guide</a></strong> - Join the community</li>
</ul>
<hr />
<h2 id="whats-your-path"><a class="header" href="#whats-your-path">What's Your Path?</a></h2>
<p>Ready to start? Pick your path above and begin your journey with MathHook!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<p>This chapter provides a comprehensive guide to using MathHook in your projects.</p>
<h2 id="expression-creation"><a class="header" href="#expression-creation">Expression Creation</a></h2>
<h3 id="using-macros"><a class="header" href="#using-macros">Using Macros</a></h3>
<p>The recommended way to create expressions is using the <code>expr!</code> and <code>symbol!</code> macros:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let y = symbol!(y);

// Simple arithmetic
let expr1 = expr!(x + y);
let expr2 = expr!(2 * x);
let expr3 = expr!(x ^ 2);

// Complex expressions with explicit grouping
let expr4 = expr!((x + 1) * (x - 1));
let expr5 = expr!((2*x) + (3*y) - 5);
<span class="boring">}</span></code></pre></pre>
<h3 id="using-constructors"><a class="header" href="#using-constructors">Using Constructors</a></h3>
<p>For programmatic construction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::Expression;

// Numbers
let int = Expression::integer(42);
let float = Expression::float(3.14);
let rational = Expression::rational(3, 4);  // 3/4

// Operations
let sum = Expression::add(vec![
    Expression::integer(1),
    Expression::integer(2),
]);

let product = Expression::mul(vec![
    Expression::integer(2),
    Expression::symbol(symbol!(x)),
]);
<span class="boring">}</span></code></pre></pre>
<h2 id="simplification"><a class="header" href="#simplification">Simplification</a></h2>
<p>Simplification transforms expressions to their canonical form:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);

// Combine like terms
let expr = expr!(x + x);
let simplified = expr.simplify();
// Result: 2*x

// Apply identities
let expr = expr!(x * 1);
let simplified = expr.simplify();
// Result: x

// Evaluate constants
let expr = expr!(2 + 3);
let simplified = expr.simplify();
// Result: 5
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>Work with expression structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::Expression;

match expr {
    Expression::Add(terms) =&gt; {
        println!("Addition with {} terms", terms.len());
    }
    Expression::Mul(factors) =&gt; {
        println!("Multiplication with {} factors", factors.len());
    }
    Expression::Pow(base, exp) =&gt; {
        println!("Power: base={}, exp={}", base, exp);
    }
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-symbols"><a class="header" href="#working-with-symbols">Working with Symbols</a></h2>
<p>Symbols represent variables in expressions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let y = symbol!(y);

// Symbols with same name are equal
assert_eq!(symbol!(x), symbol!(x));

// Different names are not equal
assert_ne!(symbol!(x), symbol!(y));
<span class="boring">}</span></code></pre></pre>
<h2 id="number-types"><a class="header" href="#number-types">Number Types</a></h2>
<p>MathHook supports multiple number representations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Integers (exact, arbitrary precision)
let int = Expression::integer(12345678901234567890);

// Rationals (exact fractions)
let frac = Expression::rational(22, 7);  // 22/7 ≈ π

// Floats (approximate)
let float = Expression::float(3.14159265359);

// Complex numbers
let complex = Expression::complex(
    Expression::integer(3),
    Expression::integer(4)
);  // 3 + 4i
<span class="boring">}</span></code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Mathematical constants are built-in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = Expression::pi();
let e = Expression::e();
let i = Expression::i();              // imaginary unit
let phi = Expression::golden_ratio();
let gamma = Expression::euler_gamma();
<span class="boring">}</span></code></pre></pre>
<h2 id="function-expressions"><a class="header" href="#function-expressions">Function Expressions</a></h2>
<p>Create function calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Elementary functions
let sin_x = expr!(sin(x));
let cos_x = expr!(cos(x));
let log_x = expr!(log(x));

// Using constructors
let tan_x = Expression::function("tan", vec![expr!(x)]);
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="getting-started/./common-patterns.html">Common Patterns</a> - Idioms and best practices</li>
<li><a href="getting-started/../core/expressions.html">Core Concepts</a> - Deep dive into the type system</li>
<li><a href="getting-started/../operations/simplification.html">Mathematical Operations</a> - Learn all operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h1>
<p>This chapter covers common patterns and best practices when using MathHook.</p>
<h2 id="macro-usage-guidelines"><a class="header" href="#macro-usage-guidelines">Macro Usage Guidelines</a></h2>
<h3 id="when-to-use-macros"><a class="header" href="#when-to-use-macros">When to Use Macros</a></h3>
<p><strong>ALWAYS use macros for:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Symbol creation
let x = symbol!(x);  // NOT Symbol::new("x")

// Simple expressions
let expr = expr!(x + y);
let expr = expr!(2 * x);
let expr = expr!(x ^ 2);

// Function calls
let expr = expr!(sin(x));
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-explicit-api"><a class="header" href="#when-to-use-explicit-api">When to Use Explicit API</a></h3>
<p><strong>Use explicit API for:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Runtime/loop variables
for i in 0..10 {
    let term = Expression::integer(i);  // NOT expr!(i)
}

// Programmatic construction
let mut terms = Vec::new();
for i in 0..n {
    terms.push(Expression::mul(vec![
        Expression::integer(coefficients[i]),
        Expression::pow(symbol!(x), Expression::integer(i))
    ]));
}
let polynomial = Expression::add(terms);
<span class="boring">}</span></code></pre></pre>
<h2 id="building-polynomials"><a class="header" href="#building-polynomials">Building Polynomials</a></h2>
<h3 id="fixed-degree"><a class="header" href="#fixed-degree">Fixed Degree</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);

// ax^2 + bx + c
let a = Expression::integer(1);
let b = Expression::integer(2);
let c = Expression::integer(1);

let quadratic = Expression::add(vec![
    Expression::mul(vec![a, Expression::pow(expr!(x), Expression::integer(2))]),
    Expression::mul(vec![b, expr!(x)]),
    c,
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-degree"><a class="header" href="#dynamic-degree">Dynamic Degree</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_polynomial(coefficients: &amp;[i64], x: &amp;Symbol) -&gt; Expression {
    let mut terms = Vec::new();
    for (i, &amp;coeff) in coefficients.iter().enumerate() {
        terms.push(Expression::mul(vec![
            Expression::integer(coeff),
            Expression::pow(Expression::symbol(x.clone()), Expression::integer(i as i64))
        ]));
    }
    Expression::add(terms)
}

let x = symbol!(x);
let poly = build_polynomial(&amp;[1, -5, 6], &amp;x);  // x^2 - 5x + 6
<span class="boring">}</span></code></pre></pre>
<h2 id="substitution-patterns"><a class="header" href="#substitution-patterns">Substitution Patterns</a></h2>
<h3 id="single-substitution"><a class="header" href="#single-substitution">Single Substitution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!((x ^ 2) + (2 * x) + 1);

// Substitute x = 3
let result = expr.substitute(&amp;x, &amp;Expression::integer(3));
<span class="boring">}</span></code></pre></pre>
<h3 id="multiple-substitutions"><a class="header" href="#multiple-substitutions">Multiple Substitutions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let x = symbol!(x);
let y = symbol!(y);
let expr = expr!((x * y) + x + y);

// Substitute both x and y
let result = expr
    .substitute(&amp;x, &amp;Expression::integer(2))
    .substitute(&amp;y, &amp;Expression::integer(3));
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-functions"><a class="header" href="#working-with-functions">Working with Functions</a></h2>
<h3 id="creating-function-expressions"><a class="header" href="#creating-function-expressions">Creating Function Expressions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using expr! macro
let f = expr!(sin(x));
let g = expr!(cos(x));

// Using constructors
let h = Expression::function("tan", vec![expr!(x)]);
<span class="boring">}</span></code></pre></pre>
<h3 id="composing-functions"><a class="header" href="#composing-functions">Composing Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// sin(cos(x))
let inner = expr!(cos(x));
let composed = Expression::function("sin", vec![inner]);

// Or using nested expr!
let composed = expr!(sin(cos(x)));
<span class="boring">}</span></code></pre></pre>
<h2 id="matrix-patterns"><a class="header" href="#matrix-patterns">Matrix Patterns</a></h2>
<h3 id="creating-matrices"><a class="header" href="#creating-matrices">Creating Matrices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From vectors
let matrix = Expression::matrix(vec![
    vec![Expression::integer(1), Expression::integer(2)],
    vec![Expression::integer(3), Expression::integer(4)],
]);

// Identity matrix
let identity = Expression::identity_matrix(3);

// Zero matrix
let zero = Expression::zero_matrix(2, 3);
<span class="boring">}</span></code></pre></pre>
<h3 id="matrix-operations-2"><a class="header" href="#matrix-operations-2">Matrix Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Expression::matrix(/* ... */);
let b = Expression::matrix(/* ... */);

// Add matrices
let sum = a.add_matrix(&amp;b);

// Multiply matrices
let product = a.multiply_matrix(&amp;b);

// Transpose
let transpose = a.transpose();

// Determinant
let det = a.determinant();
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="parsing-errors"><a class="header" href="#parsing-errors">Parsing Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::parser::{Parser, ParserConfig};

let parser = Parser::new(ParserConfig::default());

match parser.parse(input) {
    Ok(expr) =&gt; {
        println!("Parsed: {}", expr);
    }
    Err(e) =&gt; {
        eprintln!("Parse error: {}", e);
        // Handle error appropriately
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solver-errors"><a class="header" href="#solver-errors">Solver Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let mut solver = MathSolver::new();

match solver.solve(&amp;equation, &amp;x) {
    SolverResult::Single(solution) =&gt; {
        println!("Solution: {}", solution);
    }
    SolverResult::Multiple(solutions) =&gt; {
        println!("Multiple solutions: {:?}", solutions);
    }
    SolverResult::NoSolution =&gt; {
        println!("No solution exists");
    }
    SolverResult::InfiniteSolutions =&gt; {
        println!("Infinite solutions");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-patterns"><a class="header" href="#performance-patterns">Performance Patterns</a></h2>
<h3 id="bulk-operations"><a class="header" href="#bulk-operations">Bulk Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::core::performance::config::parallel_bulk_simplify;

// Simplify many expressions in parallel
let expressions = vec![/* many expressions */];
let simplified = parallel_bulk_simplify(&amp;expressions);
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-results"><a class="header" href="#caching-results">Caching Results</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::core::performance::config::{
    cache_result,
    get_cached_result,
    compute_expr_hash,
};

let expr = expr!(x ^ 2);
let hash = compute_expr_hash(&amp;expr);

if let Some(cached) = get_cached_result(hash) {
    // Use cached result
    println!("Using cached result");
} else {
    // Compute and cache
    let result = expr.simplify();
    cache_result(hash, result.clone());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="educational-patterns"><a class="header" href="#educational-patterns">Educational Patterns</a></h2>
<h3 id="step-by-step-explanations-1"><a class="header" href="#step-by-step-explanations-1">Step-by-Step Explanations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::educational::*;

let x = symbol!(x);
let expr = expr!((x + 1) * (x - 1));

// Get explanation for simplification
let explanation = expr.explain_simplification();

for step in explanation.steps() {
    println!("Step: {}", step.title);
    println!("Description: {}", step.description);
    println!("Expression: {}", step.expression);
    println!();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="derivative-explanations"><a class="header" href="#derivative-explanations">Derivative Explanations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::educational::*;

let x = symbol!(x);
let expr = expr!(sin(x ^ 2));

// Get step-by-step derivative
let explanation = expr.explain_derivative(&amp;x);

for step in explanation.steps() {
    println!("{}: {}", step.title, step.description);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="avoid-runtime-variables-in-macros"><a class="header" href="#avoid-runtime-variables-in-macros">Avoid: Runtime Variables in Macros</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - creates Symbol("i"), not integer value
for i in 0..10 {
    let expr = expr!(i);  // BAD!
}

// CORRECT
for i in 0..10 {
    let expr = Expression::integer(i);  // GOOD!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="avoid-nested-macro-calls"><a class="header" href="#avoid-nested-macro-calls">Avoid: Nested Macro Calls</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - nested expr!() doesn't work
let expr = expr!(add: expr!(2 * x), expr!(3));  // BAD!

// CORRECT - use intermediate variables or direct patterns
let term1 = expr!(2 * x);
let term2 = expr!(3);
let expr = expr!(add: term1, term2);  // GOOD!

// OR use direct pattern
let expr = expr!(add: (2 * x), 3);  // GOOD!
<span class="boring">}</span></code></pre></pre>
<h3 id="avoid-float-equality"><a class="header" href="#avoid-float-equality">Avoid: Float Equality</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - comparing floats with ==
if expr.evaluate() == 3.14 { }  // BAD!

// CORRECT - use epsilon comparison
if (expr.evaluate() - 3.14).abs() &lt; 1e-10 { }  // GOOD!

// OR use exact rationals
let expr = Expression::rational(314, 100);  // Exact 3.14
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="getting-started/../core/expressions.html">Core Concepts</a> - Deep dive into the type system</li>
<li><a href="getting-started/../operations/simplification.html">Mathematical Operations</a> - Learn all operations</li>
<li><a href="getting-started/../performance/architecture.html">Performance</a> - Optimization techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>The <code>Expression</code> type is the foundation of MathHook. This chapter explains expression structure, creation, and manipulation.</p>
<h2 id="expression-structure"><a class="header" href="#expression-structure">Expression Structure</a></h2>
<p>Expressions in MathHook are represented as an enum with variants for different mathematical constructs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expression {
    // Numbers
    Integer(i64),
    Rational(Box&lt;RationalData&gt;),
    Float(f64),
    Complex(Box&lt;ComplexData&gt;),

    // Variables
    Symbol(Symbol),

    // Operations
    Add(Vec&lt;Expression&gt;),
    Mul(Vec&lt;Expression&gt;),
    Pow(Box&lt;Expression&gt;, Box&lt;Expression&gt;),

    // Functions
    Function(String, Vec&lt;Expression&gt;),

    // Constants
    Constant(ConstantType),

    // Matrices
    Matrix(Vec&lt;Vec&lt;Expression&gt;&gt;),

    // Relations
    Equation(Box&lt;Expression&gt;, Box&lt;Expression&gt;),

    // Other variants...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-expressions"><a class="header" href="#creating-expressions">Creating Expressions</a></h2>
<h3 id="using-macros-recommended"><a class="header" href="#using-macros-recommended">Using Macros (Recommended)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!((x ^ 2) + (2 * x) + 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="using-constructors-1"><a class="header" href="#using-constructors-1">Using Constructors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::Expression;

let expr = Expression::add(vec![
    Expression::pow(
        Expression::symbol(symbol!(x)),
        Expression::integer(2)
    ),
    Expression::mul(vec![
        Expression::integer(2),
        Expression::symbol(symbol!(x))
    ]),
    Expression::integer(1),
]);
<span class="boring">}</span></code></pre></pre>
<h2 id="expression-properties"><a class="header" href="#expression-properties">Expression Properties</a></h2>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>Expressions are <strong>immutable</strong> after creation. All operations return new expressions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!(x + 1);
let doubled = expr.mul(&amp;Expression::integer(2));  // Returns new expression
// `expr` is unchanged
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-efficiency"><a class="header" href="#memory-efficiency">Memory Efficiency</a></h3>
<p>Expressions are designed to be 32 bytes to fit in CPU cache lines for optimal performance.</p>
<h2 id="why-this-design"><a class="header" href="#why-this-design">Why This Design?</a></h2>
<h3 id="why-32-byte-expression-size"><a class="header" href="#why-32-byte-expression-size">Why 32-Byte Expression Size?</a></h3>
<p><strong>Design Decision</strong>: MathHook's Expression type is constrained to exactly 32 bytes.</p>
<p><strong>Why?</strong></p>
<ul>
<li>Modern CPUs have 64-byte cache lines (standard on x86-64, ARM64)</li>
<li>Two expressions fit perfectly in one cache line</li>
<li>Cache-friendly data structures yield 3-5x faster operations in hot loops</li>
<li>This is critical for CAS workloads with millions of expression traversals</li>
</ul>
<p><strong>Trade-off</strong>: Must use <code>Box&lt;T&gt;</code> for large nested structures</p>
<ul>
<li>Recursive types (like <code>Pow(Box&lt;Expression&gt;, Box&lt;Expression&gt;)</code>) use heap allocation</li>
<li>Pointer indirection has small overhead, but cache benefits far outweigh it</li>
<li>For typical expression trees (depth &lt; 50), the trade-off is heavily positive</li>
</ul>
<p><strong>Alternative Considered</strong>: Variable-size expressions (like Python objects)</p>
<ul>
<li><strong>Pros</strong>: Simpler implementation, no size constraints</li>
<li><strong>Cons</strong>: Poor cache locality, unpredictable performance, frequent cache misses</li>
<li><strong>Decision</strong>: Performance predictability &gt; implementation simplicity for CAS workload</li>
</ul>
<p><strong>When This Matters</strong>:</p>
<ul>
<li>Hot loops processing millions of expressions (simplification, pattern matching)</li>
<li>Recursive algorithms (symbolic differentiation, integration)</li>
<li>Less important: One-time parsing, display formatting, or educational explanations</li>
</ul>
<p><strong>Verification</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::size_of;
use mathhook_core::Expression;

assert_eq!(size_of::&lt;Expression&gt;(), 32);
<span class="boring">}</span></code></pre></pre>
<p><strong>Performance Impact</strong>: Benchmarks show 3-5x speedup on simplification and 2-3x on derivative computation compared to variable-size design.</p>
<hr />
<h3 id="why-immutable-expressions"><a class="header" href="#why-immutable-expressions">Why Immutable Expressions?</a></h3>
<p><strong>Design Decision</strong>: Expressions cannot be modified after creation. All operations return new expressions.</p>
<p><strong>Why?</strong></p>
<ul>
<li><strong>Thread Safety</strong>: Safe to share across threads without locks</li>
<li><strong>Correctness</strong>: No hidden mutation surprises</li>
<li><strong>Optimization</strong>: Compiler can optimize knowing values never change</li>
<li><strong>Debugging</strong>: Expression history is traceable</li>
</ul>
<p><strong>Trade-off</strong>: More allocations</p>
<ul>
<li>Each operation creates new expressions</li>
<li>Mitigated by: reference counting (cheap clones), arena allocation for bulk operations</li>
<li>Benchmark: &lt;100ns overhead per operation (negligible in practice)</li>
</ul>
<p><strong>Alternative Considered</strong>: Mutable expressions with copy-on-write</p>
<ul>
<li><strong>Pros</strong>: Fewer allocations in some cases</li>
<li><strong>Cons</strong>: Complex lifetime management, thread-safety issues, hard to reason about</li>
<li><strong>Decision</strong>: Simplicity and safety &gt; micro-optimization</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!(x + 1);
let doubled = expr.mul(&amp;Expression::integer(2));
// `expr` is unchanged, `doubled` is new expression
// Safe to use both in parallel
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="why-canonical-forms"><a class="header" href="#why-canonical-forms">Why Canonical Forms?</a></h3>
<p><strong>Design Decision</strong>: MathHook automatically normalizes expressions to canonical form.</p>
<p><strong>What is Canonical Form?</strong></p>
<ul>
<li><code>y + x</code> becomes <code>x + y</code> (sorted)</li>
<li><code>(a + b) + c</code> becomes <code>Add(a, b, c)</code> (flattened)</li>
<li><code>x + 0</code> becomes <code>x</code> (identity removed)</li>
<li><code>6/4</code> becomes <code>3/2</code> (rationals reduced)</li>
</ul>
<p><strong>Why?</strong></p>
<ul>
<li><strong>Equality checking</strong>: Structurally equal expressions are always equal</li>
<li><strong>Simplification</strong>: Canonical form is prerequisite for many simplification rules</li>
<li><strong>Consistency</strong>: Same mathematical expression always has same representation</li>
<li><strong>Performance</strong>: Pattern matching is faster on normalized expressions</li>
</ul>
<p><strong>Trade-off</strong>: Small overhead on construction</p>
<ul>
<li>Every <code>add()</code>, <code>mul()</code>, <code>pow()</code> normalizes</li>
<li>Typically &lt;50ns per operation</li>
<li>Benefit: Avoid expensive normalization later during pattern matching</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr1 = expr!(x + y);
let expr2 = expr!(y + x);
assert_eq!(expr1, expr2);  // True - both normalized to x + y
<span class="boring">}</span></code></pre></pre>
<p><strong>When This Matters</strong>:</p>
<ul>
<li>Expression equality checking (hash tables, caches)</li>
<li>Pattern matching in simplification rules</li>
<li>Zero detection (is expression mathematically zero?)</li>
</ul>
<hr />
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<p>Expressions are <code>Send + Sync</code>, making them safe to share across threads:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let expr = Arc::new(expr!(x ^ 2));
let expr_clone = Arc::clone(&amp;expr);
// Use in multiple threads safely
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<p>Work with expression structure using Rust's pattern matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match expr {
    Expression::Add(terms) =&gt; {
        println!("Sum with {} terms", terms.len());
    }
    Expression::Mul(factors) =&gt; {
        println!("Product with {} factors", factors.len());
    }
    Expression::Pow(base, exp) =&gt; {
        println!("Power: {} ^ {}", base, exp);
    }
    Expression::Function(name, args) =&gt; {
        println!("Function {} with {} args", name, args.len());
    }
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="canonical-forms"><a class="header" href="#canonical-forms">Canonical Forms</a></h2>
<p>Expressions automatically maintain canonical forms:</p>
<ul>
<li><strong>Commutative operations sorted</strong>: \(y + x \rightarrow x + y\)</li>
<li><strong>Associativity flattened</strong>: \((a + b) + c \rightarrow a + b + c\)</li>
<li><strong>Identity elimination</strong>: \(x + 0 \rightarrow x\), \(x * 1 \rightarrow x\)</li>
<li><strong>Rationals reduced</strong>: \(\frac{6}{4} \rightarrow \frac{3}{2}\)</li>
</ul>
<h2 id="common-operations-1"><a class="header" href="#common-operations-1">Common Operations</a></h2>
<h3 id="simplification-1"><a class="header" href="#simplification-1">Simplification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!(x + x);
let simplified = expr.simplify();
// Result: 2*x
<span class="boring">}</span></code></pre></pre>
<h3 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!(x ^ 2);
let result = expr.substitute(&amp;x, &amp;Expression::integer(3));
// Result: 9
<span class="boring">}</span></code></pre></pre>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!(x ^ 2);

println!("Standard: {}", expr);         // x^2
println!("LaTeX: {}", expr.to_latex()); // x^{2}
println!("Wolfram: {}", expr.to_wolfram()); // Power[x, 2]
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="core/./symbols-numbers.html">Symbols and Numbers</a></li>
<li><a href="core/./functions.html">Functions</a></li>
<li><a href="core/../operations/simplification.html">Mathematical Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols-and-numbers"><a class="header" href="#symbols-and-numbers">Symbols and Numbers</a></h1>
<p>This chapter covers the two fundamental building blocks of expressions: symbols (variables) and numbers.</p>
<h2 id="symbols"><a class="header" href="#symbols">Symbols</a></h2>
<p>Symbols represent mathematical variables like \(x\), \(y\), \(\theta\), etc.</p>
<h3 id="creating-symbols"><a class="header" href="#creating-symbols">Creating Symbols</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let y = symbol!(y);
let theta = symbol!(theta);
<span class="boring">}</span></code></pre></pre>
<h3 id="symbol-equality"><a class="header" href="#symbol-equality">Symbol Equality</a></h3>
<p>Symbols with the same name are considered equal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(symbol!(x), symbol!(x));
assert_ne!(symbol!(x), symbol!(y));
<span class="boring">}</span></code></pre></pre>
<h3 id="string-interning"><a class="header" href="#string-interning">String Interning</a></h3>
<p>MathHook uses string interning for symbols, making equality checks O(1) pointer comparisons.</p>
<h2 id="why-this-design-1"><a class="header" href="#why-this-design-1">Why This Design?</a></h2>
<h3 id="why-string-interning-for-symbols"><a class="header" href="#why-string-interning-for-symbols">Why String Interning for Symbols?</a></h3>
<p><strong>Design Decision</strong>: Symbol names are stored in a global intern table, with symbols holding only a reference.</p>
<p><strong>Why?</strong></p>
<ul>
<li><strong>Fast equality</strong>: Comparing two symbols is a single pointer comparison (O(1))</li>
<li><strong>Memory efficiency</strong>: Symbol name "x" stored once, shared by all <code>symbol!(x)</code> instances</li>
<li><strong>Cache-friendly</strong>: Symbols are just pointers (8 bytes on 64-bit systems)</li>
</ul>
<p><strong>Without Interning</strong>: Every <code>symbol!(x)</code> would store its own copy of "x" and require string comparison (O(n))</p>
<p><strong>Trade-off</strong>: Global mutable state for intern table</p>
<ul>
<li>Thread-safe using locks or lock-free data structures</li>
<li>One-time cost on first use of each symbol name</li>
<li>Benefit far outweighs cost (10-100x faster symbol comparison)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x1 = symbol!(x);
let x2 = symbol!(x);
// Same pointer internally - O(1) comparison
assert_eq!(x1, x2);
<span class="boring">}</span></code></pre></pre>
<p><strong>When This Matters</strong>:</p>
<ul>
<li>Pattern matching with many symbol comparisons</li>
<li>Substitution operations</li>
<li>Expression equality checking</li>
<li>Hash table lookups</li>
</ul>
<hr />
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>MathHook supports multiple number types for different use cases.</p>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Arbitrary precision integers for exact computation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = Expression::integer(123456789);
let large = Expression::integer(9999999999999999999); // Arbitrary precision
<span class="boring">}</span></code></pre></pre>
<h3 id="rationals"><a class="header" href="#rationals">Rationals</a></h3>
<p>Exact representation of fractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frac = Expression::rational(22, 7);  // 22/7 ≈ π
let half = Expression::rational(1, 2);   // 1/2

// Always in reduced form
let six_fourths = Expression::rational(6, 4);  // Automatically becomes 3/2
<span class="boring">}</span></code></pre></pre>
<h3 id="floats"><a class="header" href="#floats">Floats</a></h3>
<p>Floating-point numbers for approximate computation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi_approx = Expression::float(3.14159265359);
let e_approx = Expression::float(2.71828182846);
<span class="boring">}</span></code></pre></pre>
<p><strong>Warning</strong>: Use floats only when approximation is acceptable. Prefer rationals for exact arithmetic.</p>
<h2 id="why-rational-numbers-over-floats"><a class="header" href="#why-rational-numbers-over-floats">Why Rational Numbers Over Floats?</a></h2>
<h3 id="design-decision-exact-rational-arithmetic"><a class="header" href="#design-decision-exact-rational-arithmetic">Design Decision: Exact Rational Arithmetic</a></h3>
<p><strong>Why MathHook Uses Rationals for Symbolic Math</strong>:</p>
<p><strong>The Problem with Floats</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using floats (WRONG for symbolic math)
let third = 0.33333333;
let result = 3.0 * third;
// Result: 0.99999999 (imprecise)

// Using rationals (CORRECT for symbolic math)
let third = Expression::rational(1, 3);
let result = Expression::mul(vec![Expression::integer(3), third]);
// Result: 1 (exact)
<span class="boring">}</span></code></pre></pre>
<p><strong>Why?</strong></p>
<ul>
<li><strong>Mathematical correctness</strong>: <code>1/3</code> is exactly <code>1/3</code>, not an approximation</li>
<li><strong>Symbolic operations</strong>: Algebra requires exactness (cannot lose precision)</li>
<li><strong>Accumulation prevention</strong>: No rounding error buildup</li>
<li><strong>Comparison reliability</strong>: Exact equality testing</li>
</ul>
<p><strong>When We Use Floats</strong>:</p>
<ul>
<li>Only for numerical approximation (explicit <code>.evalf()</code>)</li>
<li>Only when exact representation is impossible (e.g., transcendental results)</li>
<li><strong>NEVER</strong> in symbolic operations</li>
</ul>
<p><strong>Real-World Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Solving x^2 - 2 = 0 symbolically
let x = symbol!(x);
let eq = expr!((x ^ 2) - 2);
let solutions = eq.solve(&amp;x);
// Solutions: [-√2, √2] (exact symbolic form)
// NOT: [-1.414213562, 1.414213562] (approximate floats)
<span class="boring">}</span></code></pre></pre>
<p><strong>Alternative Considered</strong>: Always use floats (like numerical libraries)</p>
<ul>
<li><strong>Pros</strong>: Simpler implementation, predictable memory usage</li>
<li><strong>Cons</strong>: Catastrophic for symbolic algebra (precision loss, equality breaks)</li>
<li><strong>Decision</strong>: Exact arithmetic is non-negotiable for CAS</li>
</ul>
<p><strong>Why This Matters</strong>:</p>
<ul>
<li>Computer algebra requires exactness by definition</li>
<li>SymPy and Mathematica use same approach</li>
<li>Prevents subtle bugs from rounding errors</li>
<li>Enables reliable symbolic simplification</li>
</ul>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Rational arithmetic is slower than float (2-10x)</li>
<li>Acceptable trade-off for correctness</li>
<li>Use <code>.evalf()</code> when you need speed and can tolerate approximation</li>
</ul>
<hr />
<h3 id="why-16-byte-number-type"><a class="header" href="#why-16-byte-number-type">Why 16-Byte Number Type?</a></h3>
<p><strong>Design Decision</strong>: The <code>Number</code> type is exactly 16 bytes.</p>
<p><strong>Why?</strong></p>
<ul>
<li><strong>Cache efficiency</strong>: Two numbers fit in a 32-byte expression</li>
<li><strong>Tagged union</strong>: Discriminant + data in 16 bytes</li>
<li><strong>Balance</strong>: Small enough for cache, large enough for pointer + metadata</li>
</ul>
<p><strong>Structure</strong>:</p>
<pre><code>[1 byte: type tag] [15 bytes: data]
- Integer: pointer to BigInt (8 bytes) + padding
- Rational: two pointers to BigInt numerator/denominator (need clever packing)
- Float: f64 (8 bytes) + padding
- Complex: pointer to ComplexData (8 bytes) + padding
</code></pre>
<p><strong>Trade-off</strong>: Arbitrary precision requires heap allocation</p>
<ul>
<li>Small integers (i64) could fit inline, but design consistency favors uniform handling</li>
<li>Large integers/rationals use <code>BigInt</code> on heap (pointer stored in 16 bytes)</li>
</ul>
<p><strong>Alternative Considered</strong>: Variable-size numbers</p>
<ul>
<li><strong>Pros</strong>: i64 could be inline (faster)</li>
<li><strong>Cons</strong>: Variable size breaks expression size constraint</li>
<li><strong>Decision</strong>: Uniform 16-byte size maintains expression size guarantee</li>
</ul>
<hr />
<h3 id="complex-numbers"><a class="header" href="#complex-numbers">Complex Numbers</a></h3>
<p>Complex numbers with real and imaginary parts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3 + 4i
let z = Expression::complex(
    Expression::integer(3),
    Expression::integer(4)
);

// Or using addition
let z = Expression::add(vec![
    Expression::integer(3),
    Expression::mul(vec![Expression::integer(4), Expression::i()])
]);
<span class="boring">}</span></code></pre></pre>
<h2 id="number-operations"><a class="header" href="#number-operations">Number Operations</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Expression::integer(2);
let b = Expression::integer(3);

let sum = Expression::add(vec![a.clone(), b.clone()]);      // 5
let product = Expression::mul(vec![a.clone(), b.clone()]);  // 6
let power = Expression::pow(a.clone(), b.clone());          // 8
<span class="boring">}</span></code></pre></pre>
<h3 id="exact-vs-approximate"><a class="header" href="#exact-vs-approximate">Exact vs Approximate</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Exact: Use rationals
let exact = Expression::rational(1, 3);
let tripled = Expression::mul(vec![exact, Expression::integer(3)]);
// Result: 1 (exact)

// Approximate: Use floats
let approx = Expression::float(0.333333);
let tripled_approx = Expression::mul(vec![approx, Expression::float(3.0)]);
// Result: 0.999999 (approximate)
<span class="boring">}</span></code></pre></pre>
<h2 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h2>
<h3 id="to-float"><a class="header" href="#to-float">To Float</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rational = Expression::rational(1, 3);
let as_float = rational.to_float();  // 0.333...
<span class="boring">}</span></code></pre></pre>
<h3 id="to-rational"><a class="header" href="#to-rational">To Rational</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let float = Expression::float(0.5);
let as_rational = float.to_rational();  // 1/2 (if representable)
<span class="boring">}</span></code></pre></pre>
<h2 id="mathematical-constants"><a class="header" href="#mathematical-constants">Mathematical Constants</a></h2>
<p>Pre-defined constants are available:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = Expression::pi();           // π
let e = Expression::e();             // e
let i = Expression::i();             // i (imaginary unit)
let phi = Expression::golden_ratio(); // φ = (1 + √5) / 2
let gamma = Expression::euler_gamma(); // γ (Euler-Mascheroni constant)
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="core/./functions.html">Functions</a></li>
<li><a href="core/./constants.html">Constants</a></li>
<li><a href="core/../operations/simplification.html">Mathematical Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder"><a class="header" href="#chapter-placeholder">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="core/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="core/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-1"><a class="header" href="#chapter-placeholder-1">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="core/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="core/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-2"><a class="header" href="#chapter-placeholder-2">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="core/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="core/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-3"><a class="header" href="#chapter-placeholder-3">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-4"><a class="header" href="#chapter-placeholder-4">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-5"><a class="header" href="#chapter-placeholder-5">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differentiation"><a class="header" href="#differentiation">Differentiation</a></h1>
<p>Symbolic differentiation in MathHook uses automatic differentiation with the chain rule, product rule, quotient rule, and function-specific derivative rules.</p>
<h2 id="computing-derivatives-1"><a class="header" href="#computing-derivatives-1">Computing Derivatives</a></h2>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::prelude::*;

let x = symbol!(x);
let expr = expr!(x ^ 3);

// First derivative: 3x^2
let derivative = expr.derivative(&amp;x, 1);
println!("{}", derivative);

// Second derivative: 6x
let second_derivative = expr.derivative(&amp;x, 2);
println!("{}", second_derivative);
<span class="boring">}</span></code></pre></pre>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python">from mathhook import Symbol, derivative

x = Symbol('x')
expr = x**3

# First derivative
df = derivative(expr, x)
print(df)  # 3*x^2

# Second derivative
d2f = derivative(expr, x, order=2)
print(d2f)  # 6*x
</code></pre>
<h3 id="nodejstypescript-1"><a class="header" href="#nodejstypescript-1">Node.js/TypeScript</a></h3>
<pre><code class="language-typescript">import { Symbol, parse, derivative } from 'mathhook';

const x = new Symbol('x');
const expr = parse('x^3');

// First derivative
const df = derivative(expr, x);
console.log(df.toString());  // 3*x^2

// Second derivative
const d2f = derivative(expr, x, { order: 2 });
console.log(d2f.toString());  // 6*x
</code></pre>
<hr />
<h2 id="differentiation-rules"><a class="header" href="#differentiation-rules">Differentiation Rules</a></h2>
<h3 id="power-rule"><a class="header" href="#power-rule">Power Rule</a></h3>
<p>\[
\frac{d}{dx} x^n = n x^{n-1}
\]</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!(x ^ 5);
let deriv = expr.derivative(&amp;x, 1);
// Result: 5 * x^4
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
expr = x**5
deriv = derivative(expr, x)
# Result: 5 * x^4
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('x^5');
const deriv = derivative(expr, x);
// Result: 5 * x^4
</code></pre>
<h3 id="product-rule"><a class="header" href="#product-rule">Product Rule</a></h3>
<p>\[
\frac{d}{dx} [f(x) \cdot g(x)] = f'(x) \cdot g(x) + f(x) \cdot g'(x)
\]</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let f = expr!(x ^ 2);
let g = expr!(x ^ 3);
let product = expr!(mul: f, g);  // x^2 * x^3

let deriv = product.derivative(&amp;x, 1);
// Result: 2*x * x^3 + x^2 * 3*x^2 = 5*x^4
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
f = x**2
g = x**3
product = f * g  # x^2 * x^3

deriv = derivative(product, x)
# Result: 5*x^4
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('x^2 * x^3');
const deriv = derivative(expr, x);
// Result: 5*x^4
</code></pre>
<h3 id="quotient-rule"><a class="header" href="#quotient-rule">Quotient Rule</a></h3>
<p>\[
\frac{d}{dx} \frac{f(x)}{g(x)} = \frac{f'(x) \cdot g(x) - f(x) \cdot g'(x)}{[g(x)]^2}
\]</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let numerator = expr!(x ^ 2);
let denominator = expr!(x + 1);
let quotient = expr!(div: numerator, denominator);

let deriv = quotient.derivative(&amp;x, 1);
// Result: (2*x*(x+1) - x^2*1) / (x+1)^2
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
numerator = x**2
denominator = x + 1
quotient = numerator / denominator

deriv = derivative(quotient, x)
# Result: (2*x*(x+1) - x^2) / (x+1)^2
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('x^2 / (x + 1)');
const deriv = derivative(expr, x);
// Result: (2*x*(x+1) - x^2) / (x+1)^2
</code></pre>
<h3 id="chain-rule"><a class="header" href="#chain-rule">Chain Rule</a></h3>
<p>\[
\frac{d}{dx} f(g(x)) = f'(g(x)) \cdot g'(x)
\]</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let inner = expr!(x ^ 2);
let outer = expr!(sin(inner));  // sin(x^2)

let deriv = outer.derivative(&amp;x, 1);
// Result: cos(x^2) * 2*x
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">from mathhook import sin

x = Symbol('x')
inner = x**2
outer = sin(inner)  # sin(x^2)

deriv = derivative(outer, x)
# Result: cos(x^2) * 2*x
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('sin(x^2)');
const deriv = derivative(expr, x);
// Result: cos(x^2) * 2*x
</code></pre>
<hr />
<h2 id="trigonometric-derivatives"><a class="header" href="#trigonometric-derivatives">Trigonometric Derivatives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Derivative</th></tr></thead><tbody>
<tr><td>\(\sin(x)\)</td><td>\(\cos(x)\)</td></tr>
<tr><td>\(\cos(x)\)</td><td>\(-\sin(x)\)</td></tr>
<tr><td>\(\tan(x)\)</td><td>\(\sec^2(x)\)</td></tr>
<tr><td>\(\cot(x)\)</td><td>\(-\csc^2(x)\)</td></tr>
<tr><td>\(\sec(x)\)</td><td>\(\sec(x) \tan(x)\)</td></tr>
<tr><td>\(\csc(x)\)</td><td>\(-\csc(x) \cot(x)\)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong>:</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!(sin(x));
let deriv = expr.derivative(&amp;x, 1);
// Result: cos(x)
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">from mathhook import sin

x = Symbol('x')
expr = sin(x)
deriv = derivative(expr, x)
# Result: cos(x)
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('sin(x)');
const deriv = derivative(expr, x);
// Result: cos(x)
</code></pre>
<hr />
<h2 id="exponential-and-logarithmic-derivatives"><a class="header" href="#exponential-and-logarithmic-derivatives">Exponential and Logarithmic Derivatives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Derivative</th></tr></thead><tbody>
<tr><td>\(e^x\)</td><td>\(e^x\)</td></tr>
<tr><td>\(a^x\)</td><td>\(a^x \ln(a)\)</td></tr>
<tr><td>\(\ln(x)\)</td><td>\(\frac{1}{x}\)</td></tr>
<tr><td>\(\log_a(x)\)</td><td>\(\frac{1}{x \ln(a)}\)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong>:</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!(exp(x));
let deriv = expr.derivative(&amp;x, 1);
// Result: exp(x)

let ln_expr = expr!(log(x));
let ln_deriv = ln_expr.derivative(&amp;x, 1);
// Result: 1/x
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">from mathhook import exp, log

x = Symbol('x')

# Exponential
expr = exp(x)
deriv = derivative(expr, x)
# Result: exp(x)

# Logarithm
ln_expr = log(x)
ln_deriv = derivative(ln_expr, x)
# Result: 1/x
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');

// Exponential
const expr = parse('exp(x)');
const deriv = derivative(expr, x);
// Result: exp(x)

// Logarithm
const lnExpr = parse('log(x)');
const lnDeriv = derivative(lnExpr, x);
// Result: 1/x
</code></pre>
<hr />
<h2 id="partial-derivatives"><a class="header" href="#partial-derivatives">Partial Derivatives</a></h2>
<p>For multivariable functions, compute partial derivatives with respect to each variable.</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let y = symbol!(y);
let expr = expr!((x ^ 2) * y);

// Partial derivative with respect to x
let df_dx = expr.derivative(&amp;x, 1);
// Result: 2*x*y

// Partial derivative with respect to y
let df_dy = expr.derivative(&amp;y, 1);
// Result: x^2
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
y = Symbol('y')
expr = x**2 * y

# Partial derivative with respect to x
df_dx = derivative(expr, x)
# Result: 2*x*y

# Partial derivative with respect to y
df_dy = derivative(expr, y)
# Result: x^2
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const y = new Symbol('y');
const expr = parse('x^2 * y');

// Partial derivative with respect to x
const df_dx = derivative(expr, x);
// Result: 2*x*y

// Partial derivative with respect to y
const df_dy = derivative(expr, y);
// Result: x^2
</code></pre>
<hr />
<h2 id="higher-order-derivatives"><a class="header" href="#higher-order-derivatives">Higher-Order Derivatives</a></h2>
<p>Compute second, third, or nth order derivatives by specifying the order parameter.</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!(x ^ 4);

// First derivative: 4*x^3
let first = expr.derivative(&amp;x, 1);

// Second derivative: 12*x^2
let second = expr.derivative(&amp;x, 2);

// Third derivative: 24*x
let third = expr.derivative(&amp;x, 3);

// Fourth derivative: 24
let fourth = expr.derivative(&amp;x, 4);
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
expr = x**4

# First derivative: 4*x^3
first = derivative(expr, x, order=1)

# Second derivative: 12*x^2
second = derivative(expr, x, order=2)

# Third derivative: 24*x
third = derivative(expr, x, order=3)

# Fourth derivative: 24
fourth = derivative(expr, x, order=4)
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const expr = parse('x^4');

// First derivative: 4*x^3
const first = derivative(expr, x, { order: 1 });

// Second derivative: 12*x^2
const second = derivative(expr, x, { order: 2 });

// Third derivative: 24*x
const third = derivative(expr, x, { order: 3 });

// Fourth derivative: 24
const fourth = derivative(expr, x, { order: 4 });
</code></pre>
<hr />
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="example-1-velocity-and-acceleration"><a class="header" href="#example-1-velocity-and-acceleration">Example 1: Velocity and Acceleration</a></h3>
<p>Position function: \(s(t) = t^3 - 6t^2 + 9t\)</p>
<p>Velocity (first derivative): \(v(t) = 3t^2 - 12t + 9\)</p>
<p>Acceleration (second derivative): \(a(t) = 6t - 12\)</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t = symbol!(t);
let position = expr!((t ^ 3) - (6 * (t ^ 2)) + (9 * t));

let velocity = position.derivative(&amp;t, 1);
println!("Velocity: {}", velocity);  // 3*t^2 - 12*t + 9

let acceleration = position.derivative(&amp;t, 2);
println!("Acceleration: {}", acceleration);  // 6*t - 12
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">t = Symbol('t')
position = t**3 - 6*t**2 + 9*t

velocity = derivative(position, t)
print(f"Velocity: {velocity}")  # 3*t^2 - 12*t + 9

acceleration = derivative(position, t, order=2)
print(f"Acceleration: {acceleration}")  # 6*t - 12
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const t = new Symbol('t');
const position = parse('t^3 - 6*t^2 + 9*t');

const velocity = derivative(position, t);
console.log(`Velocity: ${velocity.toString()}`);  // 3*t^2 - 12*t + 9

const acceleration = derivative(position, t, { order: 2 });
console.log(`Acceleration: ${acceleration.toString()}`);  // 6*t - 12
</code></pre>
<h3 id="example-2-gradient-multivariable"><a class="header" href="#example-2-gradient-multivariable">Example 2: Gradient (Multivariable)</a></h3>
<p>For function \(f(x, y) = x^2 + y^2\), compute gradient \(\nabla f = [\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}]\)</p>
<p><strong>Rust</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let y = symbol!(y);
let f = expr!((x ^ 2) + (y ^ 2));

let df_dx = f.derivative(&amp;x, 1);  // 2*x
let df_dy = f.derivative(&amp;y, 1);  // 2*y

// Gradient: [2*x, 2*y]
<span class="boring">}</span></code></pre></pre>
<p><strong>Python</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
y = Symbol('y')
f = x**2 + y**2

df_dx = derivative(f, x)  # 2*x
df_dy = derivative(f, y)  # 2*y

# Gradient: [2*x, 2*y]
gradient = [df_dx, df_dy]
</code></pre>
<p><strong>Node.js</strong>:</p>
<pre><code class="language-typescript">const x = new Symbol('x');
const y = new Symbol('y');
const f = parse('x^2 + y^2');

const df_dx = derivative(f, x);  // 2*x
const df_dy = derivative(f, y);  // 2*y

// Gradient: [2*x, 2*y]
const gradient = [df_dx, df_dy];
</code></pre>
<hr />
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li>
<p><strong>Simplify After Differentiation</strong>: Derivatives can produce complex expressions. Simplify for cleaner results.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let deriv = expr.derivative(&amp;x, 1);
let simplified = deriv.simplify();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Cache Derivatives</strong>: For repeated use, compute once and reuse.</p>
</li>
<li>
<p><strong>Use Numerical Derivatives for Approximation</strong>: For very complex expressions where symbolic derivatives are slow, consider numerical approximation (not yet in MathHook core, but can be built on top).</p>
</li>
</ol>
<hr />
<h2 id="common-errors-and-pitfalls"><a class="header" href="#common-errors-and-pitfalls">Common Errors and Pitfalls</a></h2>
<h3 id="undefined-derivatives"><a class="header" href="#undefined-derivatives">Undefined Derivatives</a></h3>
<p>Some functions have undefined derivatives at certain points:</p>
<ul>
<li>\(\frac{d}{dx} |x| \) is undefined at \(x = 0\)</li>
<li>\(\frac{d}{dx} \sqrt{x}\) is undefined at \(x = 0\)</li>
</ul>
<p>MathHook will produce symbolic results; domain checking happens during evaluation.</p>
<h3 id="non-differentiable-functions"><a class="header" href="#non-differentiable-functions">Non-Differentiable Functions</a></h3>
<p>Functions must be differentiable. MathHook assumes smoothness unless explicitly handling piecewise functions.</p>
<hr />
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="operations/./integration.html">Integration</a> - Symbolic integration</li>
<li><a href="operations/./limits.html">Limits</a> - Computing limits</li>
<li><a href="operations/./series.html">Series Expansion</a> - Taylor and Maclaurin series</li>
<li><a href="operations/../educational/step-by-step.html">Educational Features</a> - Step-by-step derivative explanations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-6"><a class="header" href="#chapter-placeholder-6">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-7"><a class="header" href="#chapter-placeholder-7">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-8"><a class="header" href="#chapter-placeholder-8">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-9"><a class="header" href="#chapter-placeholder-9">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook">API Documentation</a></li>
<li><a href="operations/../../CLAUDE.html">CLAUDE.md</a> for developer documentation</li>
<li><a href="operations/../../USAGE.html">Usage Guide</a> for examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-10"><a class="header" href="#chapter-placeholder-10">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-11"><a class="header" href="#chapter-placeholder-11">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-12"><a class="header" href="#chapter-placeholder-12">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-13"><a class="header" href="#chapter-placeholder-13">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-14"><a class="header" href="#chapter-placeholder-14">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-15"><a class="header" href="#chapter-placeholder-15">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="advanced/../../USAGE.html">Usage Guide</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-16"><a class="header" href="#chapter-placeholder-16">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/parser/">Parser module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-17"><a class="header" href="#chapter-placeholder-17">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/parser/">Parser module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-18"><a class="header" href="#chapter-placeholder-18">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/parser/">Parser module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-19"><a class="header" href="#chapter-placeholder-19">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/parser/">Parser module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-20"><a class="header" href="#chapter-placeholder-20">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/educational/">Educational module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-21"><a class="header" href="#chapter-placeholder-21">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/educational/">Educational module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-22"><a class="header" href="#chapter-placeholder-22">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/educational/">Educational module documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-23"><a class="header" href="#chapter-placeholder-23">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/core/performance/">Performance module documentation</a></li>
<li><a href="performance/../../CLAUDE.html#performance-optimization-guidelines">CLAUDE.md Performance section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-24"><a class="header" href="#chapter-placeholder-24">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/core/performance/">Performance module documentation</a></li>
<li><a href="performance/../../CLAUDE.html#performance-optimization-guidelines">CLAUDE.md Performance section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-25"><a class="header" href="#chapter-placeholder-25">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/core/performance/">Performance module documentation</a></li>
<li><a href="performance/../../CLAUDE.html#performance-optimization-guidelines">CLAUDE.md Performance section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-26"><a class="header" href="#chapter-placeholder-26">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/core/performance/">Performance module documentation</a></li>
<li><a href="performance/../../CLAUDE.html#performance-optimization-guidelines">CLAUDE.md Performance section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-placeholder-27"><a class="header" href="#chapter-placeholder-27">Chapter Placeholder</a></h1>
<p>This chapter is under development. Please check back soon for complete documentation.</p>
<p>For now, please refer to:</p>
<ul>
<li><a href="https://docs.rs/mathhook-core/latest/mathhook_core/core/performance/">Performance module documentation</a></li>
<li><a href="performance/../../CLAUDE.html#performance-optimization-guidelines">CLAUDE.md Performance section</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles-1"><a class="header" href="#design-principles-1">Design Principles</a></h1>
<p>MathHook is built on five core principles, listed in strict priority order.</p>
<h2 id="1-mathematical-correctness-first"><a class="header" href="#1-mathematical-correctness-first">1. Mathematical Correctness First</a></h2>
<p><strong>This is the absolute highest priority. All other principles are secondary.</strong></p>
<p>Every mathematical operation in MathHook must be correct in ALL cases:</p>
<ul>
<li>Equation solving handles all valid cases correctly</li>
<li>Simplification preserves mathematical equivalence</li>
<li>Domain restrictions are respected (sqrt, log, division by zero)</li>
<li>Symbolic operations maintain algebraic properties</li>
</ul>
<h3 id="zero-tolerance-for-regressions"><a class="header" href="#zero-tolerance-for-regressions">Zero Tolerance for Regressions</a></h3>
<p>Any modification that breaks existing correct functionality is an unacceptable failure.</p>
<h3 id="validation-against-references"><a class="header" href="#validation-against-references">Validation Against References</a></h3>
<ul>
<li><strong>SymPy</strong> (<code>~/Documents/work/math/sympy/</code>): Primary validation reference</li>
<li><strong>Symbolica</strong> (<code>~/Documents/work/math/symbolica</code>): Secondary reference</li>
</ul>
<h2 id="2-performance"><a class="header" href="#2-performance">2. Performance</a></h2>
<p>After correctness, performance is the next priority.</p>
<h3 id="32-byte-expression-constraint"><a class="header" href="#32-byte-expression-constraint">32-Byte Expression Constraint</a></h3>
<p>Expressions are exactly 32 bytes to fit two expressions per 64-byte cache line (standard on modern CPUs). This constraint:</p>
<ul>
<li>Enables efficient memory access patterns</li>
<li>Improves CPU cache utilization</li>
<li>Provides 10-100x speedup over Python-based systems</li>
</ul>
<h3 id="zero-copy-parsing"><a class="header" href="#zero-copy-parsing">Zero-Copy Parsing</a></h3>
<p>Parse strings directly into AST without intermediate allocations.</p>
<h3 id="simd-operations"><a class="header" href="#simd-operations">SIMD Operations</a></h3>
<p>Vectorized operations for bulk arithmetic provide 2-4x speedup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SIMD automatically used for arrays &gt; 100 elements
let values = vec![1.0, 2.0, 3.0, /* ... many values */];
let sum = simd_bulk_add_numeric(&amp;values);
<span class="boring">}</span></code></pre></pre>
<h3 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h3>
<p>Immutable expressions enable parallel processing without locks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expressions = vec![/* many expressions */];
let simplified = parallel_bulk_simplify(&amp;expressions);
<span class="boring">}</span></code></pre></pre>
<h2 id="3-ergonomic-api"><a class="header" href="#3-ergonomic-api">3. Ergonomic API</a></h2>
<p>MathHook provides natural, intuitive APIs.</p>
<h3 id="macros-for-clarity"><a class="header" href="#macros-for-clarity">Macros for Clarity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clean and readable
let expr = expr!((x ^ 2) + (2 * x) + 1);

// vs verbose API
let expr = Expression::add(vec![
    Expression::pow(Expression::symbol(symbol!(x)), Expression::integer(2)),
    Expression::mul(vec![Expression::integer(2), Expression::symbol(symbol!(x))]),
    Expression::integer(1),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let y = symbol!(y);

// Natural arithmetic
let sum = x + y;
let product = x * y;
<span class="boring">}</span></code></pre></pre>
<h2 id="4-educational-value"><a class="header" href="#4-educational-value">4. Educational Value</a></h2>
<p>MathHook provides step-by-step explanations for all operations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let explanation = expr.explain_simplification();

for step in explanation.steps() {
    println!("{}: {}", step.title, step.description);
}
<span class="boring">}</span></code></pre></pre>
<p>This makes MathHook ideal for:</p>
<ul>
<li>Educational software</li>
<li>Learning platforms</li>
<li>Interactive mathematics tools</li>
<li>Automated tutoring systems</li>
</ul>
<h2 id="5-multi-language-support"><a class="header" href="#5-multi-language-support">5. Multi-Language Support</a></h2>
<p>MathHook provides first-class bindings for multiple languages:</p>
<ul>
<li><strong>Rust</strong> (native)</li>
<li><strong>Python</strong> (via PyO3)</li>
<li><strong>Node.js/TypeScript</strong> (via NAPI-RS)</li>
<li><strong>WebAssembly</strong> (coming soon)</li>
</ul>
<p>All bindings maintain the same correctness and performance guarantees.</p>
<h2 id="architectural-constraints"><a class="header" href="#architectural-constraints">Architectural Constraints</a></h2>
<h3 id="type-system-constraints"><a class="header" href="#type-system-constraints">Type System Constraints</a></h3>
<p>These are non-negotiable:</p>
<ul>
<li><strong>Expression</strong>: 32 bytes (cache-line optimization)</li>
<li><strong>Number</strong>: 16 bytes (fits in Expression)</li>
<li><strong>Symbol</strong>: String interning for O(1) equality</li>
</ul>
<h3 id="immutability-1"><a class="header" href="#immutability-1">Immutability</a></h3>
<p>All expressions are immutable after creation. This enables:</p>
<ul>
<li>Thread-safe sharing</li>
<li>Reliable caching</li>
<li>Predictable behavior</li>
</ul>
<h3 id="canonical-forms-1"><a class="header" href="#canonical-forms-1">Canonical Forms</a></h3>
<p>Expressions maintain canonical forms automatically:</p>
<ul>
<li>Commutative operations sorted</li>
<li>Associativity flattened</li>
<li>Identity elements eliminated</li>
<li>Rationals reduced</li>
</ul>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="architecture/./type-system.html">Type System</a></li>
<li><a href="architecture/./function-intelligence.html">Function Intelligence System</a></li>
<li><a href="architecture/./memory-layout.html">Memory Layout</a></li>
<li><a href="architecture/./thread-safety.html">Thread Safety</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-details"><a class="header" href="#architecture-details">Architecture Details</a></h1>
<p>For complete architectural documentation, see <a href="architecture/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>This chapter covers internal implementation details. Key topics:</p>
<ul>
<li>Type system design and constraints</li>
<li>Function intelligence registry</li>
<li>Memory layout optimization (32-byte expressions)</li>
<li>Thread safety guarantees</li>
</ul>
<p>See <a href="architecture/../../CLAUDE.html">CLAUDE.md</a> for comprehensive architectural documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-details-1"><a class="header" href="#architecture-details-1">Architecture Details</a></h1>
<p>For complete architectural documentation, see <a href="architecture/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>This chapter covers internal implementation details. Key topics:</p>
<ul>
<li>Type system design and constraints</li>
<li>Function intelligence registry</li>
<li>Memory layout optimization (32-byte expressions)</li>
<li>Thread safety guarantees</li>
</ul>
<p>See <a href="architecture/../../CLAUDE.html">CLAUDE.md</a> for comprehensive architectural documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-details-2"><a class="header" href="#architecture-details-2">Architecture Details</a></h1>
<p>For complete architectural documentation, see <a href="architecture/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>This chapter covers internal implementation details. Key topics:</p>
<ul>
<li>Type system design and constraints</li>
<li>Function intelligence registry</li>
<li>Memory layout optimization (32-byte expressions)</li>
<li>Thread safety guarantees</li>
</ul>
<p>See <a href="architecture/../../CLAUDE.html">CLAUDE.md</a> for comprehensive architectural documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-details-3"><a class="header" href="#architecture-details-3">Architecture Details</a></h1>
<p>For complete architectural documentation, see <a href="architecture/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>This chapter covers internal implementation details. Key topics:</p>
<ul>
<li>Type system design and constraints</li>
<li>Function intelligence registry</li>
<li>Memory layout optimization (32-byte expressions)</li>
<li>Thread safety guarantees</li>
</ul>
<p>See <a href="architecture/../../CLAUDE.html">CLAUDE.md</a> for comprehensive architectural documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-2"><a class="header" href="#api-reference-2">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-3"><a class="header" href="#api-reference-3">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-4"><a class="header" href="#api-reference-4">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-5"><a class="header" href="#api-reference-5">API Reference</a></h1>
<p>For complete API documentation, please visit:</p>
<p><a href="https://docs.rs/mathhook-core">https://docs.rs/mathhook-core</a></p>
<p>This mdBook documentation focuses on conceptual guides and tutorials. The full API reference
is available on docs.rs with detailed documentation for every function, type, and module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-api-guide"><a class="header" href="#python-api-guide">Python API Guide</a></h1>
<p>Complete guide to using MathHook from Python via PyO3 bindings.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-bash">pip install mathhook
</code></pre>
<p><strong>Requirements</strong>:</p>
<ul>
<li>Python 3.8 or higher</li>
<li>pip 20.0 or higher (for binary wheel support)</li>
</ul>
<p><strong>Platform Support</strong>:</p>
<ul>
<li>Linux (x86_64, aarch64)</li>
<li>macOS (Intel, Apple Silicon)</li>
<li>Windows (x86_64)</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-python">from mathhook import Symbol, parse, simplify

# Create symbols
x = Symbol('x')
y = Symbol('y')

# Build expressions
expr = x**2 + 2*x + 1

# Simplify
simplified = simplify(expr)
print(simplified)  # (x + 1)^2
</code></pre>
<h2 id="why-mathhook-for-python"><a class="header" href="#why-mathhook-for-python">Why MathHook for Python?</a></h2>
<h3 id="performance-comparison"><a class="header" href="#performance-comparison">Performance Comparison</a></h3>
<p><strong>100x Faster Than SymPy</strong> for large expressions:</p>
<pre><code class="language-python">import time
from mathhook import parse, simplify
# import sympy  # For comparison

# Large polynomial expression
expr_str = " + ".join([f"{i}*x**{i}" for i in range(100)])

# MathHook
start = time.time()
expr = parse(expr_str)
result = simplify(expr)
mathhook_time = time.time() - start

# SymPy (for comparison)
# start = time.time()
# expr_sympy = sympy.sympify(expr_str)
# result_sympy = sympy.simplify(expr_sympy)
# sympy_time = time.time() - start

print(f"MathHook: {mathhook_time:.4f}s")
# Typical: MathHook 0.001s vs SymPy 0.1s (100x faster)
</code></pre>
<h3 id="when-to-use-mathhook-vs-sympy"><a class="header" href="#when-to-use-mathhook-vs-sympy">When to Use MathHook vs SymPy</a></h3>
<p><strong>Use MathHook when</strong>:</p>
<ul>
<li>Performance is critical (real-time applications, large expressions)</li>
<li>You need symbolic preprocessing for numerical simulations</li>
<li>Working with expressions with &gt;50 terms</li>
<li>Building interactive applications (web, Jupyter with fast response)</li>
</ul>
<p><strong>Use SymPy when</strong>:</p>
<ul>
<li>Need advanced features: logic, sets, abstract algebra</li>
<li>Educational prototyping (rich ecosystem)</li>
<li>Assumption system is critical</li>
<li>Working with small expressions where speed doesn't matter</li>
</ul>
<p><strong>Use Both</strong>:</p>
<ul>
<li>Prototype with SymPy, optimize with MathHook for production</li>
<li>Use MathHook for hot loops, SymPy for one-time complex operations</li>
</ul>
<hr />
<h2 id="api-reference-6"><a class="header" href="#api-reference-6">API Reference</a></h2>
<h3 id="symbols-1"><a class="header" href="#symbols-1">Symbols</a></h3>
<p>Create mathematical variables:</p>
<pre><code class="language-python">from mathhook import Symbol

x = Symbol('x')
y = Symbol('y')
theta = Symbol('theta')
</code></pre>
<p><strong>Equality</strong>:</p>
<pre><code class="language-python">x1 = Symbol('x')
x2 = Symbol('x')
assert x1 == x2  # Same symbol name = equal
</code></pre>
<h3 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h3>
<h4 id="creating-expressions-1"><a class="header" href="#creating-expressions-1">Creating Expressions</a></h4>
<p><strong>Method 1: Operator Overloading</strong> (Pythonic, recommended)</p>
<pre><code class="language-python">from mathhook import Symbol

x = Symbol('x')

# Arithmetic operators
expr = x**2 + 2*x + 1
expr = (x + 1) * (x - 1)
expr = x / (x + 1)
expr = -x

# Supported operators: +, -, *, /, **, -unary
</code></pre>
<p><strong>Method 2: Builder Methods</strong></p>
<pre><code class="language-python">from mathhook import Symbol, Expression

x = Symbol('x')

# Explicit construction
expr = Expression.add(x.pow(2), Expression.mul(2, x), 1)
expr = Expression.sub(x, 1)
expr = Expression.div(x, x.add(1))
</code></pre>
<p><strong>Method 3: Parsing</strong> (from LaTeX or standard notation)</p>
<pre><code class="language-python">from mathhook import parse

expr = parse("x^2 + 2*x + 1")
expr = parse(r"\frac{x^2 + 1}{x - 1}")  # LaTeX
expr = parse("sin(x) + cos(x)")
</code></pre>
<h4 id="expression-operations"><a class="header" href="#expression-operations">Expression Operations</a></h4>
<p><strong>Simplification</strong>:</p>
<pre><code class="language-python">from mathhook import simplify

expr = parse("x + x")
result = simplify(expr)  # 2*x

expr = parse("(x + 1) * (x - 1)")
result = simplify(expr)  # x^2 - 1
</code></pre>
<p><strong>Expansion</strong>:</p>
<pre><code class="language-python">from mathhook import expand

expr = parse("(x + 1)^2")
result = expand(expr)  # x^2 + 2*x + 1
</code></pre>
<p><strong>Factorization</strong>:</p>
<pre><code class="language-python">from mathhook import factor

expr = parse("x^2 - 1")
result = factor(expr)  # (x - 1) * (x + 1)
</code></pre>
<p><strong>Substitution</strong>:</p>
<pre><code class="language-python">x = Symbol('x')
expr = x**2 + 2*x + 1

# Substitute x = 3
result = expr.substitute(x, 3)
print(result)  # 16

# Substitute with another expression
y = Symbol('y')
result = expr.substitute(x, y + 1)
print(result)  # (y + 1)^2 + 2*(y + 1) + 1
</code></pre>
<h3 id="calculus-operations-1"><a class="header" href="#calculus-operations-1">Calculus Operations</a></h3>
<h4 id="derivatives"><a class="header" href="#derivatives">Derivatives</a></h4>
<pre><code class="language-python">from mathhook import Symbol, derivative

x = Symbol('x')
expr = x**3

# First derivative
df = derivative(expr, x)
print(df)  # 3*x^2

# Second derivative
d2f = derivative(expr, x, order=2)
print(d2f)  # 6*x

# Partial derivatives
x, y = Symbol('x'), Symbol('y')
expr = x**2 * y
df_dx = derivative(expr, x)  # 2*x*y
df_dy = derivative(expr, y)  # x^2
</code></pre>
<h4 id="integration"><a class="header" href="#integration">Integration</a></h4>
<pre><code class="language-python">from mathhook import Symbol, integrate

x = Symbol('x')

# Indefinite integral
expr = x**2
integral = integrate(expr, x)
print(integral)  # x^3 / 3 + C

# Definite integral
integral = integrate(expr, x, lower=0, upper=2)
print(integral)  # 8/3
</code></pre>
<h4 id="limits"><a class="header" href="#limits">Limits</a></h4>
<pre><code class="language-python">from mathhook import Symbol, limit

x = Symbol('x')

# Limit as x -&gt; 0
expr = parse("sin(x) / x")
result = limit(expr, x, 0)
print(result)  # 1

# One-sided limits
result = limit(expr, x, 0, direction='+')  # Right limit
result = limit(expr, x, 0, direction='-')  # Left limit
</code></pre>
<h3 id="equation-solving-1"><a class="header" href="#equation-solving-1">Equation Solving</a></h3>
<h4 id="algebraic-equations"><a class="header" href="#algebraic-equations">Algebraic Equations</a></h4>
<pre><code class="language-python">from mathhook import Symbol, solve

x = Symbol('x')

# Linear equation: 2*x + 3 = 7
solutions = solve(2*x + 3, 7, x)
print(solutions)  # [x = 2]

# Quadratic equation: x^2 - 5*x + 6 = 0
solutions = solve(x**2 - 5*x + 6, 0, x)
print(solutions)  # [x = 2, x = 3]

# Multiple variables
x, y = Symbol('x'), Symbol('y')
solutions = solve([x + y - 5, x - y - 1], [x, y])
print(solutions)  # {x: 3, y: 2}
</code></pre>
<h3 id="matrix-operations-3"><a class="header" href="#matrix-operations-3">Matrix Operations</a></h3>
<pre><code class="language-python">from mathhook import Matrix, Symbol

x = Symbol('x')

# Create matrix
A = Matrix([
    [1, 2],
    [3, 4]
])

# Matrix operations
det = A.determinant()  # -2
inv = A.inverse()
transpose = A.transpose()

# Symbolic matrices
B = Matrix([
    [x, 1],
    [0, x]
])
det_B = B.determinant()  # x^2
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<h4 id="elementary-functions"><a class="header" href="#elementary-functions">Elementary Functions</a></h4>
<pre><code class="language-python">from mathhook import sin, cos, tan, exp, log, sqrt

x = Symbol('x')

# Trigonometric
expr = sin(x)**2 + cos(x)**2
result = simplify(expr)  # 1

# Exponential and logarithmic
expr = exp(log(x))
result = simplify(expr)  # x

# Square root
expr = sqrt(x**2)
result = simplify(expr)  # |x| (with assumption handling)
</code></pre>
<h4 id="special-functions"><a class="header" href="#special-functions">Special Functions</a></h4>
<pre><code class="language-python">from mathhook import gamma, factorial, erf, bessel_j

x = Symbol('x')

# Gamma function
expr = gamma(x + 1) / gamma(x)
result = simplify(expr)  # x

# Factorial
expr = factorial(5)
result = simplify(expr)  # 120

# Error function
expr = erf(0)  # 0

# Bessel function
expr = bessel_j(0, x)
</code></pre>
<h3 id="constants-1"><a class="header" href="#constants-1">Constants</a></h3>
<pre><code class="language-python">from mathhook import pi, e, I, oo

# Mathematical constants
expr = parse("sin(pi)")
result = simplify(expr)  # 0 (exact)

expr = exp(I * pi)
result = simplify(expr)  # -1 (Euler's identity)

# Infinity
expr = limit(1/x, x, 0, direction='+')  # oo (infinity)
</code></pre>
<hr />
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="latex-input-and-output"><a class="header" href="#latex-input-and-output">LaTeX Input and Output</a></h3>
<pre><code class="language-python">from mathhook import parse, to_latex

# Parse LaTeX
expr = parse(r"\frac{x^2 + 1}{x - 1}")

# Convert to LaTeX
latex_str = to_latex(expr)
print(latex_str)  # \frac{x^{2} + 1}{x - 1}
</code></pre>
<h3 id="step-by-step-explanations-2"><a class="header" href="#step-by-step-explanations-2">Step-by-Step Explanations</a></h3>
<pre><code class="language-python">from mathhook import Symbol, explain_steps

x = Symbol('x')
expr = (x + 1)**2

# Get step-by-step expansion
steps = explain_steps(expr, operation='expand')

for step in steps:
    print(f"{step['title']}: {step['expression']}")
    print(f"  Explanation: {step['description']}")

# Output:
# Step 1: Original expression: (x + 1)^2
# Step 2: Apply power rule: (x + 1) * (x + 1)
# Step 3: Multiply: x^2 + x + x + 1
# Step 4: Combine like terms: x^2 + 2*x + 1
</code></pre>
<h3 id="assumptions-system"><a class="header" href="#assumptions-system">Assumptions System</a></h3>
<pre><code class="language-python">from mathhook import Symbol

# Symbol with assumptions
x = Symbol('x', positive=True)
y = Symbol('y', real=True, nonzero=True)

expr = sqrt(x**2)
result = simplify(expr)  # x (not |x|, because x &gt; 0)

# Query assumptions
print(x.is_positive)  # True
print(x.is_real)  # True (implied by positive)
</code></pre>
<h3 id="performance-configuration"><a class="header" href="#performance-configuration">Performance Configuration</a></h3>
<pre><code class="language-python">from mathhook import set_config

# Configure for Python context
set_config({
    'parallel': True,          # Enable parallel processing
    'simd': True,              # Enable SIMD operations
    'cache_size': 10000,       # Expression cache size
    'simplify_auto': False,    # Don't auto-simplify
})
</code></pre>
<hr />
<h2 id="integration-with-numpy"><a class="header" href="#integration-with-numpy">Integration with NumPy</a></h2>
<pre><code class="language-python">import numpy as np
from mathhook import Symbol, lambdify

x = Symbol('x')
expr = x**2 + 2*x + 1

# Convert to NumPy-compatible function
f = lambdify(expr, [x], 'numpy')

# Evaluate on NumPy array
x_values = np.linspace(-5, 5, 100)
y_values = f(x_values)

# Use with NumPy operations
mean = np.mean(y_values)
std = np.std(y_values)
</code></pre>
<hr />
<h2 id="integration-with-matplotlib"><a class="header" href="#integration-with-matplotlib">Integration with Matplotlib</a></h2>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
from mathhook import Symbol, lambdify, derivative

x = Symbol('x')
expr = x**3 - 3*x**2 + 2

# Convert expression and derivative to NumPy functions
f = lambdify(expr, [x], 'numpy')
df = lambdify(derivative(expr, x), [x], 'numpy')

# Plot
x_values = np.linspace(-2, 4, 200)
plt.plot(x_values, f(x_values), label='f(x)')
plt.plot(x_values, df(x_values), label="f'(x)")
plt.legend()
plt.grid()
plt.show()
</code></pre>
<hr />
<h2 id="performance-best-practices"><a class="header" href="#performance-best-practices">Performance Best Practices</a></h2>
<h3 id="1-reuse-symbols"><a class="header" href="#1-reuse-symbols">1. Reuse Symbols</a></h3>
<pre><code class="language-python"># GOOD: Create symbol once
x = Symbol('x')
for i in range(1000):
    expr = x**2 + i*x

# BAD: Create symbol repeatedly
for i in range(1000):
    x = Symbol('x')  # Unnecessary interning overhead
    expr = x**2 + i*x
</code></pre>
<h3 id="2-use-operator-overloading"><a class="header" href="#2-use-operator-overloading">2. Use Operator Overloading</a></h3>
<pre><code class="language-python"># GOOD: Pythonic operators (optimized path)
expr = x**2 + 2*x + 1

# LESS GOOD: Explicit construction (more overhead)
expr = Expression.add(
    x.pow(2),
    Expression.mul(2, x),
    1
)
</code></pre>
<h3 id="3-simplify-strategically"><a class="header" href="#3-simplify-strategically">3. Simplify Strategically</a></h3>
<pre><code class="language-python"># GOOD: Simplify only when needed
expr = build_complex_expression()
# ... do many operations ...
final = simplify(expr)  # Simplify once at end

# BAD: Over-simplification
expr = x + 1
expr = simplify(expr)  # Unnecessary
expr = expr * 2
expr = simplify(expr)  # Unnecessary
</code></pre>
<h3 id="4-use-lambdify-for-numerical-evaluation"><a class="header" href="#4-use-lambdify-for-numerical-evaluation">4. Use Lambdify for Numerical Evaluation</a></h3>
<pre><code class="language-python"># GOOD: Compile to NumPy function for repeated evaluation
f = lambdify(expr, [x], 'numpy')
results = [f(i) for i in range(1000000)]  # Fast

# BAD: Substitute repeatedly
results = [expr.substitute(x, i) for i in range(1000000)]  # Slow
</code></pre>
<hr />
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<h3 id="pitfall-1-integer-division"><a class="header" href="#pitfall-1-integer-division">Pitfall 1: Integer Division</a></h3>
<pre><code class="language-python"># WRONG: Python 3 division
x = Symbol('x')
expr = x / 2  # Creates symbolic x / 2 (correct)

# WRONG: Integer division in coefficient
expr = x * (1 / 3)  # 0.333... (float approximation)

# CORRECT: Use rational
from mathhook import Rational
expr = x * Rational(1, 3)  # Exact 1/3
</code></pre>
<h3 id="pitfall-2-mutability-expectation"><a class="header" href="#pitfall-2-mutability-expectation">Pitfall 2: Mutability Expectation</a></h3>
<pre><code class="language-python"># WRONG: Expressions are immutable
expr = x**2
expr.simplify()  # Returns new expression, doesn't modify expr
print(expr)  # Still x**2

# CORRECT
expr = x**2
expr = simplify(expr)  # Assign result
print(expr)  # Simplified
</code></pre>
<hr />
<h2 id="api-compatibility"><a class="header" href="#api-compatibility">API Compatibility</a></h2>
<h3 id="sympy-migration"><a class="header" href="#sympy-migration">SymPy Migration</a></h3>
<!-- See [SymPy Migration Guide](../appendix/sympy-migration.md) for detailed comparison. -->
<p><strong>Quick Reference</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>SymPy</th><th>MathHook</th></tr></thead><tbody>
<tr><td><code>Symbol('x')</code></td><td><code>Symbol('x')</code></td></tr>
<tr><td><code>sympify('x**2')</code></td><td><code>parse('x^2')</code></td></tr>
<tr><td><code>simplify(expr)</code></td><td><code>simplify(expr)</code></td></tr>
<tr><td><code>expand(expr)</code></td><td><code>expand(expr)</code></td></tr>
<tr><td><code>factor(expr)</code></td><td><code>factor(expr)</code></td></tr>
<tr><td><code>diff(expr, x)</code></td><td><code>derivative(expr, x)</code></td></tr>
<tr><td><code>integrate(expr, x)</code></td><td><code>integrate(expr, x)</code></td></tr>
<tr><td><code>solve(eq, x)</code></td><td><code>solve(eq, 0, x)</code></td></tr>
<tr><td><code>latex(expr)</code></td><td><code>to_latex(expr)</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="bindings/./nodejs.html">Node.js API Guide</a> - JavaScript/TypeScript bindings</li>
</ul>
<!-- - [SymPy Migration Guide](../appendix/sympy-migration.md) - Port existing code -->
<ul>
<li><a href="bindings/../performance/benchmarking.html">Performance Benchmarks</a> - Detailed comparisons</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejstypescript-api-guide"><a class="header" href="#nodejstypescript-api-guide">Node.js/TypeScript API Guide</a></h1>
<p>Complete guide to using MathHook from Node.js and TypeScript via NAPI bindings.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-bash">npm install mathhook
# or
yarn add mathhook
# or
pnpm add mathhook
</code></pre>
<p><strong>Requirements</strong>:</p>
<ul>
<li>Node.js 16.0 or higher</li>
<li>npm 7.0 or higher</li>
</ul>
<p><strong>Platform Support</strong>:</p>
<ul>
<li>Linux (x86_64, aarch64)</li>
<li>macOS (Intel, Apple Silicon)</li>
<li>Windows (x86_64)</li>
</ul>
<p><strong>TypeScript Support</strong>: Type definitions included (.d.ts files bundled)</p>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<h3 id="javascript"><a class="header" href="#javascript">JavaScript</a></h3>
<pre><code class="language-javascript">const { Symbol, parse, simplify } = require('mathhook');

// Create symbols
const x = new Symbol('x');
const y = new Symbol('y');

// Build expressions
const expr = parse('x^2 + 2*x + 1');

// Simplify
const simplified = simplify(expr);
console.log(simplified.toString());  // (x + 1)^2
</code></pre>
<h3 id="typescript"><a class="header" href="#typescript">TypeScript</a></h3>
<pre><code class="language-typescript">import { Symbol, Expression, parse, simplify } from 'mathhook';

// Create symbols (with type safety)
const x: Symbol = new Symbol('x');
const y: Symbol = new Symbol('y');

// Build expressions
const expr: Expression = parse('x^2 + 2*x + 1');

// Simplify
const simplified: Expression = simplify(expr);
console.log(simplified.toString());  // (x + 1)^2
</code></pre>
<h2 id="why-mathhook-for-nodejs"><a class="header" href="#why-mathhook-for-nodejs">Why MathHook for Node.js?</a></h2>
<h3 id="performance-comparison-1"><a class="header" href="#performance-comparison-1">Performance Comparison</a></h3>
<p><strong>Native Performance in JavaScript</strong>:</p>
<ul>
<li>Rust core compiled to native code via NAPI</li>
<li>No V8 overhead for mathematical operations</li>
<li>50-100x faster than pure JavaScript CAS libraries</li>
</ul>
<pre><code class="language-javascript">const { parse, simplify } = require('mathhook');

// Large polynomial expression
const terms = Array.from({length: 100}, (_, i) =&gt; `${i}*x^${i}`);
const exprStr = terms.join(' + ');

// MathHook
const start = Date.now();
const expr = parse(exprStr);
const result = simplify(expr);
const mathhookTime = Date.now() - start;

console.log(`MathHook: ${mathhookTime}ms`);
// Typical: MathHook 1-5ms vs JavaScript CAS 100-500ms
</code></pre>
<h3 id="when-to-use-mathhook"><a class="header" href="#when-to-use-mathhook">When to Use MathHook</a></h3>
<p><strong>Use MathHook when</strong>:</p>
<ul>
<li>Building web applications with symbolic math (calculators, graphing, education)</li>
<li>Server-side computation for math APIs</li>
<li>Real-time symbolic computation requirements</li>
<li>Need LaTeX parsing and rendering</li>
</ul>
<p><strong>Integration Points</strong>:</p>
<ul>
<li>Express/Fastify APIs for math endpoints</li>
<li>Next.js/Nuxt.js server-side rendering</li>
<li>WebSocket servers for interactive math applications</li>
<li>GraphQL resolvers for mathematical queries</li>
</ul>
<hr />
<h2 id="api-reference-7"><a class="header" href="#api-reference-7">API Reference</a></h2>
<h3 id="symbols-2"><a class="header" href="#symbols-2">Symbols</a></h3>
<pre><code class="language-typescript">import { Symbol } from 'mathhook';

const x = new Symbol('x');
const y = new Symbol('y');
const theta = new Symbol('theta');
</code></pre>
<p><strong>Equality</strong>:</p>
<pre><code class="language-typescript">const x1 = new Symbol('x');
const x2 = new Symbol('x');
console.log(x1.equals(x2));  // true (same name)
</code></pre>
<h3 id="expressions-2"><a class="header" href="#expressions-2">Expressions</a></h3>
<h4 id="creating-expressions-2"><a class="header" href="#creating-expressions-2">Creating Expressions</a></h4>
<p><strong>Method 1: Parsing</strong> (Recommended for Node.js)</p>
<pre><code class="language-typescript">import { parse } from 'mathhook';

const expr = parse('x^2 + 2*x + 1');
const expr2 = parse('\\frac{x^2 + 1}{x - 1}');  // LaTeX
const expr3 = parse('sin(x) + cos(x)');
</code></pre>
<p><strong>Method 2: Builder API</strong></p>
<pre><code class="language-typescript">import { Expression, Symbol } from 'mathhook';

const x = new Symbol('x');

// Build expressions programmatically
const expr = Expression.add([
    Expression.pow(x.toExpression(), Expression.integer(2)),
    Expression.mul([Expression.integer(2), x.toExpression()]),
    Expression.integer(1)
]);
</code></pre>
<p><strong>Method 3: From JSON</strong> (for serialization)</p>
<pre><code class="language-typescript">import { Expression } from 'mathhook';

const exprJson = {
    type: 'Add',
    terms: [
        { type: 'Symbol', name: 'x' },
        { type: 'Integer', value: 1 }
    ]
};

const expr = Expression.fromJSON(exprJson);
</code></pre>
<h4 id="expression-operations-1"><a class="header" href="#expression-operations-1">Expression Operations</a></h4>
<p><strong>Simplification</strong>:</p>
<pre><code class="language-typescript">import { parse, simplify } from 'mathhook';

const expr = parse('x + x');
const result = simplify(expr);
console.log(result.toString());  // 2*x
</code></pre>
<p><strong>Expansion</strong>:</p>
<pre><code class="language-typescript">import { parse, expand } from 'mathhook';

const expr = parse('(x + 1)^2');
const result = expand(expr);
console.log(result.toString());  // x^2 + 2*x + 1
</code></pre>
<p><strong>Substitution</strong>:</p>
<pre><code class="language-typescript">import { Symbol, parse } from 'mathhook';

const x = new Symbol('x');
const expr = parse('x^2 + 2*x + 1');

// Substitute x = 3
const result = expr.substitute(x, Expression.integer(3));
console.log(result.toString());  // 16
</code></pre>
<h3 id="calculus-operations-2"><a class="header" href="#calculus-operations-2">Calculus Operations</a></h3>
<h4 id="derivatives-1"><a class="header" href="#derivatives-1">Derivatives</a></h4>
<pre><code class="language-typescript">import { Symbol, parse, derivative } from 'mathhook';

const x = new Symbol('x');
const expr = parse('x^3');

// First derivative
const df = derivative(expr, x);
console.log(df.toString());  // 3*x^2

// Second derivative
const d2f = derivative(expr, x, { order: 2 });
console.log(d2f.toString());  // 6*x
</code></pre>
<h4 id="integration-1"><a class="header" href="#integration-1">Integration</a></h4>
<pre><code class="language-typescript">import { Symbol, parse, integrate } from 'mathhook';

const x = new Symbol('x');
const expr = parse('x^2');

// Indefinite integral
const integral = integrate(expr, x);
console.log(integral.toString());  // x^3 / 3 + C

// Definite integral
const definite = integrate(expr, x, { lower: 0, upper: 2 });
console.log(definite.toString());  // 8/3
</code></pre>
<h3 id="equation-solving-2"><a class="header" href="#equation-solving-2">Equation Solving</a></h3>
<pre><code class="language-typescript">import { Symbol, parse, solve } from 'mathhook';

const x = new Symbol('x');

// Quadratic equation: x^2 - 5*x + 6 = 0
const expr = parse('x^2 - 5*x + 6');
const solutions = solve(expr, x);

solutions.forEach(sol =&gt; {
    console.log(sol.toString());
});
// Output: x = 2, x = 3
</code></pre>
<h3 id="latex-support"><a class="header" href="#latex-support">LaTeX Support</a></h3>
<pre><code class="language-typescript">import { parse, toLatex } from 'mathhook';

// Parse LaTeX
const expr = parse('\\frac{x^2 + 1}{x - 1}');

// Convert to LaTeX
const latex = toLatex(expr);
console.log(latex);  // \frac{x^{2} + 1}{x - 1}
</code></pre>
<hr />
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="expressjs-api"><a class="header" href="#expressjs-api">Express.js API</a></h3>
<pre><code class="language-typescript">import express from 'express';
import { parse, simplify, toLatex } from 'mathhook';

const app = express();
app.use(express.json());

// Simplify endpoint
app.post('/api/simplify', (req, res) =&gt; {
    try {
        const { expression } = req.body;
        const expr = parse(expression);
        const simplified = simplify(expr);

        res.json({
            original: expression,
            simplified: simplified.toString(),
            latex: toLatex(simplified)
        });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Derivative endpoint
app.post('/api/derivative', (req, res) =&gt; {
    try {
        const { expression, variable } = req.body;
        const expr = parse(expression);
        const x = new Symbol(variable);
        const deriv = derivative(expr, x);

        res.json({
            expression: expression,
            derivative: deriv.toString(),
            latex: toLatex(deriv)
        });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.listen(3000, () =&gt; {
    console.log('Math API running on port 3000');
});
</code></pre>
<h3 id="nextjs-server-actions"><a class="header" href="#nextjs-server-actions">Next.js Server Actions</a></h3>
<pre><code class="language-typescript">// app/actions/math.ts
'use server';

import { parse, simplify, derivative } from 'mathhook';

export async function simplifyExpression(expression: string) {
    try {
        const expr = parse(expression);
        const simplified = simplify(expr);
        return {
            success: true,
            result: simplified.toString()
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

export async function computeDerivative(expression: string, variable: string) {
    try {
        const expr = parse(expression);
        const x = new Symbol(variable);
        const deriv = derivative(expr, x);
        return {
            success: true,
            result: deriv.toString()
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}
</code></pre>
<h3 id="react-component-example"><a class="header" href="#react-component-example">React Component Example</a></h3>
<pre><code class="language-typescript">// components/Calculator.tsx
'use client';

import { useState } from 'react';
import { simplifyExpression } from '@/app/actions/math';

export default function Calculator() {
    const [input, setInput] = useState('');
    const [result, setResult] = useState('');

    const handleSimplify = async () =&gt; {
        const response = await simplifyExpression(input);
        if (response.success) {
            setResult(response.result);
        } else {
            setResult(`Error: ${response.error}`);
        }
    };

    return (
        &lt;div&gt;
            &lt;input
                value={input}
                onChange={(e) =&gt; setInput(e.target.value)}
                placeholder="Enter expression (e.g., x^2 + 2*x + 1)"
            /&gt;
            &lt;button onClick={handleSimplify}&gt;Simplify&lt;/button&gt;
            {result &amp;&amp; &lt;div&gt;Result: {result}&lt;/div&gt;}
        &lt;/div&gt;
    );
}
</code></pre>
<h3 id="websocket-server"><a class="header" href="#websocket-server">WebSocket Server</a></h3>
<pre><code class="language-typescript">import { WebSocketServer } from 'ws';
import { parse, simplify, derivative } from 'mathhook';

const wss = new WebSocketServer({ port: 8080 });

wss.on('connection', (ws) =&gt; {
    ws.on('message', (data) =&gt; {
        try {
            const request = JSON.parse(data.toString());

            switch (request.operation) {
                case 'simplify': {
                    const expr = parse(request.expression);
                    const result = simplify(expr);
                    ws.send(JSON.stringify({
                        operation: 'simplify',
                        result: result.toString()
                    }));
                    break;
                }
                case 'derivative': {
                    const expr = parse(request.expression);
                    const x = new Symbol(request.variable);
                    const result = derivative(expr, x);
                    ws.send(JSON.stringify({
                        operation: 'derivative',
                        result: result.toString()
                    }));
                    break;
                }
            }
        } catch (error) {
            ws.send(JSON.stringify({ error: error.message }));
        }
    });
});
</code></pre>
<hr />
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="async-operations"><a class="header" href="#async-operations">Async Operations</a></h3>
<p>For long-running operations, use Worker Threads:</p>
<pre><code class="language-typescript">import { Worker } from 'worker_threads';

// math-worker.ts
import { parentPort } from 'worker_threads';
import { parse, simplify } from 'mathhook';

parentPort?.on('message', (expression) =&gt; {
    try {
        const expr = parse(expression);
        const result = simplify(expr);
        parentPort?.postMessage({ success: true, result: result.toString() });
    } catch (error) {
        parentPort?.postMessage({ success: false, error: error.message });
    }
});

// main.ts
function simplifyAsync(expression: string): Promise&lt;string&gt; {
    return new Promise((resolve, reject) =&gt; {
        const worker = new Worker('./math-worker.ts');
        worker.on('message', (result) =&gt; {
            if (result.success) {
                resolve(result.result);
            } else {
                reject(new Error(result.error));
            }
            worker.terminate();
        });
        worker.postMessage(expression);
    });
}
</code></pre>
<h3 id="caching-results-1"><a class="header" href="#caching-results-1">Caching Results</a></h3>
<pre><code class="language-typescript">import { parse, simplify } from 'mathhook';
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 600 }); // 10 minutes

function simplifyWithCache(expression: string): string {
    const cached = cache.get&lt;string&gt;(expression);
    if (cached) {
        return cached;
    }

    const expr = parse(expression);
    const result = simplify(expr).toString();
    cache.set(expression, result);
    return result;
}
</code></pre>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<pre><code class="language-typescript">import { parse, MathError, DomainError } from 'mathhook';

try {
    const expr = parse('1/0');
    const evaluated = expr.evaluate();
} catch (error) {
    if (error instanceof DomainError) {
        console.error('Domain error:', error.message);
    } else if (error instanceof MathError) {
        console.error('Math error:', error.message);
    } else {
        console.error('Unknown error:', error);
    }
}
</code></pre>
<hr />
<h2 id="performance-best-practices-1"><a class="header" href="#performance-best-practices-1">Performance Best Practices</a></h2>
<h3 id="1-parse-once-use-many-times"><a class="header" href="#1-parse-once-use-many-times">1. Parse Once, Use Many Times</a></h3>
<pre><code class="language-typescript">// GOOD: Parse once
const expr = parse('x^2 + 2*x + 1');
for (let i = 0; i &lt; 1000; i++) {
    const result = expr.substitute(x, Expression.integer(i));
}

// BAD: Parse repeatedly
for (let i = 0; i &lt; 1000; i++) {
    const expr = parse('x^2 + 2*x + 1');  // Wasteful!
    const result = expr.substitute(x, Expression.integer(i));
}
</code></pre>
<h3 id="2-use-caching-for-repeated-operations"><a class="header" href="#2-use-caching-for-repeated-operations">2. Use Caching for Repeated Operations</a></h3>
<pre><code class="language-typescript">const cache = new Map&lt;string, Expression&gt;();

function getCachedParse(expr: string): Expression {
    if (!cache.has(expr)) {
        cache.set(expr, parse(expr));
    }
    return cache.get(expr)!;
}
</code></pre>
<h3 id="3-batch-operations-when-possible"><a class="header" href="#3-batch-operations-when-possible">3. Batch Operations When Possible</a></h3>
<pre><code class="language-typescript">// GOOD: Batch process
const expressions = ['x^2', 'x + 1', '2*x'];
const results = expressions.map(e =&gt; simplify(parse(e)));

// Also consider parallel processing with Worker Threads for large batches
</code></pre>
<h3 id="4-v8-optimization-tips"><a class="header" href="#4-v8-optimization-tips">4. V8 Optimization Tips</a></h3>
<pre><code class="language-typescript">// Use consistent object shapes for V8 optimization
interface MathRequest {
    expression: string;
    operation: 'simplify' | 'derivative' | 'integrate';
    variable?: string;
}

function processMathRequest(req: MathRequest): string {
    // V8 can optimize this better with consistent types
    const expr = parse(req.expression);
    switch (req.operation) {
        case 'simplify':
            return simplify(expr).toString();
        case 'derivative':
            return derivative(expr, new Symbol(req.variable!)).toString();
        case 'integrate':
            return integrate(expr, new Symbol(req.variable!)).toString();
    }
}
</code></pre>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="jest-example"><a class="header" href="#jest-example">Jest Example</a></h3>
<pre><code class="language-typescript">import { parse, simplify, derivative } from 'mathhook';

describe('MathHook Integration', () =&gt; {
    test('simplifies expression', () =&gt; {
        const expr = parse('x + x');
        const result = simplify(expr);
        expect(result.toString()).toBe('2*x');
    });

    test('computes derivative', () =&gt; {
        const expr = parse('x^2');
        const x = new Symbol('x');
        const deriv = derivative(expr, x);
        expect(deriv.toString()).toBe('2*x');
    });

    test('handles errors gracefully', () =&gt; {
        expect(() =&gt; parse('invalid syntax +')).toThrow();
    });
});
</code></pre>
<hr />
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<p>Full TypeScript type definitions:</p>
<pre><code class="language-typescript">declare module 'mathhook' {
    export class Symbol {
        constructor(name: string);
        name(): string;
        equals(other: Symbol): boolean;
        toExpression(): Expression;
    }

    export class Expression {
        static integer(value: number): Expression;
        static rational(num: number, den: number): Expression;
        static float(value: number): Expression;
        static symbol(symbol: Symbol): Expression;
        static add(terms: Expression[]): Expression;
        static mul(factors: Expression[]): Expression;
        static pow(base: Expression, exp: Expression): Expression;
        static fromJSON(json: object): Expression;

        toString(): string;
        toJSON(): object;
        substitute(symbol: Symbol, value: Expression): Expression;
        evaluate(): number;
        equals(other: Expression): boolean;
    }

    export function parse(input: string): Expression;
    export function simplify(expr: Expression): Expression;
    export function expand(expr: Expression): Expression;
    export function factor(expr: Expression): Expression;
    export function derivative(expr: Expression, variable: Symbol, options?: { order?: number }): Expression;
    export function integrate(expr: Expression, variable: Symbol, options?: { lower?: number, upper?: number }): Expression;
    export function solve(expr: Expression, variable: Symbol): Expression[];
    export function toLatex(expr: Expression): string;
    export function toWolfram(expr: Expression): string;

    export class MathError extends Error {}
    export class DomainError extends MathError {}
    export class ParseError extends MathError {}
}
</code></pre>
<hr />
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="rest-api-math-service"><a class="header" href="#rest-api-math-service">REST API Math Service</a></h3>
<p>Complete example of a production-ready math API:</p>
<pre><code class="language-typescript">import express from 'express';
import { parse, simplify, derivative, integrate, solve, toLatex } from 'mathhook';
import { body, validationResult } from 'express-validator';

const app = express();
app.use(express.json());

// Validation middleware
const validateExpression = [
    body('expression').isString().notEmpty(),
    body('variable').optional().isString(),
];

// Simplify endpoint
app.post('/api/simplify',
    validateExpression,
    (req, res) =&gt; {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        try {
            const expr = parse(req.body.expression);
            const simplified = simplify(expr);

            res.json({
                original: req.body.expression,
                simplified: simplified.toString(),
                latex: toLatex(simplified)
            });
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }
);

// Rate limiting example
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});

app.use('/api/', limiter);

app.listen(3000);
</code></pre>
<hr />
<h2 id="migration-from-javascript-cas-libraries"><a class="header" href="#migration-from-javascript-cas-libraries">Migration from JavaScript CAS Libraries</a></h2>
<h3 id="from-mathjs"><a class="header" href="#from-mathjs">From Math.js</a></h3>
<pre><code class="language-javascript">// Math.js
const math = require('mathjs');
const expr = math.parse('x^2 + 2*x + 1');
const simplified = math.simplify(expr);

// MathHook
const { parse, simplify } = require('mathhook');
const expr = parse('x^2 + 2*x + 1');
const simplified = simplify(expr);
</code></pre>
<h3 id="from-algebrite"><a class="header" href="#from-algebrite">From Algebrite</a></h3>
<pre><code class="language-javascript">// Algebrite
const Algebrite = require('algebrite');
const result = Algebrite.simplify('x + x').toString();

// MathHook
const { parse, simplify } = require('mathhook');
const result = simplify(parse('x + x')).toString();
</code></pre>
<hr />
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="bindings/./python.html">Python API Guide</a> - Python bindings</li>
<li><a href="bindings/../parser/latex.html">LaTeX Parsing Guide</a> - Advanced LaTeX support</li>
<li><a href="bindings/../performance/benchmarking.html">Performance Benchmarks</a> - Detailed comparisons</li>
<li><a href="https://github.com/ahmedmashhour/mathhook-examples">Web Integration Examples</a> - Production examples</li>
</ul>
<hr />
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ul>
<li><strong>Documentation</strong>: <a href="https://mathhook.readthedocs.io">https://mathhook.readthedocs.io</a></li>
<li><strong>GitHub Issues</strong>: Report bugs and request features</li>
<li><strong>npm Package</strong>: <a href="https://www.npmjs.com/package/mathhook">https://www.npmjs.com/package/mathhook</a></li>
<li><strong>Discord</strong>: Join our community for support</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-bindings"><a class="header" href="#language-bindings">Language Bindings</a></h1>
<p>Language-specific documentation is under development.</p>
<p>For now, please refer to:</p>
<ul>
<li>Python: <a href="bindings/../../crates/mathhook-python/README.html">mathhook-python README</a></li>
<li>Node.js: <a href="bindings/../../crates/mathhook-node/README.html">mathhook-node README</a></li>
<li><a href="https://pypi.org/project/mathhook/">PyPI</a> for Python package</li>
<li><a href="https://www.npmjs.com/package/mathhook-node">npm</a> for Node.js package</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-guide"><a class="header" href="#development-guide">Development Guide</a></h1>
<p>For complete development documentation, please see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<h3 id="clone-the-repository-1"><a class="header" href="#clone-the-repository-1">Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/ahmedmashhour/mathhook.git
cd mathhook
</code></pre>
<h3 id="build-the-project"><a class="header" href="#build-the-project">Build the Project</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="run-tests-1"><a class="header" href="#run-tests-1">Run Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="run-benchmarks"><a class="header" href="#run-benchmarks">Run Benchmarks</a></h3>
<pre><code class="language-bash">cargo bench
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>mathhook/
├── crates/
│   ├── mathhook-core/      # Core mathematical engine
│   ├── mathhook/           # High-level API
│   ├── mathhook-python/    # Python bindings
│   ├── mathhook-node/      # Node.js bindings
│   └── mathhook-benchmarks/# Benchmarks
└── docs/                   # This documentation
</code></pre>
<p>For detailed architectural documentation, see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guidelines"><a class="header" href="#contributing-guidelines">Contributing Guidelines</a></h1>
<p>For complete contributing guidelines, please see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>Key points:</p>
<ol>
<li><strong>Mathematical Correctness First</strong> - Every operation must be correct</li>
<li><strong>No Regressions</strong> - All tests must pass</li>
<li><strong>Documentation Required</strong> - All public APIs need docs</li>
<li><strong>Follow Style Guide</strong> - Run <code>cargo fmt</code> and <code>cargo clippy</code></li>
<li><strong>Test Coverage</strong> - Add tests for new features</li>
</ol>
<p>See <a href="contributing/../../CLAUDE.html">CLAUDE.md</a> for comprehensive guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guidelines-1"><a class="header" href="#contributing-guidelines-1">Contributing Guidelines</a></h1>
<p>For complete contributing guidelines, please see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>Key points:</p>
<ol>
<li><strong>Mathematical Correctness First</strong> - Every operation must be correct</li>
<li><strong>No Regressions</strong> - All tests must pass</li>
<li><strong>Documentation Required</strong> - All public APIs need docs</li>
<li><strong>Follow Style Guide</strong> - Run <code>cargo fmt</code> and <code>cargo clippy</code></li>
<li><strong>Test Coverage</strong> - Add tests for new features</li>
</ol>
<p>See <a href="contributing/../../CLAUDE.html">CLAUDE.md</a> for comprehensive guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guidelines-2"><a class="header" href="#contributing-guidelines-2">Contributing Guidelines</a></h1>
<p>For complete contributing guidelines, please see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>Key points:</p>
<ol>
<li><strong>Mathematical Correctness First</strong> - Every operation must be correct</li>
<li><strong>No Regressions</strong> - All tests must pass</li>
<li><strong>Documentation Required</strong> - All public APIs need docs</li>
<li><strong>Follow Style Guide</strong> - Run <code>cargo fmt</code> and <code>cargo clippy</code></li>
<li><strong>Test Coverage</strong> - Add tests for new features</li>
</ol>
<p>See <a href="contributing/../../CLAUDE.html">CLAUDE.md</a> for comprehensive guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guidelines-3"><a class="header" href="#contributing-guidelines-3">Contributing Guidelines</a></h1>
<p>For complete contributing guidelines, please see <a href="contributing/../../CLAUDE.html">CLAUDE.md</a>.</p>
<p>Key points:</p>
<ol>
<li><strong>Mathematical Correctness First</strong> - Every operation must be correct</li>
<li><strong>No Regressions</strong> - All tests must pass</li>
<li><strong>Documentation Required</strong> - All public APIs need docs</li>
<li><strong>Follow Style Guide</strong> - Run <code>cargo fmt</code> and <code>cargo clippy</code></li>
<li><strong>Test Coverage</strong> - Add tests for new features</li>
</ol>
<p>See <a href="contributing/../../CLAUDE.html">CLAUDE.md</a> for comprehensive guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathematical-notation"><a class="header" href="#mathematical-notation">Mathematical Notation</a></h1>
<p>This appendix documents the mathematical notation used throughout MathHook.</p>
<h2 id="latex-support-1"><a class="header" href="#latex-support-1">LaTeX Support</a></h2>
<p>MathHook can parse standard LaTeX mathematical notation:</p>
<ul>
<li><code>\frac{a}{b}</code> - Fractions</li>
<li><code>\sqrt{x}</code> - Square root</li>
<li><code>x^{2}</code> - Exponentiation</li>
<li><code>\sin(x)</code>, <code>\cos(x)</code>, <code>\tan(x)</code> - Trigonometric functions</li>
<li><code>\log(x)</code>, <code>\ln(x)</code> - Logarithms</li>
<li><code>\sum</code>, <code>\prod</code>, <code>\int</code> - Summation, product, integral</li>
<li>Greek letters: <code>\alpha</code>, <code>\beta</code>, <code>\gamma</code>, etc.</li>
</ul>
<h2 id="standard-notation"><a class="header" href="#standard-notation">Standard Notation</a></h2>
<ul>
<li><code>2*x</code> or <code>2x</code> - Multiplication (implicit multiplication supported)</li>
<li><code>x^2</code> - Exponentiation</li>
<li><code>x/y</code> - Division</li>
<li><code>sin(x)</code> - Functions</li>
<li><code>|x|</code> - Absolute value</li>
</ul>
<h2 id="wolfram-language"><a class="header" href="#wolfram-language">Wolfram Language</a></h2>
<p>MathHook also supports Wolfram Language syntax:</p>
<ul>
<li><code>Power[x, 2]</code> - Exponentiation</li>
<li><code>Sin[x]</code> - Functions</li>
<li><code>D[expr, x]</code> - Derivatives</li>
<li><code>Integrate[expr, x]</code> - Integration</li>
</ul>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<ol>
<li>Function application: <code>sin(x)</code>, <code>log(y)</code></li>
<li>Exponentiation: <code>^</code> (right-associative)</li>
<li>Multiplication/Division: <code>*</code>, <code>/</code> (left-associative)</li>
<li>Addition/Subtraction: <code>+</code>, <code>-</code> (left-associative)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h1>
<p>Common error messages and their solutions.</p>
<h2 id="parse-errors"><a class="header" href="#parse-errors">Parse Errors</a></h2>
<h3 id="unexpected-token"><a class="header" href="#unexpected-token">"Unexpected token"</a></h3>
<p><strong>Cause</strong>: Invalid syntax in input expression.</p>
<p><strong>Solution</strong>: Check for typos, missing parentheses, or unsupported syntax.</p>
<h3 id="implicit-multiplication-ambiguity"><a class="header" href="#implicit-multiplication-ambiguity">"Implicit multiplication ambiguity"</a></h3>
<p><strong>Cause</strong>: Parser cannot determine multiplication intent.</p>
<p><strong>Solution</strong>: Add explicit <code>*</code> operator or use parentheses.</p>
<h2 id="domain-errors"><a class="header" href="#domain-errors">Domain Errors</a></h2>
<h3 id="sqrt-of-negative-number"><a class="header" href="#sqrt-of-negative-number">"sqrt of negative number"</a></h3>
<p><strong>Cause</strong>: Attempting to compute square root of negative number in real domain.</p>
<p><strong>Solution</strong>: Use complex domain or ensure argument is non-negative.</p>
<h3 id="division-by-zero"><a class="header" href="#division-by-zero">"Division by zero"</a></h3>
<p><strong>Cause</strong>: Expression evaluates to division by zero.</p>
<p><strong>Solution</strong>: Check for zero denominators before evaluation.</p>
<h3 id="log-of-non-positive-number"><a class="header" href="#log-of-non-positive-number">"log of non-positive number"</a></h3>
<p><strong>Cause</strong>: Logarithm of zero or negative number in real domain.</p>
<p><strong>Solution</strong>: Ensure argument is positive or use complex domain.</p>
<h2 id="solver-errors-1"><a class="header" href="#solver-errors-1">Solver Errors</a></h2>
<h3 id="no-solution-exists"><a class="header" href="#no-solution-exists">"No solution exists"</a></h3>
<p><strong>Cause</strong>: Equation has no solution in the given domain.</p>
<p><strong>Solution</strong>: Check equation for contradictions or domain restrictions.</p>
<h3 id="cannot-solve---equation-too-complex"><a class="header" href="#cannot-solve---equation-too-complex">"Cannot solve - equation too complex"</a></h3>
<p><strong>Cause</strong>: Solver cannot handle this equation type yet.</p>
<p><strong>Solution</strong>: Try simplifying equation or use numerical methods.</p>
<h2 id="for-more-help"><a class="header" href="#for-more-help">For More Help</a></h2>
<ul>
<li><a href="https://github.com/ahmedmashhour/mathhook/issues">GitHub Issues</a></li>
<li><a href="https://docs.rs/mathhook-core">API Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<h3 id="what-is-mathhook-1"><a class="header" href="#what-is-mathhook-1">What is MathHook?</a></h3>
<p>MathHook is a high-performance educational computer algebra system (CAS) written in Rust.</p>
<h3 id="how-does-it-compare-to-sympy"><a class="header" href="#how-does-it-compare-to-sympy">How does it compare to SymPy?</a></h3>
<p>MathHook is 10-100x faster than SymPy for common operations while maintaining mathematical correctness.</p>
<h3 id="what-languages-are-supported"><a class="header" href="#what-languages-are-supported">What languages are supported?</a></h3>
<p>Rust (native), Python, Node.js/TypeScript, and WebAssembly (coming soon).</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="how-do-i-create-expressions"><a class="header" href="#how-do-i-create-expressions">How do I create expressions?</a></h3>
<p>Use the <code>expr!</code> and <code>symbol!</code> macros:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = symbol!(x);
let expr = expr!((x ^ 2) + 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="why-use-rationals-instead-of-floats"><a class="header" href="#why-use-rationals-instead-of-floats">Why use rationals instead of floats?</a></h3>
<p>Rationals provide exact arithmetic without precision loss. Use floats only when approximation is acceptable.</p>
<h3 id="how-do-i-parse-latex"><a class="header" href="#how-do-i-parse-latex">How do I parse LaTeX?</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mathhook_core::parser::{Parser, ParserConfig};

let parser = Parser::new(ParserConfig::default());
let expr = parser.parse(r"\frac{x^2}{2}").unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="how-fast-is-mathhook"><a class="header" href="#how-fast-is-mathhook">How fast is MathHook?</a></h3>
<p>10-100x faster than SymPy, competitive with other native CAS systems.</p>
<h3 id="does-it-support-parallel-processing"><a class="header" href="#does-it-support-parallel-processing">Does it support parallel processing?</a></h3>
<p>Yes, expressions are immutable and thread-safe. Use <code>parallel_bulk_simplify</code> for bulk operations.</p>
<h3 id="what-is-simd"><a class="header" href="#what-is-simd">What is SIMD?</a></h3>
<p>SIMD (Single Instruction Multiple Data) vectorizes arithmetic for 2-4x speedup on large arrays.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<h3 id="how-do-i-contribute"><a class="header" href="#how-do-i-contribute">How do I contribute?</a></h3>
<p>See <a href="appendix/../contributing/development.html">Contributing Guide</a> and <a href="appendix/../../CLAUDE.html">CLAUDE.md</a>.</p>
<h3 id="what-are-the-design-principles"><a class="header" href="#what-are-the-design-principles">What are the design principles?</a></h3>
<ol>
<li>Mathematical correctness first</li>
<li>Performance</li>
<li>Ergonomic API</li>
<li>Educational value</li>
<li>Multi-language support</li>
</ol>
<p>See <a href="appendix/../architecture/principles.html">Design Principles</a> for details.</p>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="parse-errors-1"><a class="header" href="#parse-errors-1">Parse errors?</a></h3>
<p>Check syntax, use explicit <code>*</code> for multiplication, ensure balanced parentheses.</p>
<h3 id="domain-errors-1"><a class="header" href="#domain-errors-1">Domain errors?</a></h3>
<p>Check for sqrt of negatives, log of non-positives, or division by zero.</p>
<h3 id="import-errors"><a class="header" href="#import-errors">Import errors?</a></h3>
<p>Reinstall package: <code>pip install --force-reinstall mathhook</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<p><strong>AST (Abstract Syntax Tree)</strong>: Tree representation of mathematical expressions.</p>
<p><strong>Assumption</strong>: Constraint on symbol values (e.g., positive, real, integer).</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<p><strong>CAS (Computer Algebra System)</strong>: Software for symbolic mathematics.</p>
<p><strong>Canonical Form</strong>: Standard representation of expressions for reliable equality.</p>
<p><strong>Cache Line</strong>: 64-byte memory chunk that CPUs load at once.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<p><strong>Domain</strong>: Set of valid input values for a function.</p>
<p><strong>Derivative</strong>: Rate of change of a function.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<p><strong>Expression</strong>: Mathematical formula represented as a tree structure.</p>
<p><strong>Ergonomic API</strong>: User-friendly, intuitive programming interface.</p>
<h2 id="i"><a class="header" href="#i">I</a></h2>
<p><strong>Immutable</strong>: Cannot be changed after creation.</p>
<p><strong>Implicit Multiplication</strong>: <code>2x</code> interpreted as <code>2 * x</code>.</p>
<h2 id="l"><a class="header" href="#l">L</a></h2>
<p><strong>LALRPOP</strong>: Parser generator tool used by MathHook.</p>
<p><strong>LaTeX</strong>: Typesetting system for mathematical notation.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<p><strong>Rational</strong>: Exact fraction representation (numerator/denominator).</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><strong>SIMD</strong>: Single Instruction Multiple Data - parallel computation technique.</p>
<p><strong>Simplification</strong>: Transforming expressions to canonical form.</p>
<p><strong>Symbol</strong>: Mathematical variable (e.g., x, y, θ).</p>
<p><strong>String Interning</strong>: Storing one copy of each unique string for fast comparison.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<p><strong>Thread Safety</strong>: Safe to use from multiple threads simultaneously.</p>
<h2 id="z"><a class="header" href="#z">Z</a></h2>
<p><strong>Zero-Copy</strong>: Processing without making intermediate copies of data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to MathHook will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="unreleased"><a class="header" href="#unreleased">[Unreleased]</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Initial mdBook documentation</li>
<li>Comprehensive usage guides</li>
<li>Architecture documentation</li>
</ul>
<h2 id="010---2024-xx-xx"><a class="header" href="#010---2024-xx-xx">[0.1.0] - 2024-XX-XX</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Initial release</li>
<li>Core expression system</li>
<li>LaTeX and Wolfram Language parsers</li>
<li>Symbolic differentiation</li>
<li>Equation solving (linear, quadratic, polynomial)</li>
<li>Matrix operations</li>
<li>Python bindings (PyO3)</li>
<li>Node.js bindings (NAPI-RS)</li>
<li>Step-by-step educational explanations</li>
<li>SIMD optimizations</li>
<li>Parallel processing support</li>
</ul>
<h3 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h3>
<ul>
<li>Integration still under development</li>
<li>Some special functions not yet implemented</li>
<li>WebAssembly bindings in progress</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>See <a href="appendix/../contributing/development.html">Contributing Guide</a> for how to suggest changes to this changelog.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
