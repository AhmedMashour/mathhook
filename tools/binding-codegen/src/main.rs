use anyhow::Result;
use clap::{Parser, Subcommand};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "binding-codegen")]
#[command(about = "Generate Python/Node.js bindings for mathhook-core")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Scan,
    Analyze,
    Generate {
        #[arg(long)]
        target: Option<String>,
        #[arg(long)]
        dry_run: bool,
    },
    Check,
    Debug {
        #[arg(long, default_value = "Expression")]
        type_name: String,
        #[arg(long)]
        method: Option<String>,
    },
}

fn compute_core_hash() -> Result<String> {
    use sha2::{Digest, Sha256};
    use walkdir::WalkDir;

    let mut hasher = Sha256::new();
    let core_src = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("crates/mathhook-core/src");

    let mut files: Vec<_> = WalkDir::new(&core_src)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path()
                .extension()
                .is_some_and(|ext| ext == "rs" || ext == "lalrpop")
        })
        .collect();

    files.sort_by_key(|e| e.path().to_path_buf());

    for entry in files {
        if let Ok(content) = std::fs::read(entry.path()) {
            hasher.update(&content);
        }
    }

    Ok(hex::encode(hasher.finalize()))
}

fn create_manifest(
    classified: &binding_codegen::ClassifiedApi,
    scanned_impls: &[binding_codegen::ImplInfo],
    files: &std::collections::HashMap<String, String>,
    _target: binding_codegen::Target,
) -> Result<binding_codegen::BindingManifest> {
    let mut manifest = binding_codegen::BindingManifest::new(compute_core_hash()?);

    for type_info in &classified.primary_types {
        let method_count = scanned_impls
            .iter()
            .filter(|impl_block| impl_block.target_type == type_info.name)
            .flat_map(|impl_block| &impl_block.methods)
            .filter(|m| m.is_public)
            .count();

        manifest.add_type(binding_codegen::TypeBindingInfo {
            core_type: type_info.name.clone(),
            python_wrapper: format!("Py{}", type_info.name),
            node_wrapper: format!("Js{}", type_info.name),
            fragments: vec![],
            method_count,
            source_modules: vec![],
        });
    }

    let mut stats = manifest.pattern_stats.clone();
    stats.direct_mappings = files.len();
    manifest.pattern_stats = stats;

    Ok(manifest)
}

fn extract_wrapper_name(content: &str, prefix: &str) -> Option<String> {
    for line in content.lines() {
        let line = line.trim();
        let name = if line.starts_with("pub struct ") {
            line.strip_prefix("pub struct ")
        } else if line.starts_with("pub enum ") {
            line.strip_prefix("pub enum ")
        } else {
            None
        };

        if let Some(rest) = name {
            let type_name = rest.split_whitespace().next()?;
            if type_name.starts_with(prefix) {
                return Some(type_name.to_string());
            }
        }
    }
    None
}

fn generate_mod_file(
    files: &std::collections::HashMap<String, String>,
    target: binding_codegen::Target,
) -> String {
    let prefix = match target {
        binding_codegen::Target::Python => "Py",
        binding_codegen::Target::Node => "Js",
    };

    let mut lines = vec![
        "// AUTO-GENERATED by binding-codegen - DO NOT EDIT".to_string(),
        "// Regenerate with: cargo run -p binding-codegen -- generate".to_string(),
        String::new(),
        "#![allow(dead_code, unused_imports, unused_variables, clippy::all)]".to_string(),
        String::new(),
    ];

    let mut module_names: Vec<_> = files
        .keys()
        .filter(|f| f.ends_with(".rs") && *f != "functions.rs")
        .map(|f| f.trim_end_matches(".rs"))
        .collect();
    module_names.sort();

    for module in &module_names {
        lines.push(format!("pub mod {};", module));
    }

    if files.contains_key("functions.rs") {
        lines.push("pub mod functions;".to_string());
    }

    lines.push(String::new());
    lines.push("// Re-export all wrapper types for cross-module access".to_string());

    let mut wrapper_names: Vec<(String, String)> = Vec::new();
    for module in &module_names {
        let filename = format!("{}.rs", module);
        if let Some(content) = files.get(&filename) {
            if let Some(wrapper_name) = extract_wrapper_name(content, prefix) {
                lines.push(format!("pub use {}::{};", module, wrapper_name));
                wrapper_names.push((module.to_string(), wrapper_name));
            }
        }
    }

    if matches!(target, binding_codegen::Target::Python) {
        lines.push(String::new());
        lines.push("use pyo3::prelude::*;".to_string());
        lines.push(String::new());
        lines.push("/// Register all generated types with the Python module".to_string());
        lines.push("/// Call this from your #[pymodule] function".to_string());
        lines.push(
            "pub fn register_generated_types(m: &Bound<'_, PyModule>) -> PyResult<()> {"
                .to_string(),
        );

        for (_, wrapper_name) in &wrapper_names {
            lines.push(format!("    m.add_class::<{}>()?;", wrapper_name));
        }

        lines.push("    Ok(())".to_string());
        lines.push("}".to_string());
    }

    if matches!(target, binding_codegen::Target::Node) {
        lines.push(String::new());
        lines.push("/// List of all generated wrapper type names".to_string());
        lines.push(
            "/// NAPI-RS auto-exports via #[napi], this constant is for introspection".to_string(),
        );
        lines.push("pub const GENERATED_TYPES: &[&str] = &[".to_string());

        for (_, wrapper_name) in &wrapper_names {
            lines.push(format!("    \"{}\",", wrapper_name));
        }

        lines.push("];".to_string());

        lines.push(String::new());
        lines.push("/// Returns the list of all generated wrapper type names".to_string());
        lines
            .push("/// Equivalent to Python's register_generated_types for API parity".to_string());
        lines.push("#[inline]".to_string());
        lines.push("pub fn register_generated_types() -> &'static [&'static str] {".to_string());
        lines.push("    GENERATED_TYPES".to_string());
        lines.push("}".to_string());
    }

    lines.join("\n")
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Scan => {
            println!("Scanning mathhook-core public API...\n");

            let mathhook_core_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .parent()
                .unwrap()
                .parent()
                .unwrap()
                .join("crates/mathhook-core");

            let api = binding_codegen::scanner::scan_crate(&mathhook_core_path)?;
            let stats = api.stats();

            println!("\n=== Scan Results ===");
            println!("Total items scanned: {}", api.total_items());
            println!("\nTypes:");
            println!("  Structs: {}", stats.total_structs);
            println!("  Enums: {}", stats.total_enums);
            println!("  Total: {}", stats.total_types);
            println!("\nFunctions:");
            println!("  Standalone: {}", stats.total_functions);
            println!("\nImplementations:");
            println!("  Impl blocks: {}", stats.total_impl_blocks);
            println!("  Total methods: {}", stats.total_methods);
            println!("  Public methods: {}", stats.public_methods);
            println!("\nModules: {}", stats.modules);
            println!("\nTrait definitions: {}", api.trait_definitions.len());

            Ok(())
        }
        Commands::Analyze => {
            println!("Analyzing API patterns...");
            binding_codegen::analyzer::analyze()?;
            Ok(())
        }
        Commands::Generate { target, dry_run } => {
            use binding_codegen::{
                classify_all, scanner, BindingConfig, Emitter, NodeEmitter, PythonEmitter, Target,
            };
            use std::fs;

            println!("Generating bindings...");

            let mathhook_core_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .parent()
                .unwrap()
                .parent()
                .unwrap()
                .join("crates/mathhook-core");

            let scanned = scanner::scan_crate(&mathhook_core_path)?;
            let config = BindingConfig::default_config();
            let classified = classify_all(&scanned, &config);

            println!("Classification:");
            println!("  Primary types: {}", classified.primary_types.len());
            println!("  Helper types: {}", classified.helper_types.len());
            println!("  Skipped types: {}", classified.skipped_types.len());
            println!(
                "  Standalone functions: {}",
                classified.standalone_functions.len()
            );
            println!("  Trait definitions: {}", scanned.trait_definitions.len());

            let (target_enum, target_str, output_dir) = match target.as_deref() {
                Some("python") | None => (
                    Target::Python,
                    "python",
                    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                        .parent()
                        .unwrap()
                        .parent()
                        .unwrap()
                        .join("crates/mathhook-python/src/generated"),
                ),
                Some("node") => (
                    Target::Node,
                    "node",
                    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                        .parent()
                        .unwrap()
                        .parent()
                        .unwrap()
                        .join("crates/mathhook-node/src/generated"),
                ),
                Some(other) => {
                    anyhow::bail!("Unknown target: {}", other);
                }
            };

            println!("\nGenerating {} bindings...", target_str);

            let simple_enum_types: Vec<String> = scanned
                .types
                .iter()
                .filter(|t| t.is_simple_enum())
                .map(|t| t.name.clone())
                .collect();

            let emitter: Box<dyn Emitter> = if target_str == "python" {
                Box::new(PythonEmitter::with_simple_enum_types(simple_enum_types))
            } else {
                Box::new(NodeEmitter::with_simple_enum_types(simple_enum_types))
            };

            let mut files = emitter.generate_all(&classified, &scanned);

            let mod_content = generate_mod_file(&files, target_enum);
            files.insert("mod.rs".to_string(), mod_content);

            if dry_run {
                println!("Dry run - would generate {} files:", files.len());
                for (filename, content) in &files {
                    println!("  {} ({} bytes)", filename, content.len());
                }
            } else {
                if output_dir.exists() {
                    let old_files: Vec<_> = fs::read_dir(&output_dir)?
                        .filter_map(|e| e.ok())
                        .filter(|e| {
                            e.path()
                                .extension()
                                .is_some_and(|ext| ext == "rs" || ext == "json")
                        })
                        .collect();
                    let old_count = old_files.len();
                    for entry in old_files {
                        fs::remove_file(entry.path())?;
                    }
                    if old_count > 0 {
                        println!("  Cleaned up {} old files", old_count);
                    }
                }
                fs::create_dir_all(&output_dir)?;

                for (filename, content) in &files {
                    let file_path = output_dir.join(filename);
                    fs::write(&file_path, content)?;
                    println!("  Generated: {}", file_path.display());
                }

                let manifest = create_manifest(&classified, &scanned.impls, &files, target_enum)?;
                let manifest_path = output_dir.join("manifest.json");
                manifest.save(&manifest_path)?;
                println!("\n  Manifest: {}", manifest_path.display());
                println!("  Core hash: {}", &manifest.core_hash[..16]);
                println!("  Generated: {}", manifest.generated_at);

                println!("\n Successfully generated {} binding files", files.len());
            }

            Ok(())
        }
        Commands::Check => {
            use binding_codegen::BindingManifest;

            println!("Checking binding freshness...\n");

            let current_hash = compute_core_hash()?;
            let mut all_fresh = true;

            for (target_name, manifest_path) in &[
                (
                    "Python",
                    "crates/mathhook-python/src/generated/manifest.json",
                ),
                (
                    "Node.js",
                    "crates/mathhook-node/src/generated/manifest.json",
                ),
            ] {
                let full_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                    .parent()
                    .unwrap()
                    .parent()
                    .unwrap()
                    .join(manifest_path);

                if !full_path.exists() {
                    println!("  {}: No manifest found", target_name);
                    println!(
                        "   Generate with: cargo run -p binding-codegen -- generate --target {}",
                        target_name.to_lowercase()
                    );
                    all_fresh = false;
                    continue;
                }

                match BindingManifest::load(&full_path) {
                    Ok(manifest) => {
                        if manifest.core_hash == current_hash {
                            println!(" {}: Bindings are up to date", target_name);
                            println!("   Hash: {}...", &current_hash[..16]);
                            println!("   Generated: {}", manifest.generated_at);
                        } else {
                            println!(" {}: Bindings are STALE", target_name);
                            println!("   Current hash: {}...", &current_hash[..16]);
                            println!("   Manifest hash: {}...", &manifest.core_hash[..16]);
                            println!(
                                "   Regenerate with: cargo run -p binding-codegen -- generate --target {}",
                                target_name.to_lowercase()
                            );
                            all_fresh = false;
                        }
                    }
                    Err(e) => {
                        println!("  {}: Failed to load manifest: {}", target_name, e);
                        all_fresh = false;
                    }
                }
                println!();
            }

            if !all_fresh {
                std::process::exit(1);
            }

            Ok(())
        }
        Commands::Debug { type_name, method } => {
            use binding_codegen::analyzer::{analyze_method_with_context, analyze_type};
            use quote::ToTokens;

            println!("Debugging impl blocks for type: {}\n", type_name);

            let mathhook_core_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .parent()
                .unwrap()
                .parent()
                .unwrap()
                .join("crates/mathhook-core");

            let api = binding_codegen::scanner::scan_crate(&mathhook_core_path)?;

            if let Some(method_name) = method {
                println!(
                    "=== Debugging method '{}' on {} ===\n",
                    method_name, type_name
                );
                for imp in &api.impls {
                    if imp.target_type == type_name {
                        for m in &imp.methods {
                            if m.name == method_name {
                                println!("Found: {} (public: {})", m.name, m.is_public);
                                println!("  Trait: {:?}", imp.trait_name);
                                println!("  Inputs ({}):", m.signature.inputs.len());
                                for (name, ty) in &m.signature.inputs {
                                    let ty_str = ty.to_token_stream().to_string();
                                    println!("    {}: {}", name, ty_str);
                                    let analyzed = analyze_type(ty);
                                    println!(
                                        "      -> {:?} (supported: {})",
                                        analyzed,
                                        analyzed.is_supported()
                                    );
                                }
                                if let Some(out) = &m.signature.output {
                                    let out_str = out.to_token_stream().to_string();
                                    println!("  Output: {}", out_str);
                                    let analyzed = analyze_type(out);
                                    println!(
                                        "    -> {:?} (supported: {})",
                                        analyzed,
                                        analyzed.is_supported()
                                    );
                                }

                                let analyzed_method =
                                    analyze_method_with_context(m, Some(type_name.clone()));
                                println!(
                                    "\n  Overall method is_supported: {}",
                                    analyzed_method.is_supported
                                );
                                println!();
                            }
                        }
                    }
                }
            } else {
                println!("=== All impl blocks for {} ===\n", type_name);
                let mut total_methods = 0;
                for imp in &api.impls {
                    if imp.target_type == type_name {
                        let trait_info = imp.trait_name.as_deref().unwrap_or("(inherent impl)");
                        let pub_methods: Vec<_> = imp
                            .methods
                            .iter()
                            .filter(|m| m.is_public)
                            .map(|m| m.name.as_str())
                            .collect();
                        total_methods += pub_methods.len();
                        println!("  {} - {} public methods:", trait_info, pub_methods.len());
                        for m in &pub_methods {
                            println!("    - {}", m);
                        }
                        println!();
                    }
                }
                println!("Total public methods found: {}", total_methods);
            }

            Ok(())
        }
    }
}
